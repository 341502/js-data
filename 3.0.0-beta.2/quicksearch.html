<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"Collection.js.html":{"id":"Collection.js.html","title":"Source: Collection.js","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentContainerDataStoreLinkedCollectionMapperQueryRecordSchema Source: Collection.js import utils from './utils' import Component from './Component' import Query from './Query' import Index from '../lib/mindex/index' const DOMAIN = 'Collection' const COLLECTION_DEFAULTS = { /** * Field to be used as the unique identifier for records in this collection. * Defaults to `&quot;id&quot;` unless {@link Collection#mapper} is set, in which case * this will default to {@link Mapper#idAttribute}. * * @name Collection#idAttribute * @type {string} * @default &quot;id&quot; */ idAttribute: 'id', /** * What to do when inserting a record into this Collection that shares a * primary key with a record already in this Collection. * * Possible values: * - merge * - replace * * Merge: * * Recursively shallow copy properties from the new record onto the existing * record. * * Replace: * * Shallow copy top-level properties from the new record onto the existing * record. Any top-level own properties of the existing record that are _not_ * on the new record will be removed. * * @name Collection#onConflict * @type {string} * @default &quot;merge&quot; */ onConflict: 'merge' } /** * An ordered set of {@link Record} instances. * * @example * import {Collection, Record} from 'js-data' * const user1 = new Record({ id: 1 }) * const user2 = new Record({ id: 2 }) * const UserCollection = new Collection([user1, user2]) * UserCollection.get(1) === user1 // true * * @class Collection * @extends Component * @type {Function} * @param {Array} [records] Initial set of records to insert into the * collection. * @param {Object} [opts] Configuration options. * @param {string} [opts.idAttribute] See {@link Collection#idAttribute}. * @param {string} [opts.onConflict=&quot;merge&quot;] See {@link Collection#onConflict}. * @param {string} [opts.mapper] See {@link Collection#mapper}. */ export default Component.extend({ constructor: function Collection (records, opts) { const self = this utils.classCallCheck(self, Collection) Collection.__super__.call(self) if (records &amp;&amp; !utils.isArray(records)) { opts = records records = [] } if (utils.isString(opts)) { opts = { idAttribute: opts } } // Default values for arguments records || (records = []) opts || (opts = {}) /** * Default Mapper for this collection. Optional. If a Mapper is provided, then * the collection will use the {@link Mapper#idAttribute} setting, and will * wrap records in {@link Mapper#recordClass}. * * @example * import {Collection, Mapper} from 'js-data' * * class MyMapperClass extends Mapper { * foo () { return 'bar' } * } * const myMapper = new MyMapperClass() * const collection = new Collection(null, { mapper: myMapper }) * * @name Collection#mapper * @type {Mapper} * @default null */ Object.defineProperties(self, { mapper: { value: undefined, writable: true }, queryClass: { value: undefined, writable: true } }) // Apply user-provided configuration utils.fillIn(self, opts) // Fill in any missing options with the defaults utils.fillIn(self, utils.copy(COLLECTION_DEFAULTS)) if (!self.queryClass) { self.queryClass = Query } const idAttribute = self.recordId() Object.defineProperties(self, { /** * The main index, which uses @{link Collection#recordId} as the key. * * @name Collection#index * @type {Index} */ index: { value: new Index([idAttribute], { hashCode (obj) { return utils.get(obj, idAttribute) } }) }, /** * Object that holds the secondary indexes of this collection. * * @name Collection#indexes * @type {Object.&lt;string, Index&gt;} */ indexes: { value: {} } }) // Insert initial data into the collection if (records) { self.add(records) } }, /** * Used to bind to events emitted by records in this Collection. * * @method Collection#_onRecordEvent * @since 3.0.0 * @private * @param {...*} [arg] Args passed to {@link Collection#emit}. */ _onRecordEvent (...args) { this.emit(...args) }, /** * Insert the provided record or records. * * If a record is already in the collection then the provided record will * either merge with or replace the existing record based on the value of the * `onConflict` option. * * The collection's secondary indexes will be updated as each record is * visited. * * @method Collection#add * @since 3.0.0 * @param {(Object|Object[]|Record|Record[])} data The record or records to insert. * @param {Object} [opts] Configuration options. * @param {string} [opts.onConflict] What to do when a record is already in * the collection. Possible values are `merge` or `replace`. * @returns {(Object|Object[]|Record|Record[])} The added record or records. */ add (records, opts) { const self = this // Default values for arguments opts || (opts = {}) // Fill in &quot;opts&quot; with the Collection's configuration utils._(opts, self) records = self.beforeAdd(records, opts) || records // Track whether just one record or an array of records is being inserted let singular = false const idAttribute = self.recordId() if (!utils.isArray(records)) { if (utils.isObject(records)) { records = [records] singular = true } else { throw utils.err(`${DOMAIN}#add`, 'records')(400, 'object or array', records) } } // Map the provided records to existing records. // New records will be inserted. If any records map to existing records, // they will be merged into the existing records according to the onConflict // option. records = records.map(function (record) { let id = self.recordId(record) if (!utils.isSorN(id)) { throw utils.err(`${DOMAIN}#add`, `record.${idAttribute}`)(400, 'string or number', id) } // Grab existing record if there is one const existing = self.get(id) // If the currently visited record is just a reference to an existing // record, then there is nothing to be done. Exit early. if (record === existing) { return existing } if (existing) { // Here, the currently visited record corresponds to a record already // in the collection, so we need to merge them const onConflict = opts.onConflict || self.onConflict if (onConflict === 'merge') { utils.deepMixIn(existing, record) } else if (onConflict === 'replace') { utils.forOwn(existing, (value, key) =&gt; { if (key !== idAttribute &amp;&amp; !record.hasOwnProperty(key)) { delete existing[key] } }) existing.set(record) } else { throw utils.err(`${DOMAIN}#add`, 'opts.onConflict')(400, 'one of (merge, replace)', onConflict, true) } record = existing // Update all indexes in the collection self.updateIndexes(record) } else { // Here, the currently visted record does not correspond to any record // in the collection, so (optionally) instantiate this record and insert // it into the collection record = self.mapper ? self.mapper.createRecord(record, opts) : record self.index.insertRecord(record) utils.forOwn(self.indexes, function (index, name) { index.insertRecord(record) }) if (record &amp;&amp; utils.isFunction(record.on)) { record.on('all', self._onRecordEvent, self) } } return record }) // Finally, return the inserted data const result = singular ? records[0] : records // TODO: Make this more performant (batch events?) self.emit('add', result) return self.afterAdd(records, opts, result) || result }, /** * Lifecycle hook called by {@link Collection#add}. If this method returns a * value then {@link Collection#add} will return that same value. * * @method Collection#method * @since 3.0.0 * @param {(Object|Object[]|Record|Record[])} result The record or records * that were added to this Collection by {@link Collection#add}. * @param {Object} opts The `opts` argument passed to {@link Collection#add}. */ afterAdd () {}, /** * Lifecycle hook called by {@link Collection#remove}. If this method returns * a value then {@link Collection#remove} will return that same value. * * @method Collection#afterRemove * @since 3.0.0 * @param {(string|number)} id The `id` argument passed to {@link Collection#remove}. * @param {Object} opts The `opts` argument passed to {@link Collection#remove}. * @param {Object} record The result that will be returned by {@link Collection#remove}. */ afterRemove () {}, /** * Lifecycle hook called by {@link Collection#removeAll}. If this method * returns a value then {@link Collection#removeAll} will return that same * value. * * @method Collection#afterRemoveAll * @since 3.0.0 * @param {Object} query The `query` argument passed to {@link Collection#removeAll}. * @param {Object} opts The `opts` argument passed to {@link Collection#removeAll}. * @param {Object} records The result that will be returned by {@link Collection#removeAll}. */ afterRemoveAll () {}, /** * Lifecycle hook called by {@link Collection#add}. If this method returns a * value then the `records` argument in {@link Collection#add} will be * re-assigned to the returned value. * * @method Collection#beforeAdd * @since 3.0.0 * @param {(Object|Object[]|Record|Record[])} records The `records` argument passed to {@link Collection#add}. * @param {Object} opts The `opts` argument passed to {@link Collection#add}. */ beforeAdd () {}, /** * Lifecycle hook called by {@link Collection#remove}. * * @method Collection#beforeRemove * @since 3.0.0 * @param {(string|number)} id The `id` argument passed to {@link Collection#remove}. * @param {Object} opts The `opts` argument passed to {@link Collection#remove}. */ beforeRemove () {}, /** * Lifecycle hook called by {@link Collection#removeAll}. * * @method Collection#beforeRemoveAll * @since 3.0.0 * @param {Object} query The `query` argument passed to {@link Collection#removeAll}. * @param {Object} opts The `opts` argument passed to {@link Collection#removeAll}. */ beforeRemoveAll () {}, /** * Find all records between two boundaries. * * Shortcut for `collection.query().between(18, 30, { index: 'age' }).run()` * * @example &lt;caption&gt;Get all users ages 18 to 30&lt;/caption&gt; * const users = collection.between(18, 30, { index: 'age' }) * * @example &lt;caption&gt;Same as above&lt;/caption&gt; * const users = collection.between([18], [30], { index: 'age' }) * * @method Collection#between * @since 3.0.0 * @param {Array} leftKeys Keys defining the left boundary. * @param {Array} rightKeys Keys defining the right boundary. * @param {Object} [opts] Configuration options. * @param {string} [opts.index] Name of the secondary index to use in the * query. If no index is specified, the main index is used. * @param {boolean} [opts.leftInclusive=true] Whether to include records * on the left boundary. * @param {boolean} [opts.rightInclusive=false] Whether to include records * on the left boundary. * @param {boolean} [opts.limit] Limit the result to a certain number. * @param {boolean} [opts.offset] The number of resulting records to skip. * @returns {Array} The result. */ between (leftKeys, rightKeys, opts) { return this.query().between(leftKeys, rightKeys, opts).run() }, /** * Create a new secondary index on the contents of the collection. * * @example &lt;caption&gt;Index users by age&lt;/caption&gt; * collection.createIndex('age') * * @example &lt;caption&gt;Index users by status and role&lt;/caption&gt; * collection.createIndex('statusAndRole', ['status', 'role']) * * @method Collection#createIndex * @since 3.0.0 * @param {string} name - The name of the new secondary index. * @param {string[]} [fieldList] - Array of field names to use as the key or * compound key of the new secondary index. If no fieldList is provided, then * the name will also be the field that is used to index the collection. * @returns {Collection} A reference to itself for chaining. */ createIndex (name, fieldList, opts) { const self = this if (utils.isString(name) &amp;&amp; fieldList === undefined) { fieldList = [name] } opts || (opts = {}) opts.hashCode = opts.hashCode || function (obj) { return self.recordId(obj) } const index = self.indexes[name] = new Index(fieldList, opts) self.index.visitAll(index.insertRecord, index) return self }, /** * Find the record or records that match the provided query or pass the * provided filter function. * * Shortcut for `collection.query().filter(queryOrFn[, thisArg]).run()` * * @example &lt;caption&gt;Get the draft posts created less than three months&lt;/caption&gt; * const posts = collection.filter({ * where: { * status: { * '==': 'draft' * }, * created_at_timestamp: { * '&gt;=': (new Date().getTime() - (1000 * 60 * 60 * 24 * 30 * 3)) // 3 months ago * } * } * }) * * @example &lt;caption&gt;Use a custom filter function&lt;/caption&gt; * const posts = collection.filter(function (post) { * return post.isReady() * }) * * @method Collection#filter * @since 3.0.0 * @param {(Object|Function)} [queryOrFn={}] - Selection query or filter * function. * @param {Object} [thisArg] - Context to which to bind `queryOrFn` if * `queryOrFn` is a function. * @returns {Array} The result. */ filter (query, thisArg) { return this.query().filter(query, thisArg).run() }, /** * Iterate over all records. * * @example * collection.forEach(function (record) { * // do something * }) * * @method Collection#forEach * @since 3.0.0 * @param {Function} forEachFn - Iteration function. * @param {*} [thisArg] - Context to which to bind `forEachFn`. * @returns {Array} The result. */ forEach (cb, thisArg) { this.index.visitAll(cb, thisArg) }, /** * Get the record with the given id. * * @method Collection#get * @since 3.0.0 * @param {(string|number)} id - The primary key of the record to get. * @returns {(Object|Record)} The record with the given id. */ get (id) { const instances = this.query().get(id).run() return instances.length ? instances[0] : undefined }, /** * Find the record or records that match the provided keyLists. * * Shortcut for `collection.query().getAll(keyList1, keyList2, ...).run()` * * @example &lt;caption&gt;Get the posts where &quot;status&quot; is &quot;draft&quot; or &quot;inReview&quot;&lt;/caption&gt; * const posts = collection.getAll('draft', 'inReview', { index: 'status' }) * * @example &lt;caption&gt;Same as above&lt;/caption&gt; * const posts = collection.getAll(['draft'], ['inReview'], { index: 'status' }) * * @method Collection#getAll * @since 3.0.0 * @param {...Array} [keyList] - Provide one or more keyLists, and all * records matching each keyList will be retrieved. If no keyLists are * provided, all records will be returned. * @param {Object} [opts] - Configuration options. * @param {string} [opts.index] - Name of the secondary index to use in the * query. If no index is specified, the main index is used. * @returns {Array} The result. */ getAll (...args) { return this.query().getAll(...args).run() }, /** * Return the index with the given name. If no name is provided, return the * main index. Throws an error if the specified index does not exist. * * @method Collection#getIndex * @since 3.0.0 * @param {string} [name] The name of the index to retrieve. */ getIndex (name) { const index = name ? this.indexes[name] : this.index if (!index) { throw utils.err(`${DOMAIN}#getIndex`, name)(404, 'index') } return index }, /** * Limit the result. * * Shortcut for `collection.query().limit(maximumNumber).run()` * * @example * const posts = collection.limit(10) * * @method Collection#limit * @since 3.0.0 * @param {number} num - The maximum number of records to keep in the result. * @returns {Array} The result. */ limit (num) { return this.query().limit(num).run() }, /** * Apply a mapping function to all records. * * @example * const names = collection.map(function (user) { * return user.name * }) * * @method Collection#map * @since 3.0.0 * @param {Function} mapFn - Mapping function. * @param {*} [thisArg] - Context to which to bind `mapFn`. * @returns {Array} The result of the mapping. */ map (cb, thisArg) { const data = [] this.index.visitAll(function (value) { data.push(cb.call(thisArg, value)) }) return data }, /** * Return the result of calling the specified function on each record in this * collection's main index. * * @method Collection#mapCall * @since 3.0.0 * @param {string} funcName - Name of function to call * @parama {...*} [args] - Remaining arguments to be passed to the function. * @returns {Array} The result. */ mapCall (funcName, ...args) { const data = [] this.index.visitAll(function (record) { data.push(record[funcName](...args)) }) return data }, /** * Return the primary key of the given, or if no record is provided, return the * name of the field that holds the primary key of records in this Collection. * * @method Collection#recordId * @since 3.0.0 * @param {(Object|Record)} [record] The record whose primary key is to be * returned. * @returns {(string|number)} Primary key or name of field that holds primary * key. */ recordId (record) { const self = this if (record) { return utils.get(record, self.recordId()) } return self.mapper ? self.mapper.idAttribute : self.idAttribute }, /** * Create a new query to be executed against the contents of the collection. * The result will be all or a subset of the contents of the collection. * * @example &lt;caption&gt;Grab page 2 of users between ages 18 and 30&lt;/caption&gt; * collection.query() * .between(18, 30, { index: 'age' }) // between ages 18 and 30 * .skip(10) // second page * .limit(10) // page size * .run() * * @method Collection#query * @since 3.0.0 * @returns {Query} New query object. */ query () { const Ctor = this.queryClass return new Ctor(this) }, /** * Reduce the data in the collection to a single value and return the result. * * @example * const totalVotes = collection.reduce(function (prev, record) { * return prev + record.upVotes + record.downVotes * }, 0) * * @method Collection#reduce * @since 3.0.0 * @param {Function} cb - Reduction callback. * @param {*} initialValue - Initial value of the reduction. * @returns {*} The result. */ reduce (cb, initialValue) { const data = this.getAll() return data.reduce(cb, initialValue) }, /** * Remove the record with the given id from this Collection. * * @method Collection#remove * @since 3.0.0 * @param {(string|number)} id - The primary key of the record to be removed. * @param {Object} [opts] - Configuration options. * @returns {Object|Record} The removed record, if any. */ remove (id, opts) { const self = this // Default values for arguments opts || (opts = {}) self.beforeRemove(id, opts) const record = self.get(id) // The record is in the collection, remove it if (record) { self.index.removeRecord(record) utils.forOwn(self.indexes, function (index, name) { index.removeRecord(record) }) if (record &amp;&amp; utils.isFunction(record.off)) { record.off('all', self._onRecordEvent, self) self.emit('remove', record) } } return self.afterRemove(id, opts, record) || record }, /** * Remove the record selected by &quot;query&quot; from this collection. * * @method Collection#removeAll * @since 3.0.0 * @param {Object} [query={}] - Selection query. * @param {Object} [query.where] - Filtering criteria. * @param {number} [query.skip] - Number to skip. * @param {number} [query.limit] - Number to limit to. * @param {Array} [query.orderBy] - Sorting criteria. * @param {Object} [opts] - Configuration options. * @returns {(Object[]|Record[])} The removed records, if any. */ removeAll (query, opts) { const self = this // Default values for arguments opts || (opts = {}) self.beforeRemoveAll(query, opts) const records = self.filter(query) // Remove each selected record from the collection records.forEach(function (item) { self.remove(self.recordId(item), opts) }) return self.afterRemoveAll(query, opts, records) || records }, /** * Skip a number of results. * * Shortcut for `collection.query().skip(numberToSkip).run()` * * @example * const posts = collection.skip(10) * * @method Collection#skip * @since 3.0.0 * @param {number} num - The number of records to skip. * @returns {Array} The result. */ skip (num) { return this.query().skip(num).run() }, /** * Return the plain JSON representation of all items in this collection. * Assumes records in this collection have a toJSON method. * * @method Collection#toJSON * @since 3.0.0 * @param {Object} [opts] - Configuration options. * @param {string[]} [opts.with] - Array of relation names or relation fields * to include in the representation. * @returns {Array} The records. */ toJSON (opts) { return this.mapCall('toJSON', opts) }, /** * Update a record's position in a single index of this collection. See * {@link Collection#updateIndexes} to update a record's position in all * indexes at once. * * @method Collection#updateIndex * @since 3.0.0 * @param {Object} record - The record to update. * @param {Object} [opts] - Configuration options. * @param {string} [opts.index] The index in which to update the record's * position. If you don't specify an index then the record will be updated * in the main index. */ updateIndex (record, opts) { opts || (opts = {}) this.getIndex(opts.index).updateRecord(record) }, /** * TODO * * @method Collection#updateIndexes * @since 3.0.0 * @param {Object} record - TODO * @param {Object} [opts] - Configuration options. */ updateIndexes (record) { const self = this self.index.updateRecord(record) utils.forOwn(self.indexes, function (index, name) { index.updateRecord(record) }) } }) × Search results Close api.js-data.io • js-data.io "},"Component.js.html":{"id":"Component.js.html","title":"Source: Component.js","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentContainerDataStoreLinkedCollectionMapperQueryRecordSchema Source: Component.js import utils from './utils' /** * @class Component */ export default function Component () { /** * Event listeners attached to this Component. __Do not modify.__ Use * {@link Component#on} and {@link Component#off} instead. * * @name Component#_listeners * @instance * @since 3.0.0 * @type {Object} */ Object.defineProperty(this, '_listeners', { value: {} }) } /** * Create a subclass of this component. * * @method Component.extend * @static * @param {Object} [props={}] Properties to add to the prototype of the * subclass. * @param {Object} [classProps={}] Static properties to add to the subclass. * @returns {Constructor} Subclass of this component. * @since 3.0.0 */ Component.extend = utils.extend /** * Log the provided values at the &quot;debug&quot; level. * * @method Component#dbg * @param {...*} [args] Values to log. * @since 3.0.0 */ /** * Log the provided values. By default sends values to `console[level]`. * * @method Component#log * @param {string} level Log level * @param {...*} [args] Values to log. * @since 3.0.0 */ utils.logify(Component.prototype) /** * Register a new event listener on this Component. * * @example &lt;caption&gt;Listen for all &quot;afterCreate&quot; events in a DataStore&lt;/caption&gt; * store.on('afterCreate', (mapperName, props, opts, result) =&gt; { * console.log(mapperName) // &quot;post&quot; * console.log(props.id) // undefined * console.log(result.id) // 1234 * }) * store.create('post', { title: 'Modeling your data' }).then((post) =&gt; { * console.log(post.id) // 1234 * }) * * @example &lt;caption&gt;Listen for the &quot;add&quot; event on a collection&lt;/caption&gt; * collection.on('add', (records) =&gt; { * console.log(records) // [...] * }) * * @example &lt;caption&gt;Listen for &quot;change&quot; events on a record&lt;/caption&gt; * post.on('change', (record, changes) =&gt; { * console.log(changes) // { changed: { title: 'Modeling your data' } } * }) * post.title = 'Modeling your data' * * @method Component#on * @param {string} event Name of event to subsribe to. * @param {Function} listener Listener function to handle the event. * @param {*} [ctx] Optional content in which to invoke the listener. * @since 3.0.0 */ /** * Remove an event listener from this Component. If no listener is provided, * then all listeners for the specified event will be removed. If no event is * specified then all listeners for all events will be removed. * * @example &lt;caption&gt;Remove a listener to a single event&lt;/caption&gt; * collection.off('add', handler) * * @example &lt;caption&gt;Remove all listeners to a single event&lt;/caption&gt; * record.off('change') * * @example &lt;caption&gt;Remove all listeners to all events&lt;/caption&gt; * store.off() * * @method Component#off * @param {string} [event] Name of event to unsubsribe to. * @param {Function} [listener] Listener to remove. * @since 3.0.0 */ /** * Trigger an event on this Component. * * @example * collection.on('foo', (msg) =&gt; { * console.log(msg) // &quot;bar&quot; * }) * collection.emit('foo', 'bar') * * @example * store.on('foo', (msg, val1, val2) =&gt; { * console.log(msg, val1, val2) // &quot;bar&quot; &quot;beep&quot; &quot;boop&quot; * }) * store.emit('foo', 'bar', 'beep', 'boop') * * @method Component#emit * @param {string} event Name of event to emit. * @param {...*} [args] Arguments to pass to any listeners. * @since 3.0.0 */ utils.eventify( Component.prototype, function () { return this._listeners }, function (value) { this._listeners = value } ) × Search results Close api.js-data.io • js-data.io "},"Container.js.html":{"id":"Container.js.html","title":"Source: Container.js","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentContainerDataStoreLinkedCollectionMapperQueryRecordSchema Source: Container.js import utils from './utils' import Component from './Component' import { belongsToType, hasManyType, hasOneType } from './decorators' import Mapper from './Mapper' const DOMAIN = 'Container' const toProxy = [ /** * Wrapper for {@link Mapper#count}. * * @example &lt;caption&gt;Get the number of published blog posts&lt;/caption&gt; * import {Container} from 'js-data' * import RethinkDBAdapter from 'js-data-rethinkdb' * const store = new Container() * store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }) * store.defineMapper('post') * * store.count('post', { status: 'published' }).then((numPublished) =&gt; { * console.log(numPublished) // e.g. 45 * }) * * @method Container#count * @param {string} name Name of the {@link Mapper} to target. * @param {Object} [query] See {@link Mapper#count}. * @param {Object} [opts] See {@link Mapper#count}. * @returns {Promise} See {@link Mapper#count}. * @see Mapper#count * @since 3.0.0 */ 'count', /** * Wrapper for {@link Mapper#create}. * * @example &lt;caption&gt;Create and save a new blog post&lt;/caption&gt; * import {Container} from 'js-data' * import RethinkDBAdapter from 'js-data-rethinkdb' * const store = new Container() * store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }) * store.defineMapper('post') * * store.create('post', { * title: 'Modeling your data', * status: 'draft' * }).then((post) =&gt; { * console.log(post) // { id: 1234, status: 'draft', ... } * }) * * @method Container#create * @param {string} name Name of the {@link Mapper} to target. * @param {Object} props See {@link Mapper#create}. * @param {Object} [opts] See {@link Mapper#create}. * @returns {Promise} See {@link Mapper#create}. * @see Mapper#create * @since 3.0.0 */ 'create', /** * Wrapper for {@link Mapper#createMany}. * * @example &lt;caption&gt;Create and save several new blog posts&lt;/caption&gt; * import {Container} from 'js-data' * import RethinkDBAdapter from 'js-data-rethinkdb' * const store = new Container() * store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }) * store.defineMapper('post') * * store.createMany('post', [{ * title: 'Modeling your data', * status: 'draft' * }, { * title: 'Reading data', * status: 'draft' * }]).then((posts) =&gt; { * console.log(posts[0]) // { id: 1234, status: 'draft', ... } * console.log(posts[1]) // { id: 1235, status: 'draft', ... } * }) * * @method Container#createMany * @param {string} name Name of the {@link Mapper} to target. * @param {Record[]} records See {@link Mapper#createMany}. * @param {Object} [opts] See {@link Mapper#createMany}. * @returns {Promise} See {@link Mapper#createMany}. * @see Mapper#createMany * @since 3.0.0 */ 'createMany', /** * Wrapper for {@link Mapper#createRecord}. * * __Note:__ This method does __not__ interact with any adapter, and does * __not__ save any data. It only creates new objects in memory. * * @example &lt;caption&gt;Create empty unsaved record instance&lt;/caption&gt; * import {Container} from 'js-data' * const store = new Container() * store.defineMapper('post') * const post = PostService.createRecord() * * @method Container#createRecord * @param {string} name Name of the {@link Mapper} to target. * @param {Object|Object[]} props See {@link Mapper#createRecord}. * @param {Object} [opts] See {@link Mapper#createRecord}. * @returns {Promise} See {@link Mapper#createRecord}. * @see Mapper#createRecord * @since 3.0.0 */ 'createRecord', /** * Wrapper for {@link Mapper#dbg}. * * @method Container#dbg * @param {string} name Name of the {@link Mapper} to target. * @param {...*} args See {@link Mapper#dbg}. * @see Mapper#dbg * @since 3.0.0 */ 'dbg', /** * Wrapper for {@link Mapper#destroy}. * * @example &lt;caption&gt;Destroy a specific blog post&lt;/caption&gt; * import {Container} from 'js-data' * import RethinkDBAdapter from 'js-data-rethinkdb' * const store = new Container() * store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }) * store.defineMapper('post') * * store.destroy('post', 1234).then(() =&gt; { * // Blog post #1234 has been destroyed * }) * * @method Container#destroy * @param {string} name Name of the {@link Mapper} to target. * @param {(string|number)} id See {@link Mapper#destroy}. * @param {Object} [opts] See {@link Mapper#destroy}. * @returns {Promise} See {@link Mapper#destroy}. * @see Mapper#destroy * @since 3.0.0 */ 'destroy', /** * Wrapper for {@link Mapper#destroyAll}. * * @example &lt;caption&gt;Destroy all &quot;draft&quot; blog posts&lt;/caption&gt; * import {Container} from 'js-data' * import RethinkDBAdapter from 'js-data-rethinkdb' * const store = new Container() * store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }) * store.defineMapper('post') * * store.destroyAll('post', { status: 'draft' }).then(() =&gt; { * // All &quot;draft&quot; blog posts have been destroyed * }) * * @method Container#destroyAll * @param {string} name Name of the {@link Mapper} to target. * @param {Object} [query] See {@link Mapper#destroyAll}. * @param {Object} [opts] See {@link Mapper#destroyAll}. * @returns {Promise} See {@link Mapper#destroyAll}. * @see Mapper#destroyAll * @since 3.0.0 */ 'destroyAll', /** * Wrapper for {@link Mapper#find}. * * @example * import {Container} from 'js-data' * import RethinkDBAdapter from 'js-data-rethinkdb' * const store = new Container() * store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }) * store.defineMapper('post') * * store.find('post', 1).then((post) =&gt; { * console.log(post) // { id: 1, ...} * }) * * @method Container#find * @param {string} name Name of the {@link Mapper} to target. * @param {(string|number)} id See {@link Mapper#find}. * @param {Object} [opts] See {@link Mapper#find}. * @returns {Promise} See {@link Mapper#find}. * @see Mapper#find * @since 3.0.0 */ 'find', /** * Wrapper for {@link Mapper#createRecord}. * * @example &lt;caption&gt;Find all &quot;published&quot; blog posts&lt;/caption&gt; * import {Container} from 'js-data' * import RethinkDBAdapter from 'js-data-rethinkdb' * const store = new Container() * store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }) * store.defineMapper('post') * * store.findAll('post', { status: 'published' }).then((posts) =&gt; { * console.log(posts) // [{ id: 1, ...}, ...] * }) * * @method Container#findAll * @param {string} name Name of the {@link Mapper} to target. * @param {Object} [query] See {@link Mapper#findAll}. * @param {Object} [opts] See {@link Mapper#findAll}. * @returns {Promise} See {@link Mapper#findAll}. * @see Mapper#findAll * @since 3.0.0 */ 'findAll', /** * Wrapper for {@link Mapper#getSchema}. * * @method Container#getSchema * @param {string} name Name of the {@link Mapper} to target. * @returns {Schema} See {@link Mapper#getSchema}. * @see Mapper#getSchema * @since 3.0.0 */ 'getSchema', /** * Wrapper for {@link Mapper#is}. * * @example * import {Container} from 'js-data' * const store = new Container() * store.defineMapper('post') * const post = store.createRecord() * * console.log(store.is('post', post)) // true * // Equivalent to what's above * console.log(post instanceof store.getMapper('post').recordClass) // true * * @method Container#is * @param {string} name Name of the {@link Mapper} to target. * @param {Object|Record} record See {@link Mapper#is}. * @returns {boolean} See {@link Mapper#is}. * @see Mapper#is * @since 3.0.0 */ 'is', /** * Wrapper for {@link Mapper#log}. * * @method Container#log * @param {string} name Name of the {@link Mapper} to target. * @param {...*} args See {@link Mapper#log}. * @see Mapper#log * @since 3.0.0 */ 'log', /** * Wrapper for {@link Mapper#sum}. * * @example * import {Container} from 'js-data' * import RethinkDBAdapter from 'js-data-rethinkdb' * const store = new Container() * store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }) * store.defineMapper('purchase_order') * * store.sum('purchase_order', 'amount', { status: 'paid' }).then((amountPaid) =&gt; { * console.log(amountPaid) // e.g. 451125.34 * }) * * @method Container#sum * @param {string} name Name of the {@link Mapper} to target. * @param {string} field See {@link Mapper#sum}. * @param {Object} [query] See {@link Mapper#sum}. * @param {Object} [opts] See {@link Mapper#sum}. * @returns {Promise} See {@link Mapper#sum}. * @see Mapper#sum * @since 3.0.0 */ 'sum', /** * Wrapper for {@link Mapper#toJSON}. * * @example * import {Container} from 'js-data' * import RethinkDBAdapter from 'js-data-rethinkdb' * const store = new Container() * store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }) * store.defineMapper('person', { * schema: { * properties: { * name: { type: 'string' }, * id: { type: 'string' } * } * } * }) * const person = store.createRecord('person', { id: 1, name: 'John', foo: 'bar' }) * console.log(store.toJSON('person', person)) // {&quot;id&quot;:1,&quot;name&quot;:&quot;John&quot;,&quot;foo&quot;:&quot;bar&quot;} * console.log(store.toJSON('person', person), { strict: true }) // {&quot;id&quot;:1,&quot;name&quot;:&quot;John&quot;} * * @method Container#toJSON * @param {string} name Name of the {@link Mapper} to target. * @param {Record|Record[]} records See {@link Mapper#toJSON}. * @param {Object} [opts] See {@link Mapper#toJSON}. * @returns {Object|Object[]} See {@link Mapper#toJSON}. * @see Mapper#toJSON * @since 3.0.0 */ 'toJSON', /** * Wrapper for {@link Mapper#update}. * * @example * import {Container} from 'js-data' * import RethinkDBAdapter from 'js-data-rethinkdb' * const store = new Container() * store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }) * store.defineMapper('post') * * store.update('post', 1234, { * status: 'published', * published_at: new Date() * }).then((post) =&gt; { * console.log(post) // { id: 1234, status: 'published', ... } * }) * * @method Container#update * @param {string} name Name of the {@link Mapper} to target. * @param {(string|number)} id See {@link Mapper#update}. * @param {Object} record See {@link Mapper#update}. * @param {Object} [opts] See {@link Mapper#update}. * @returns {Promise} See {@link Mapper#update}. * @see Mapper#update * @since 3.0.0 * @tutorial [&quot;http://www.js-data.io/v3.0/docs/saving-data&quot;,&quot;Saving data&quot;] */ 'update', /** * Wrapper for {@link Mapper#updateAll}. * * @example &lt;caption&gt;Turn all of John's blog posts into drafts.&lt;/caption&gt; * import {Container} from 'js-data' * import RethinkDBAdapter from 'js-data-rethinkdb' * const store = new Container() * store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }) * store.defineMapper('post') * * const update = { status: draft: published_at: null } * const query = { userId: 1234 } * store.updateAll('post', update, query).then((posts) =&gt; { * console.log(posts) // [...] * }) * * @method Container#updateAll * @param {string} name Name of the {@link Mapper} to target. * @param {Object} update See {@link Mapper#updateAll}. * @param {Object} [query] See {@link Mapper#updateAll}. * @param {Object} [opts] See {@link Mapper#updateAll}. * @returns {Promise} See {@link Mapper#updateAll}. * @see Mapper#updateAll * @since 3.0.0 */ 'updateAll', /** * Wrapper for {@link Mapper#updateMany}. * * @example * import {Container} from 'js-data' * import RethinkDBAdapter from 'js-data-rethinkdb' * const store = new Container() * store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }) * store.defineMapper('post') * * store.updateMany('post', [ * { id: 1234, status: 'draft' }, * { id: 2468, status: 'published', published_at: new Date() } * ]).then((posts) =&gt; { * console.log(posts) // [...] * }) * * @method Container#updateMany * @param {string} name Name of the {@link Mapper} to target. * @param {(Object[]|Record[])} records See {@link Mapper#updateMany}. * @param {Object} [opts] See {@link Mapper#updateMany}. * @returns {Promise} See {@link Mapper#updateMany}. * @see Mapper#updateMany * @since 3.0.0 */ 'updateMany', /** * Wrapper for {@link Mapper#validate}. * * @example * import {Container} from 'js-data' * const store = new Container() * store.defineMapper('post', { * schema: { * properties: { * name: { type: 'string' }, * id: { type: 'string' } * } * } * }) * let errors = store.validate('post', { name: 'John' }) * console.log(errors) // undefined * errors = store.validate('post', { name: 123 }) * console.log(errors) // [{ expected: 'one of (string)', actual: 'number', path: 'name' }] * * @method Container#validate * @param {string} name Name of the {@link Mapper} to target. * @param {(Object[]|Record[])} records See {@link Mapper#validate}. * @param {Object} [opts] See {@link Mapper#validate}. * @returns {Promise} See {@link Mapper#validate}. * @see Mapper#validate * @since 3.0.0 */ 'validate' ] const props = { constructor: function Container (opts) { const self = this utils.classCallCheck(self, Container) Container.__super__.call(self) opts || (opts = {}) // Apply options provided by the user utils.fillIn(self, opts) /** * Defaults options to pass to {@link Container#mapperClass} when creating a * new {@link Mapper}. * * @default {} * @name Container#mapperDefaults * @since 3.0.0 * @type {Object} */ self.mapperDefaults = self.mapperDefaults || {} /** * Constructor function to use in {@link Container#defineMapper} to create a * new mapper. * * {@link Mapper} * @name Container#mapperClass * @since 3.0.0 * @type {Constructor} */ self.mapperClass = self.mapperClass || Mapper // Holds the adapters, shared by all mappers in this container self._adapters = {} // The the mappers in this container self._mappers = {} }, /** * Register a new event listener on this Container. * * Proxy for {@link Component#on}. If an event was emitted by a Mapper in the * Container, then the name of the Mapper will be prepended to the arugments * passed to the listener. * * @method Container#on * @param {string} event Name of event to subsribe to. * @param {Function} listener Listener function to handle the event. * @param {*} [ctx] Optional content in which to invoke the listener. * @since 3.0.0 */ /** * Used to bind to events emitted by mappers in this container. * * @method Container#_onMapperEvent * @param {string} name Name of the mapper that emitted the event. * @param {...*} [args] Args See {@link Mapper#emit}. * @private * @since 3.0.0 */ _onMapperEvent (name, ...args) { const type = args.shift() this.emit(type, name, ...args) }, /** * Create a new mapper and register it in this container. * * @example * import {Container} from 'js-data' * const store = new Container({ * mapperDefaults: { foo: 'bar' } * }) * const userMapper = store.defineMapper('user') * userMapper.foo // &quot;bar&quot; * * @method Container#defineMapper * @param {string} name Name under which to register the new {@link Mapper}. * {@link Mapper#name} will be set to this value. * @param {Object} [opts] Configuration options. Passed to * {@link Container#mapperClass} when creating the new {@link Mapper}. * @returns {Mapper} * @since 3.0.0 */ defineMapper (name, opts) { const self = this // For backwards compatibility with defineResource if (utils.isObject(name)) { opts = name name = opts.name } if (!utils.isString(name)) { throw utils.err(`${DOMAIN}#defineMapper`, 'name')(400, 'string', name) } // Default values for arguments opts || (opts = {}) // Set Mapper#name opts.name = name opts.relations || (opts.relations = {}) // Check if the user is overriding the datastore's default mapperClass const mapperClass = opts.mapperClass || self.mapperClass delete opts.mapperClass // Apply the datastore's defaults to the options going into the mapper utils.fillIn(opts, self.mapperDefaults) // Instantiate a mapper const mapper = self._mappers[name] = new mapperClass(opts) // eslint-disable-line mapper.relations || (mapper.relations = {}) // Make sure the mapper's name is set mapper.name = name // All mappers in this datastore will share adapters mapper._adapters = self.getAdapters() mapper.datastore = self mapper.on('all', function (...args) { self._onMapperEvent(name, ...args) }) // Setup the mapper's relations, including generating Mapper#relationList // and Mapper#relationFields utils.forOwn(mapper.relations, function (group, type) { utils.forOwn(group, function (relations, _name) { if (utils.isObject(relations)) { relations = [relations] } relations.forEach(function (def) { def.getRelation = function () { return self.getMapper(_name) } const relatedMapper = self._mappers[_name] || _name if (type === belongsToType) { mapper.belongsTo(relatedMapper, def) } else if (type === hasOneType) { mapper.hasOne(relatedMapper, def) } else if (type === hasManyType) { mapper.hasMany(relatedMapper, def) } }) }) }) return mapper }, defineResource (name, opts) { return this.defineMapper(name, opts) }, /** * Return the registered adapter with the given name or the default adapter if * no name is provided. * * @method Container#getAdapter * @param {string} [name] The name of the adapter to retrieve. * @returns {Adapter} The adapter. * @since 3.0.0 */ getAdapter (name) { const self = this const adapter = self.getAdapterName(name) if (!adapter) { throw utils.err(`${DOMAIN}#getAdapter`, 'name')(400, 'string', name) } return self.getAdapters()[adapter] }, /** * Return the name of a registered adapter based on the given name or options, * or the name of the default adapter if no name provided. * * @method Container#getAdapterName * @param {(Object|string)} [opts] The name of an adapter or options, if any. * @returns {string} The name of the adapter. * @since 3.0.0 */ getAdapterName (opts) { opts || (opts = {}) if (utils.isString(opts)) { opts = { adapter: opts } } return opts.adapter || this.mapperDefaults.defaultAdapter }, /** * Return the registered adapters of this container. * * @method Container#getAdapters * @returns {Adapter} * @since 3.0.0 */ getAdapters () { return this._adapters }, /** * Return the mapper registered under the specified name. * * @example * import {Container} from 'js-data' * const container = new Container() * const userMapper = container.defineMapper('user') * userMapper === container.getMapper('user') // true * * @method Container#getMapper * @param {string} name {@link Mapper#name}. * @returns {Mapper} * @since 3.0.0 */ getMapper (name) { const mapper = this._mappers[name] if (!mapper) { throw utils.err(`${DOMAIN}#getMapper`, name)(404, 'mapper') } return mapper }, /** * Register an adapter on this container under the given name. Adapters * registered on a container are shared by all mappers in the container. * * @example * import {Container} from 'js-data' * import HttpAdapter from 'js-data-http' * const container = new Container() * container.registerAdapter('http', new HttpAdapter, { default: true }) * * @method Container#registerAdapter * @param {string} name The name of the adapter to register. * @param {Adapter} adapter The adapter to register. * @param {Object} [opts] Configuration options. * @param {boolean} [opts.default=false] Whether to make the adapter the * default adapter for all Mappers in this container. * @since 3.0.0 * @tutorial [&quot;http://www.js-data.io/v3.0/docs/connecting-to-a-data-source&quot;,&quot;Connecting to a data source&quot;] */ registerAdapter (name, adapter, opts) { const self = this opts || (opts = {}) self.getAdapters()[name] = adapter // Optionally make it the default adapter for the target. if (opts === true || opts.default) { self.mapperDefaults.defaultAdapter = name utils.forOwn(self._mappers, function (mapper) { mapper.defaultAdapter = name }) } } } toProxy.forEach(function (method) { props[method] = function (name, ...args) { return this.getMapper(name)[method](...args) } }) /** * ```javascript * import {Container} from 'js-data' * ``` * * The `Container` class is a place to store {@link Mapper} instances. * * Without a container, you need to manage mappers yourself, including resolving * circular dependencies among relations. All mappers in a container share the * same adapters, so you don't have to add each adapter to all of your mappers. * * @example &lt;caption&gt;Without Container&lt;/caption&gt; * import {Mapper} from 'js-data' * import HttpAdapter from 'js-data-http' * const adapter = new HttpAdapter() * const userMapper = new Mapper({ name: 'user' }) * userMapper.registerAdapter('http', adapter, { default: true }) * const commentMapper = new Mapper({ name: 'comment' }) * commentMapper.registerAdapter('http', adapter, { default: true }) * * // This might be more difficult if the mappers were defined in different * // modules. * userMapper.hasMany(commentMapper, { * localField: 'comments', * foreignKey: 'userId' * }) * commentMapper.belongsTo(userMapper, { * localField: 'user', * foreignKey: 'userId' * }) * * @example &lt;caption&gt;With Container&lt;/caption&gt; * import {Container} from 'js-data' * import HttpAdapter from 'js-data-http' * const container = new Container() * // All mappers in container share adapters * container.registerAdapter('http', new HttpAdapter(), { default: true }) * * // These could be defined in separate modules without a problem. * container.defineMapper('user', { * relations: { * hasMany: { * comment: { * localField: 'comments', * foreignKey: 'userId' * } * } * } * }) * container.defineMapper('comment', { * relations: { * belongsTo: { * user: { * localField: 'user', * foreignKey: 'userId' * } * } * } * }) * * @class Container * @extends Component * @param {Object} [opts] Configuration options. * @param {Function} [opts.mapperClass] Constructor function to use in * {@link Container#defineMapper} to create a new mapper. * @param {Object} [opts.mapperDefaults] Defaults options to pass to * {@link Container#mapperClass} when creating a new mapper. * @returns {Container} * @since 3.0.0 * @tutorial [&quot;http://www.js-data.io/v3.0/docs/components-of-jsdata#container&quot;,&quot;Components of JSData: Container&quot;] * @tutorial [&quot;http://www.js-data.io/v3.0/docs/jsdata-and-the-browser&quot;,&quot;Notes on using JSData in the Browser&quot;] * @tutorial [&quot;http://www.js-data.io/v3.0/docs/jsdata-and-nodejs&quot;,&quot;Notes on using JSData in Node.js&quot;] */ export default Component.extend(props) /** * Create a subclass of this Container. * * @example &lt;caption&gt;Extend the class in a cross-browser manner.&lt;/caption&gt; * import {Container} from 'js-data' * const CustomContainerClass = Container.extend({ * foo () { return 'bar' } * }) * const customContainer = new CustomContainerClass() * console.log(customContainer.foo()) // &quot;bar&quot; * * @example &lt;caption&gt;Extend the class using ES2015 class syntax.&lt;/caption&gt; * class CustomContainerClass extends Container { * foo () { return 'bar' } * } * const customContainer = new CustomContainerClass() * console.log(customContainer.foo()) // &quot;bar&quot; * * @method Container.extend * @param {Object} [props={}] Properties to add to the prototype of the * subclass. * @param {Object} [classProps={}] Static properties to add to the subclass. * @returns {Constructor} Subclass of this Container. * @since 3.0.0 */ × Search results Close api.js-data.io • js-data.io "},"DataStore.js.html":{"id":"DataStore.js.html","title":"Source: DataStore.js","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentContainerDataStoreLinkedCollectionMapperQueryRecordSchema Source: DataStore.js import utils from './utils' import { belongsToType, hasManyType, hasOneType } from './decorators' import Container from './Container' import LinkedCollection from './LinkedCollection' const DOMAIN = 'DataStore' const safeSet = function (record, field, value) { if (record &amp;&amp; record._set) { record._set(field, value) } else { utils.set(record, field, value) } } const cachedFn = function (name, hashOrId, opts) { const self = this const cached = self._completedQueries[name][hashOrId] if (utils.isFunction(cached)) { return cached(name, hashOrId, opts) } return cached } const props = { constructor: function DataStore (opts) { const self = this utils.classCallCheck(self, DataStore) DataStore.__super__.call(self, opts) self.collectionClass = self.collectionClass || LinkedCollection self._collections = {} self._pendingQueries = {} self._completedQueries = {} return self }, _callSuper (method, ...args) { return this.constructor.__super__.prototype[method].apply(this, args) }, /** * TODO * * @name DataStore#_end * @method * @private * @param {string} name Name of the {@link LinkedCollection} to which to * add the data. * @param {Object} data TODO. * @param {Object} [opts] Configuration options. * @returns {(Object|Array)} Result. */ _end (name, result, opts) { let _data = opts.raw ? result.data : result if (_data &amp;&amp; utils.isFunction(this.addToCache)) { _data = this.addToCache(name, _data, opts) if (opts.raw) { result.data = _data } else { result = _data } } return result }, /** * Register a new event listener on this DataStore. * * Proxy for {@link Container#on}. If an event was emitted by a Mapper or * Collection in the DataStore, then the name of the Mapper or Collection will * be prepended to the arugments passed to the provided event handler. * * @name DataStore#on * @method * @param {string} event Name of event to subsribe to. * @param {Function} listener Listener function to handle the event. * @param {*} [ctx] Optional content in which to invoke the listener. */ /** * Used to bind to events emitted by collections in this store. * * @name DataStore#_onCollectionEvent * @method * @private * @param {string} name Name of the collection that emitted the event. * @param {...*} [args] Args passed to {@link Collection#emit}. */ _onCollectionEvent (name, ...args) { const type = args.shift() this.emit(type, name, ...args) }, /** * TODO * * @name DataStore#addToCache * @method * @param {string} name - Name of the {@link Mapper} to target. * @param {*} data - Data from which data should be selected for add. * @param {Object} [opts] - Configuration options. */ addToCache (name, data, opts) { return this.getCollection(name).add(data, opts) }, /** * Retrieve a cached `find` result, if any. * * @name DataStore#cachedFind * @method * @param {string} name The `name` argument passed to {@link DataStore#find}. * @param {(string|number)} id The `id` argument passed to {@link DataStore#find}. * @param {Object} opts The `opts` argument passed to {@link DataStore#find}. */ cachedFind: cachedFn, /** * Retrieve a cached `findAll` result, if any. * * @name DataStore#cachedFindAll * @method * @param {string} name The `name` argument passed to {@link DataStore#findAll}. * @param {string} hash The result of calling {@link DataStore#hashQuery} on * the `query` argument passed to {@link DataStore#findAll}. * @param {Object} opts The `opts` argument passed to {@link DataStore#findAll}. */ cachedFindAll: cachedFn, /** * Cache a `find` result. The default implementation does the following: * * ``` * // Find and return the record from the data store * return this.get(name, id) * ``` * * Override this method to customize. * * @name DataStore#cacheFind * @method * @param {string} name The `name` argument passed to {@link DataStore#find}. * @param {*} data The result to cache. * @param {(string|number)} id The `id` argument passed to {@link DataStore#find}. * @param {Object} opts The `opts` argument passed to {@link DataStore#find}. */ cacheFind (name, data, id, opts) { const self = this self._completedQueries[name][id] = function (name, id, opts) { return self.get(name, id) } }, /** * Cache a `findAll` result. The default implementation does the following: * * ``` * // Find and return the records from the data store * return this.filter(name, utils.fromJson(hash)) * ``` * * Override this method to customize. * * @name DataStore#cacheFindAll * @method * @param {string} name The `name` argument passed to {@link DataStore#findAll}. * @param {*} data The result to cache. * @param {string} hash The result of calling {@link DataStore#hashQuery} on * the `query` argument passed to {@link DataStore#findAll}. * @param {Object} opts The `opts` argument passed to {@link DataStore#findAll}. */ cacheFindAll (name, data, hash, opts) { const self = this self._completedQueries[name][hash] = function (name, hash, opts) { return self.filter(name, utils.fromJson(hash)) } }, /** * TODO * * @name DataStore#create * @method * @param {string} name Name of the {@link Mapper} to target. * @param {Object} record Passed to {@link Mapper#create}. * @param {Object} [opts] Passed to {@link Mapper#create}. See * {@link Mapper#create} for more configuration options. * @returns {Promise} */ create (name, record, opts) { const self = this opts || (opts = {}) return self._callSuper('create', name, record, opts).then(function (data) { return self._end(name, data, opts) }) }, /** * TODO * * @name DataStore#createMany * @method * @param {string} name Name of the {@link Mapper} to target. * @param {Array} records Passed to {@link Mapper#createMany}. * @param {Object} [opts] Passed to {@link Mapper#createMany}. See * {@link Mapper#createMany} for more configuration options. * @returns {Promise} */ createMany (name, records, opts) { const self = this opts || (opts = {}) return self._callSuper('createMany', name, records, opts).then(function (data) { return self._end(name, data, opts) }) }, defineMapper (name, opts) { const self = this const mapper = utils.getSuper(self).prototype.defineMapper.call(self, name, opts) self._pendingQueries[name] = {} self._completedQueries[name] = {} mapper.relationList || Object.defineProperty(mapper, 'relationList', { value: [] }) // The datastore uses a subclass of Collection that is &quot;datastore-aware&quot; const collection = self._collections[name] = new self.collectionClass(null, { // eslint-disable-line // Make sure the collection has somewhere to store &quot;added&quot; timestamps _added: {}, // Give the collection a reference to this datastore datastore: self, // The mapper tied to the collection mapper }) const schema = mapper.schema || {} const properties = schema.properties || {} // TODO: Make it possible index nested properties? utils.forOwn(properties, function (opts, prop) { if (opts.indexed) { collection.createIndex(prop) } }) // Create a secondary index on the &quot;added&quot; timestamps of records in the // collection collection.createIndex('addedTimestamps', ['$'], { fieldGetter (obj) { return collection._added[collection.recordId(obj)] } }) collection.on('all', function (...args) { self._onCollectionEvent(name, ...args) }) const idAttribute = mapper.idAttribute mapper.relationList.forEach(function (def) { const relation = def.relation const localField = def.localField const path = `links.${localField}` const foreignKey = def.foreignKey const type = def.type const updateOpts = { index: foreignKey } let descriptor const getter = function () { return this._get(path) } if (type === belongsToType) { if (!collection.indexes[foreignKey]) { collection.createIndex(foreignKey) } descriptor = { get: getter, set (record) { const _self = this const current = this._get(path) if (record === current) { return current } const id = utils.get(_self, idAttribute) const inverseDef = def.getInverse(mapper) if (record) { const relatedIdAttribute = def.getRelation().idAttribute const relatedId = utils.get(record, relatedIdAttribute) // Prefer store record if (!utils.isUndefined(relatedId)) { record = self.get(relation, relatedId) || record } // Set locals _self._set(path, record) safeSet(_self, foreignKey, relatedId) collection.updateIndex(_self, updateOpts) // Update (set) inverse relation if (inverseDef.type === hasOneType) { utils.set(record, inverseDef.localField, _self) } else if (inverseDef.type === hasManyType) { const children = utils.get(record, inverseDef.localField) utils.noDupeAdd(children, _self, function (_record) { return id === utils.get(_record, idAttribute) }) } } else { // Unset locals _self._set(path, undefined) safeSet(_self, foreignKey, undefined) collection.updateIndex(_self, updateOpts) } if (current) { if (inverseDef.type === hasOneType) { utils.set(current, inverseDef.localField, undefined) } else if (inverseDef.type === hasManyType) { const children = utils.get(current, inverseDef.localField) utils.remove(children, function (_record) { return id === utils.get(_record, idAttribute) }) } } return record } } if (mapper.recordClass.prototype.hasOwnProperty(foreignKey)) { const superClass = mapper.recordClass mapper.recordClass = superClass.extend({ constructor: (function () { var subClass = function Record (props, opts) { utils.classCallCheck(this, subClass) superClass.call(this, props, opts) } return subClass })() }) } Object.defineProperty(mapper.recordClass.prototype, foreignKey, { enumerable: true, get () { return this._get(foreignKey) }, set (value) { const _self = this if (utils.isUndefined(value)) { // Unset locals utils.set(_self, localField, undefined) } else { safeSet(_self, foreignKey, value) let storeRecord = self.get(relation, value) if (storeRecord) { utils.set(_self, localField, storeRecord) } } } }) } else if (type === hasManyType) { const localKeys = def.localKeys const foreignKeys = def.foreignKeys // TODO: Handle case when belongsTo relation isn't ever defined if (self._collections[relation] &amp;&amp; foreignKey &amp;&amp; !self.getCollection(relation).indexes[foreignKey]) { self.getCollection(relation).createIndex(foreignKey) } descriptor = { get () { const _self = this let current = getter.call(_self) if (!current) { _self._set(path, []) } return getter.call(_self) }, set (records) { const _self = this records || (records = []) if (records &amp;&amp; !utils.isArray(records)) { records = [records] } const id = utils.get(_self, idAttribute) const relatedIdAttribute = def.getRelation().idAttribute const inverseDef = def.getInverse(mapper) const inverseLocalField = inverseDef.localField let linked = _self._get(path) if (!linked) { linked = [] } const current = linked linked = [] const toLink = {} records.forEach(function (record) { const relatedId = utils.get(record, relatedIdAttribute) if (!utils.isUndefined(relatedId)) { // Prefer store record record = self.get(relation, relatedId) || record toLink[relatedId] = record } linked.push(record) }) if (foreignKey) { records.forEach(function (record) { // Update (set) inverse relation safeSet(record, foreignKey, id) self.getCollection(relation).updateIndex(record, updateOpts) utils.set(record, inverseLocalField, _self) }) current.forEach(function (record) { const relatedId = utils.get(record, relatedIdAttribute) if (!utils.isUndefined(relatedId) &amp;&amp; !toLink.hasOwnProperty(relatedId)) { // Update (unset) inverse relation safeSet(record, foreignKey, undefined) self.getCollection(relation).updateIndex(record, updateOpts) utils.set(record, inverseLocalField, undefined) } }) } else if (localKeys) { const _localKeys = [] records.forEach(function (record) { // Update (set) inverse relation utils.set(record, inverseLocalField, _self) _localKeys.push(utils.get(record, relatedIdAttribute)) }) // Update locals utils.set(_self, localKeys, _localKeys) // Update (unset) inverse relation current.forEach(function (record) { const relatedId = utils.get(record, relatedIdAttribute) if (!utils.isUndefined(relatedId) &amp;&amp; !toLink.hasOwnProperty(relatedId)) { // Update inverse relation utils.set(record, inverseLocalField, undefined) } }) } else if (foreignKeys) { // Update (unset) inverse relation current.forEach(function (record) { const _localKeys = utils.get(record, foreignKeys) || [] utils.remove(_localKeys, function (_key) { return id === _key }) const _localField = utils.get(record, inverseLocalField) || [] utils.remove(_localField, function (_record) { return id === utils.get(_record, idAttribute) }) }) // Update (set) inverse relation records.forEach(function (record) { const _localKeys = utils.get(record, foreignKeys) || [] utils.noDupeAdd(_localKeys, id, function (_key) { return id === _key }) const _localField = utils.get(record, inverseLocalField) || [] utils.noDupeAdd(_localField, _self, function (_record) { return id === utils.get(_record, idAttribute) }) }) } _self._set(path, linked) return linked } } } else if (type === hasOneType) { // TODO: Handle case when belongsTo relation isn't ever defined if (self._collections[relation] &amp;&amp; foreignKey &amp;&amp; !self.getCollection(relation).indexes[foreignKey]) { self.getCollection(relation).createIndex(foreignKey) } descriptor = { get: getter, set (record) { const _self = this const current = this._get(path) if (record === current) { return current } const relatedId = utils.get(record, def.getRelation().idAttribute) const inverseLocalField = def.getInverse(mapper).localField // Update (unset) inverse relation if (current) { safeSet(current, foreignKey, undefined) self.getCollection(relation).updateIndex(current, updateOpts) utils.set(current, inverseLocalField, undefined) } if (record) { // Prefer store record if (!utils.isUndefined(relatedId)) { record = self.get(relation, relatedId) || record } // Set locals _self._set(path, record) // Update (set) inverse relation safeSet(record, foreignKey, utils.get(_self, idAttribute)) self.getCollection(relation).updateIndex(record, updateOpts) utils.set(record, inverseLocalField, _self) } else { // Set locals _self._set(path, undefined) } return record } } } if (descriptor) { descriptor.enumerable = utils.isUndefined(def.enumerable) ? true : def.enumerable if (def.get) { let origGet = descriptor.get descriptor.get = function () { return def.get(def, this, (...args) =&gt; origGet.apply(this, args)) } } if (def.set) { let origSet = descriptor.set descriptor.set = function (related) { return def.set(def, this, related, (value) =&gt; origSet.call(this, value === undefined ? related : value)) } } Object.defineProperty(mapper.recordClass.prototype, localField, descriptor) } }) return mapper }, /** * TODO * * @name DataStore#destroy * @method * @param {string} name - Name of the {@link Mapper} to target. * @param {(string|number)} id - Passed to {@link Mapper#destroy}. * @param {Object} [opts] - Passed to {@link Mapper#destroy}. See * {@link Mapper#destroy} for more configuration options. * @returns {Promise} */ destroy (name, id, opts) { const self = this opts || (opts = {}) return self._callSuper('destroy', name, id, opts).then(function (data) { if (opts.raw) { data.data = self.getCollection(name).remove(id, opts) } else { data = self.getCollection(name).remove(id, opts) } delete self._pendingQueries[name][id] delete self._completedQueries[name][id] return data }) }, /** * TODO * * @name DataStore#destroyAll * @method * @param {string} name - Name of the {@link Mapper} to target. * @param {Object} [query] - Passed to {@link Mapper#destroyAll}. * @param {Object} [opts] - Passed to {@link Mapper#destroyAll}. See * {@link Mapper#destroyAll} for more configuration options. * @returns {Promise} */ destroyAll (name, query, opts) { const self = this opts || (opts = {}) return self._callSuper('destroyAll', name, query, opts).then(function (data) { if (opts.raw) { data.data = self.getCollection(name).removeAll(query, opts) } else { data = self.getCollection(name).removeAll(query, opts) } const hash = self.hashQuery(name, query, opts) delete self._pendingQueries[name][hash] delete self._completedQueries[name][hash] return data }) }, eject (id, opts) { return this.remove(id, opts) }, ejectAll (query, opts) { return this.removeAll(query, opts) }, /** * TODO * * @name DataStore#find * @method * @param {string} name - Name of the {@link Mapper} to target. * @param {(string|number)} id - Passed to {@link Mapper#find}. * @param {Object} [opts] - Passed to {@link Mapper#find}. * @returns {Promise} */ find (name, id, opts) { const self = this opts || (opts = {}) const pendingQuery = self._pendingQueries[name][id] utils.fillIn(opts, self.getMapper(name)) if (pendingQuery) { return pendingQuery } const item = self.cachedFind(name, id, opts) let promise if (opts.force || !item) { promise = self._pendingQueries[name][id] = self._callSuper('find', name, id, opts).then(function (data) { delete self._pendingQueries[name][id] const result = self._end(name, data, opts) self.cacheFind(name, result, id, opts) return result }, function (err) { delete self._pendingQueries[name][id] return utils.reject(err) }) } else { promise = utils.resolve(item) } return promise }, /** * TODO * * @name DataStore#findAll * @method * @param {string} name - Name of the {@link Mapper} to target. * @param {Object} [query] - Passed to {@link Model.findAll}. * @param {Object} [opts] - Passed to {@link Model.findAll}. * @returns {Promise} */ findAll (name, query, opts) { const self = this opts || (opts = {}) const hash = self.hashQuery(name, query, opts) const pendingQuery = self._pendingQueries[name][hash] utils.fillIn(opts, self.getMapper(name)) if (pendingQuery) { return pendingQuery } const items = self.cachedFindAll(name, hash, opts) let promise if (opts.force || !items) { promise = self._pendingQueries[name][hash] = self._callSuper('findAll', name, query, opts).then(function (data) { delete self._pendingQueries[name][hash] const result = self._end(name, data, opts) self.cacheFindAll(name, result, hash, opts) return result }, function (err) { delete self._pendingQueries[name][hash] return utils.reject(err) }) } else { promise = utils.resolve(items) } return promise }, /** * TODO * * @name DataStore#getCollection * @method * @param {string} name Name of the {@link LinkedCollection} to retrieve. * @returns {LinkedCollection} */ getCollection (name) { const collection = this._collections[name] if (!collection) { throw utils.err(`${DOMAIN}#getCollection`, name)(404, 'collection') } return collection }, hashQuery (name, query, opts) { return utils.toJson(query) }, inject (records, opts) { return this.add(records, opts) }, remove (name, id, opts) { const self = this const record = self.getCollection(name).remove(id, opts) if (record) { self.removeRelated(name, [record], opts) } return record }, removeAll (name, query, opts) { const self = this const records = self.getCollection(name).removeAll(query, opts) if (records.length) { self.removeRelated(name, records, opts) } return records }, removeRelated (name, records, opts) { const self = this utils.forEachRelation(self.getMapper(name), opts, function (def, optsCopy) { records.forEach(function (record) { let relatedData let query if (def.foreignKey &amp;&amp; (def.type === hasOneType || def.type === hasManyType)) { query = { [def.foreignKey]: def.getForeignKey(record) } } else if (def.type === hasManyType &amp;&amp; def.localKeys) { query = { where: { [def.getRelation().idAttribute]: { 'in': utils.get(record, def.localKeys) } } } } else if (def.type === hasManyType &amp;&amp; def.foreignKeys) { query = { where: { [def.foreignKeys]: { 'contains': def.getForeignKey(record) } } } } else if (def.type === belongsToType) { relatedData = self.remove(def.relation, def.getForeignKey(record), optsCopy) } if (query) { relatedData = self.removeAll(def.relation, query, optsCopy) } if (relatedData) { if (utils.isArray(relatedData) &amp;&amp; !relatedData.length) { return } if (def.type === hasOneType) { relatedData = relatedData[0] } def.setLocalField(record, relatedData) } }) }) }, /** * TODO * * @name DataStore#update * @method * @param {string} name - Name of the {@link Mapper} to target. * @param {(string|number)} id - Passed to {@link Mapper#update}. * @param {Object} record - Passed to {@link Mapper#update}. * @param {Object} [opts] - Passed to {@link Mapper#update}. See * {@link Mapper#update} for more configuration options. * @returns {Promise} */ update (name, id, record, opts) { const self = this opts || (opts = {}) return self._callSuper('update', name, id, record, opts).then(function (data) { return self._end(name, data, opts) }) }, /** * TODO * * @name DataStore#updateAll * @method * @param {string} name - Name of the {@link Mapper} to target. * @param {Object} props - Passed to {@link Mapper#updateAll}. * @param {Object} [query] - Passed to {@link Mapper#updateAll}. * @param {Object} [opts] - Passed to {@link Mapper#updateAll}. See * {@link Mapper#updateAll} for more configuration options. * @returns {Promise} */ updateAll (name, props, query, opts) { const self = this opts || (opts = {}) return self._callSuper('updateAll', name, query, props, opts).then(function (data) { return self._end(name, data, opts) }) }, /** * TODO * * @name DataStore#updateMany * @method * @param {string} name Name of the {@link Mapper} to target. * @param {(Object[]|Record[])} records Passed to {@link Mapper#updateMany}. * @param {Object} [opts] Passed to {@link Mapper#updateMany}. See * {@link Mapper#updateMany} for more configuration options. * @returns {Promise} */ updateMany (name, records, opts) { const self = this opts || (opts = {}) return self._callSuper('updateMany', name, records, opts).then(function (data) { return self._end(name, data, opts) }) } } const toProxy = [ 'add', 'between', 'createIndex', 'filter', 'get', 'getAll', 'query', 'toJson' ] toProxy.forEach(function (method) { props[method] = function (name, ...args) { return this.getCollection(name)[method](...args) } }) /** * The `DataStore` class is an extension of {@link Container}. Not only does * `DataStore` manage mappers, but also collections. `DataStore` implements the * asynchronous {@link Mapper} methods, such as {@link Mapper#find} and * {@link Mapper#create}. If you use the asynchronous `DataStore` methods * instead of calling them directly on the mappers, then the results of the * method calls will be inserted into the store's collections. You can think of * a `DataStore` as an [Identity Map](https://en.wikipedia.org/wiki/Identity_map_pattern) * for the [ORM](https://en.wikipedia.org/wiki/Object-relational_mapping) * (the Mappers). * * ```javascript * import {DataStore} from 'js-data' * ``` * * @example * import {DataStore} from 'js-data' * import HttpAdapter from 'js-data-http' * const store = new DataStore() * const UserMapper = store.defineMapper('user') * * // Call &quot;find&quot; on &quot;UserMapper&quot; (Stateless ORM) * UserMapper.find(1).then((user) =&gt; { * // retrieved a &quot;user&quot; record via the http adapter, but that's it * * // Call &quot;find&quot; on &quot;store&quot; targeting &quot;user&quot; (Stateful DataStore) * return store.find('user', 1) * }).then((user) =&gt; { * // not only was a &quot;user&quot; record retrieved, but it was added to the * // store's &quot;user&quot; collection * const cachedUser = store.getCollection('user').get(1) * console.log(user === cachedUser) // true * }) * * @class DataStore * @extends Container * @param {Object} [opts] Configuration options. See {@link Container}. * @returns {DataStore} * @see Container * @since 3.0.0 * @tutorial [&quot;http://www.js-data.io/v3.0/docs/components-of-jsdata#datastore&quot;,&quot;Components of JSData: DataStore&quot;] * @tutorial [&quot;http://www.js-data.io/v3.0/docs/working-with-the-datastore&quot;,&quot;Working with the DataStore&quot;] * @tutorial [&quot;http://www.js-data.io/v3.0/docs/jsdata-and-the-browser&quot;,&quot;Notes on using JSData in the Browser&quot;] */ export default Container.extend(props) /** * Create a subclass of this DataStore. * * @example &lt;caption&gt;Extend the class in a cross-browser manner.&lt;/caption&gt; * import {DataStore} from 'js-data' * const CustomDataStoreClass = DataStore.extend({ * foo () { return 'bar' } * }) * const customDataStore = new CustomDataStoreClass() * console.log(customDataStore.foo()) // &quot;bar&quot; * * @example &lt;caption&gt;Extend the class using ES2015 class syntax.&lt;/caption&gt; * class CustomDataStoreClass extends DataStore { * foo () { return 'bar' } * } * const customDataStore = new CustomDataStoreClass() * console.log(customDataStore.foo()) // &quot;bar&quot; * * @method DataStore.extend * @param {Object} [props={}] Properties to add to the prototype of the * subclass. * @param {Object} [classProps={}] Static properties to add to the subclass. * @returns {Constructor} Subclass of this DataStore. * @since 3.0.0 */ × Search results Close api.js-data.io • js-data.io "},"LinkedCollection.js.html":{"id":"LinkedCollection.js.html","title":"Source: LinkedCollection.js","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentContainerDataStoreLinkedCollectionMapperQueryRecordSchema Source: LinkedCollection.js import utils from './utils' import { belongsToType, hasManyType, hasOneType } from './decorators' import Collection from './Collection' const DOMAIN = 'LinkedCollection' /** * TODO * * ```javascript * import {LinkedCollection} from 'js-data' * ``` * * @class LinkedCollection * @extends Collection * @param {Array} [records] Initial set of records to insert into the * collection. See {@link Collection}. * @param {Object} [opts] Configuration options. See {@link Collection}. * @returns {Mapper} */ export default Collection.extend({ constructor: function LinkedCollection (records, opts) { const self = this utils.classCallCheck(self, LinkedCollection) LinkedCollection.__super__.call(self, records, opts) // Make sure this collection has somewhere to store &quot;added&quot; timestamps Object.defineProperty(self, '_added', { value: {} }) // Make sure this collection has a reference to a datastore if (!self.datastore) { throw utils.err(`new ${DOMAIN}`, 'opts.datastore')(400, 'DataStore', self.datastore) } return self }, _onRecordEvent (...args) { const self = this utils.getSuper(self).prototype._onRecordEvent.apply(self, args) const event = args[0] // This is a very brute force method // Lots of room for optimization if (utils.isString(event) &amp;&amp; event.indexOf('change') === 0) { self.updateIndexes(args[1]) } }, add (records, opts) { const self = this const datastore = self.datastore const mapper = self.mapper const relationList = mapper.relationList const timestamp = new Date().getTime() const usesRecordClass = !!mapper.recordClass const idAttribute = mapper.idAttribute let singular if (utils.isObject(records) &amp;&amp; !utils.isArray(records)) { singular = true records = [records] } records = utils.getSuper(self).prototype.add.call(self, records, opts) if (relationList.length &amp;&amp; records.length) { // Check the currently visited record for relations that need to be // inserted into their respective collections. mapper.relationList.forEach(function (def) { const relationName = def.relation // A reference to the Mapper that this Mapper is related to const relatedMapper = datastore.getMapper(relationName) // The field used by the related Mapper as the primary key const relationIdAttribute = relatedMapper.idAttribute // Grab the foreign key in this relationship, if there is one const foreignKey = def.foreignKey // A lot of this is an optimization for being able to insert a lot of // data as quickly as possible const relatedCollection = datastore.getCollection(relationName) const type = def.type const isHasMany = type === hasManyType const shouldAdd = utils.isUndefined(def.add) ? true : !!def.add let relatedData records.forEach(function (record) { // Grab a reference to the related data attached or linked to the // currently visited record relatedData = def.getLocalField(record) const id = utils.get(record, idAttribute) if (utils.isFunction(def.add)) { relatedData = def.add(datastore, def, record) } else if (relatedData) { // Otherwise, if there is something to be added, add it if (isHasMany) { // Handle inserting hasMany relations relatedData = relatedData.map(function (toInsertItem) { // Check that this item isn't the same item that is already in the // store if (toInsertItem !== relatedCollection.get(relatedCollection.recordId(toInsertItem))) { // Make sure this item has its foreignKey if (foreignKey) { // TODO: slow, could be optimized? But user loses hook def.setForeignKey(record, toInsertItem) } // Finally add this related item if (shouldAdd) { toInsertItem = relatedCollection.add(toInsertItem) } } return toInsertItem }) } else { const relatedDataId = utils.get(relatedData, relationIdAttribute) // Handle inserting belongsTo and hasOne relations if (relatedData !== relatedCollection.get(relatedDataId)) { // Make sure foreignKey field is set def.setForeignKey(record, relatedData) // Finally insert this related item if (shouldAdd) { relatedData = relatedCollection.add(relatedData) } } } } if (!relatedData || (utils.isArray(relatedData) &amp;&amp; !relatedData.length)) { if (type === belongsToType) { const relatedId = utils.get(record, foreignKey) if (!utils.isUndefined(relatedId)) { relatedData = relatedCollection.get(relatedId) } } else if (type === hasOneType) { const _records = relatedCollection.filter({ [foreignKey]: id }) relatedData = _records.length ? _records[0] : undefined } else if (type === hasManyType) { if (foreignKey) { const _records = relatedCollection.filter({ [foreignKey]: id }) relatedData = _records.length ? _records : undefined } else if (def.localKeys &amp;&amp; utils.get(record, def.localKeys)) { const _records = relatedCollection.filter({ where: { [relationIdAttribute]: { 'in': utils.get(record, def.localKeys) } } }) relatedData = _records.length ? _records : undefined } else if (def.foreignKeys) { const _records = relatedCollection.filter({ where: { [def.foreignKeys]: { 'contains': id } } }) relatedData = _records.length ? _records : undefined } } } if (relatedData) { def.setLocalField(record, relatedData) } else { } }) }) } records.forEach(function (record) { // Track when this record was added self._added[self.recordId(record)] = timestamp if (usesRecordClass) { record._set('$', timestamp) } }) return singular ? records[0] : records }, remove (id, opts) { const self = this const mapper = self.mapper const record = utils.getSuper(self).prototype.remove.call(self, id, opts) if (record) { delete self._added[id] if (mapper.recordClass) { record._set('$') // unset } } return record }, removeAll (query, opts) { const self = this const mapper = self.mapper const records = utils.getSuper(self).prototype.removeAll.call(self, query, opts) records.forEach(function (record) { delete self._added[self.recordId(record)] if (mapper.recordClass) { record._set('$') // unset } }) return records } }) × Search results Close api.js-data.io • js-data.io "},"Mapper.js.html":{"id":"Mapper.js.html","title":"Source: Mapper.js","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentContainerDataStoreLinkedCollectionMapperQueryRecordSchema Source: Mapper.js import utils from './utils' import Component from './Component' import Record from './Record' import Schema from './Schema' import { belongsTo, belongsToType, hasMany, hasManyType, hasOne, hasOneType } from './decorators' const DOMAIN = 'Mapper' const makeNotify = function (num) { return function (...args) { const self = this const opts = args[args.length - num] self.dbg(opts.op, ...args) if (opts.notify || (opts.notify === undefined &amp;&amp; self.notify)) { setTimeout(() =&gt; { self.emit(opts.op, ...args) }) } } } // These are the default implementations of all of the lifecycle hooks const notify = makeNotify(1) const notify2 = makeNotify(2) // This object provides meta information used by Mapper#crud to actually // execute each lifecycle method const LIFECYCLE_METHODS = { count: { defaults: [{}, {}], skip: true, types: [] }, destroy: { defaults: [{}, {}], skip: true, types: [] }, destroyAll: { defaults: [{}, {}], skip: true, types: [] }, find: { defaults: [undefined, {}], types: [] }, findAll: { defaults: [{}, {}], types: [] }, sum: { defaults: [undefined, {}, {}], skip: true, types: [] }, update: { adapterArgs (mapper, id, props, opts) { return [id, mapper.toJSON(props, opts), opts] }, beforeAssign: 1, defaults: [undefined, {}, {}], types: [] }, updateAll: { adapterArgs (mapper, props, query, opts) { return [mapper.toJSON(props, opts), query, opts] }, beforeAssign: 0, defaults: [{}, {}, {}], types: [] }, updateMany: { adapterArgs (mapper, records, opts) { return [records.map(function (record) { return mapper.toJSON(record, opts) }), opts] }, beforeAssign: 0, defaults: [[], {}], types: [] } } const MAPPER_DEFAULTS = { /** * Hash of registered adapters. Don't modify directly. Use * {@link Mapper#registerAdapter} instead. * * @default {} * @name Mapper#_adapters * @since 3.0.0 * @tutorial [&quot;http://www.js-data.io/v3.0/docs/connecting-to-a-data-source&quot;,&quot;Connecting to a data source&quot;] */ _adapters: {}, /** * Whether to augment {@link Mapper#recordClass} with getter/setter property * accessors according to the properties defined in {@link Mapper#schema}. * This makes possible validation and change tracking on individual properties * when using the dot (e.g. `user.name = &quot;Bob&quot;`) operator to modify a * property. * * @default true * @name Mapper#applySchema * @since 3.0.0 * @type {boolean} */ applySchema: true, /** * Whether to enable debug-level logs. * * @default false * @name Mapper#debug * @since 3.0.0 * @type {boolean} */ debug: false, /** * The name of the registered adapter that this Mapper should used by default. * * @default &quot;http&quot; * @name Mapper#defaultAdapter * @since 3.0.0 * @tutorial [&quot;http://www.js-data.io/v3.0/docs/connecting-to-a-data-source&quot;,&quot;Connecting to a data source&quot;] * @type {string} */ defaultAdapter: 'http', /** * The field used as the unique identifier on records handled by this Mapper. * * @default id * @name Mapper#idAttribute * @since 3.0.0 * @type {string} */ idAttribute: 'id', /** * Whether this Mapper should emit operational events. * * @default true * @name Mapper#notify * @since 3.0.0 * @type {boolean} */ notify: true, /** * Whether {@link Mapper#create}, {@link Mapper#createMany}, * {@link Mapper#update}, {@link Mapper#updateAll}, {@link Mapper#updateMany}, * {@link Mapper#find}, {@link Mapper#findAll}, {@link Mapper#destroy}, * {@link Mapper#destroyAll}, {@link Mapper#count}, and {@link Mapper#sum} * should return a raw result object that contains both the instance data * returned by the adapter _and_ metadata about the operation. * * The default is to NOT return the result object, and instead return just the * instance data. * * @default false * @name Mapper#raw * @since 3.0.0 * @type {boolean} */ raw: false } /** * The core of JSData's [ORM/ODM][orm] implementation. Given a minimum amout of * meta information about a resource, a Mapper can perform generic CRUD * operations against that resource. Apart from its configuration, a Mapper is * stateless. The particulars of various persistence layers have been abstracted * into adapters, which a Mapper uses to perform its operations. * * The term &quot;Mapper&quot; comes from the [Data Mapper Pattern][pattern] described in * Martin Fowler's [Patterns of Enterprise Application Architecture][book]. A * Data Mapper moves data between [in-memory object instances][record] and a * relational or document-based database. JSData's Mapper can work with any * persistence layer you can write an adapter for. * * _(&quot;Model&quot; is a heavily overloaded term and is avoided in this documentation * to prevent confusion.)_ * * [orm]: https://en.wikipedia.org/wiki/Object-relational_mapping * [pattern]: https://en.wikipedia.org/wiki/Data_mapper_pattern * [book]: http://martinfowler.com/books/eaa.html * [record]: Record.html * * @example &lt;caption&gt;Import and instantiate&lt;/caption&gt; * import {Mapper} from 'js-data' * * const UserService = new Mapper({ name: 'user' }) * * @example &lt;caption&gt;Define a Mapper using the Container component&lt;/caption&gt; * import {Container} from 'js-data' * * const store = new Container() * store.defineMapper('user') * * @class Mapper * @extends Component * @param {Object} opts Configuration options. * @param {boolean} [opts.applySchema=true] See {@link Mapper#applySchema}. * @param {boolean} [opts.debug=false] See {@link Mapper#debug}. * @param {string} [opts.defaultAdapter=http] See {@link Mapper#defaultAdapter}. * @param {string} [opts.idAttribute=id] See {@link Mapper#idAttribute}. * @param {string} opts.name See {@link Mapper#name}. * @param {boolean} [opts.notify] See {@link Mapper#notify}. * @param {boolean} [opts.raw=false] See {@link Mapper#raw}. * @param {Function|boolean} [opts.recordClass] See {@link Mapper#recordClass}. * @returns {Mapper} A new {@link Mapper} instance. * @see http://www.js-data.io/v3.0/docs/components-of-jsdata#mapper * @since 3.0.0 * @tutorial [&quot;http://www.js-data.io/v3.0/docs/components-of-jsdata#mapper&quot;,&quot;Components of JSData: Mapper&quot;] * @tutorial [&quot;http://www.js-data.io/v3.0/docs/modeling-your-data&quot;,&quot;Modeling your data&quot;] */ export default Component.extend({ constructor: function Mapper (opts) { const self = this utils.classCallCheck(self, Mapper) Mapper.__super__.call(self) opts || (opts = {}) // Prepare certain properties to be non-enumerable Object.defineProperties(self, { _adapters: { value: undefined, writable: true }, /** * Set to `false` to force the Mapper to work with POJO objects only. * * @example &lt;caption&gt;Use POJOs only.&lt;/caption&gt; * import {Mapper, Record} from 'js-data' * const UserMapper = new Mapper({ recordClass: false }) * UserMapper.recordClass // false * const user = UserMapper#createRecord() * user instanceof Record // false * * @example &lt;caption&gt;Set to a custom class to have records wrapped in your custom class.&lt;/caption&gt; * import {Mapper, Record} from 'js-data' * // Custom class * class User { * constructor (props = {}) { * for (var key in props) { * if (props.hasOwnProperty(key)) { * this[key] = props[key] * } * } * } * } * const UserMapper = new Mapper({ recordClass: User }) * UserMapper.recordClass // function User() {} * const user = UserMapper#createRecord() * user instanceof Record // false * user instanceof User // true * * * @example &lt;caption&gt;Extend the {@link Record} class.&lt;/caption&gt; * import {Mapper, Record} from 'js-data' * // Custom class * class User extends Record { * constructor () { * super(props) * } * } * const UserMapper = new Mapper({ recordClass: User }) * UserMapper.recordClass // function User() {} * const user = UserMapper#createRecord() * user instanceof Record // true * user instanceof User // true * * @name Mapper#recordClass * @default {@link Record} * @see Record * @since 3.0.0 */ recordClass: { value: undefined, writable: true }, /** * The meta information describing this Mapper's available lifecycle * methods. __Do not modify.__ * * TODO: Improve documentation. * * @name Mapper#lifecycleMethods * @since 3.0.0 * @type {Object} */ lifecycleMethods: { value: LIFECYCLE_METHODS }, /** * This Mapper's {@link Schema}. * * @name Mapper#schema * @see Schema * @since 3.0.0 * @type {Schema} */ schema: { value: undefined, writable: true } }) // Apply user-provided configuration utils.fillIn(self, opts) // Fill in any missing options with the defaults utils.fillIn(self, utils.copy(MAPPER_DEFAULTS)) /** * The name for this Mapper. This is the minimum amount of meta information * required for a Mapper to be able to execute CRUD operations for a * Resource. * * @name Mapper#name * @since 3.0.0 * @type {string} */ if (!self.name) { throw utils.err(`new ${DOMAIN}`, 'opts.name')(400, 'string', self.name) } // Setup schema, with an empty default schema if necessary if (!(self.schema instanceof Schema)) { self.schema = new Schema(self.schema || {}) } // Create a subclass of Record that's tied to this Mapper if (utils.isUndefined(self.recordClass)) { const superClass = Record self.recordClass = superClass.extend({ constructor: (function () { var subClass = function Record (props, opts) { utils.classCallCheck(this, subClass) superClass.call(this, props, opts) } return subClass })() }) } if (self.recordClass) { self.recordClass.mapper = self // We can only apply the schema to the prototype of self.recordClass if the // class extends Record if (utils.getSuper(self.recordClass, true) === Record &amp;&amp; self.schema &amp;&amp; self.schema.apply &amp;&amp; self.applySchema) { self.schema.apply(self.recordClass.prototype) } } }, /** * Mapper lifecycle hook called by {@link Mapper#count}. If this method * returns a promise then {@link Mapper#count} will wait for the promise * to resolve before continuing. * * @method Mapper#afterCount * @param {Object} query The `query` argument passed to {@link Mapper#count}. * @param {Object} opts The `opts` argument passed to {@link Mapper#count}. * @param {*} result The result, if any. * @since 3.0.0 */ afterCount: notify2, /** * Mapper lifecycle hook called by {@link Mapper#create}. If this method * returns a promise then {@link Mapper#create} will wait for the promise * to resolve before continuing. * * @method Mapper#afterCreate * @param {Object} props The `props` argument passed to {@link Mapper#create}. * @param {Object} opts The `opts` argument passed to {@link Mapper#create}. * @param {*} result The result, if any. * @since 3.0.0 */ afterCreate: notify2, /** * Mapper lifecycle hook called by {@link Mapper#createMany}. If this method * returns a promise then {@link Mapper#createMany} will wait for the promise * to resolve before continuing. * * @method Mapper#afterCreateMany * @param {Array} records The `records` argument passed to {@link Mapper#createMany}. * @param {Object} opts The `opts` argument passed to {@link Mapper#createMany}. * @param {*} result The result, if any. * @since 3.0.0 */ afterCreateMany: notify2, /** * Mapper lifecycle hook called by {@link Mapper#destroy}. If this method * returns a promise then {@link Mapper#destroy} will wait for the promise * to resolve before continuing. * * @method Mapper#afterDestroy * @param {(string|number)} id The `id` argument passed to {@link Mapper#destroy}. * @param {Object} opts The `opts` argument passed to {@link Mapper#destroy}. * @param {*} result The result, if any. * @since 3.0.0 */ afterDestroy: notify2, /** * Mapper lifecycle hook called by {@link Mapper#destroyAll}. If this method * returns a promise then {@link Mapper#destroyAll} will wait for the promise * to resolve before continuing. * * @method Mapper#afterDestroyAll * @param {*} data The `data` returned by the adapter. * @param {query} query The `query` argument passed to {@link Mapper#destroyAll}. * @param {Object} opts The `opts` argument passed to {@link Mapper#destroyAll}. * @param {*} result The result, if any. * @since 3.0.0 */ afterDestroyAll: notify2, /** * Mapper lifecycle hook called by {@link Mapper#find}. If this method * returns a promise then {@link Mapper#find} will wait for the promise * to resolve before continuing. * * @method Mapper#afterFind * @param {(string|number)} id The `id` argument passed to {@link Mapper#find}. * @param {Object} opts The `opts` argument passed to {@link Mapper#find}. * @param {*} result The result, if any. * @since 3.0.0 */ afterFind: notify2, /** * Mapper lifecycle hook called by {@link Mapper#findAll}. If this method * returns a promise then {@link Mapper#findAll} will wait for the promise * to resolve before continuing. * * @method Mapper#afterFindAll * @param {Object} query The `query` argument passed to {@link Mapper#findAll}. * @param {Object} opts The `opts` argument passed to {@link Mapper#findAll}. * @param {*} result The result, if any. * @since 3.0.0 */ afterFindAll: notify2, /** * Mapper lifecycle hook called by {@link Mapper#sum}. If this method * returns a promise then {@link Mapper#sum} will wait for the promise * to resolve before continuing. * * @method Mapper#afterSum * @param {Object} query The `query` argument passed to {@link Mapper#sum}. * @param {Object} opts The `opts` argument passed to {@link Mapper#sum}. * @param {*} result The result, if any. * @since 3.0.0 */ afterSum: notify2, /** * Mapper lifecycle hook called by {@link Mapper#update}. If this method * returns a promise then {@link Mapper#update} will wait for the promise * to resolve before continuing. * * @method Mapper#afterUpdate * @param {(string|number)} id The `id` argument passed to {@link Mapper#update}. * @param {props} props The `props` argument passed to {@link Mapper#update}. * @param {Object} opts The `opts` argument passed to {@link Mapper#update}. * @param {*} result The result, if any. * @since 3.0.0 */ afterUpdate: notify2, /** * Mapper lifecycle hook called by {@link Mapper#updateAll}. If this method * returns a promise then {@link Mapper#updateAll} will wait for the promise * to resolve before continuing. * * @method Mapper#afterUpdateAll * @param {Object} props The `props` argument passed to {@link Mapper#updateAll}. * @param {Object} query The `query` argument passed to {@link Mapper#updateAll}. * @param {Object} opts The `opts` argument passed to {@link Mapper#updateAll}. * @param {*} result The result, if any. * @since 3.0.0 */ afterUpdateAll: notify2, /** * Mapper lifecycle hook called by {@link Mapper#updateMany}. If this method * returns a promise then {@link Mapper#updateMany} will wait for the promise * to resolve before continuing. * * @method Mapper#afterUpdateMany * @param {Array} records The `records` argument passed to {@link Mapper#updateMany}. * @param {Object} opts The `opts` argument passed to {@link Mapper#updateMany}. * @param {*} result The result, if any. * @since 3.0.0 */ afterUpdateMany: notify2, /** * Mapper lifecycle hook called by {@link Mapper#create}. If this method * returns a promise then {@link Mapper#create} will wait for the promise * to resolve before continuing. * * @method Mapper#beforeCreate * @param {Object} props The `props` argument passed to {@link Mapper#create}. * @param {Object} opts The `opts` argument passed to {@link Mapper#create}. * @since 3.0.0 */ beforeCreate: notify, /** * Mapper lifecycle hook called by {@link Mapper#createMany}. If this method * returns a promise then {@link Mapper#createMany} will wait for the promise * to resolve before continuing. * * @method Mapper#beforeCreateMany * @param {Array} records The `records` argument passed to {@link Mapper#createMany}. * @param {Object} opts The `opts` argument passed to {@link Mapper#createMany}. * @since 3.0.0 */ beforeCreateMany: notify, /** * Mapper lifecycle hook called by {@link Mapper#count}. If this method * returns a promise then {@link Mapper#count} will wait for the promise * to resolve before continuing. * * @method Mapper#beforeCount * @param {Object} query The `query` argument passed to {@link Mapper#count}. * @param {Object} opts The `opts` argument passed to {@link Mapper#count}. * @since 3.0.0 */ beforeCount: notify, /** * Mapper lifecycle hook called by {@link Mapper#destroy}. If this method * returns a promise then {@link Mapper#destroy} will wait for the promise * to resolve before continuing. * * @method Mapper#beforeDestroy * @param {(string|number)} id The `id` argument passed to {@link Mapper#destroy}. * @param {Object} opts The `opts` argument passed to {@link Mapper#destroy}. * @since 3.0.0 */ beforeDestroy: notify, /** * Mapper lifecycle hook called by {@link Mapper#destroyAll}. If this method * returns a promise then {@link Mapper#destroyAll} will wait for the promise * to resolve before continuing. * * @method Mapper#beforeDestroyAll * @param {query} query The `query` argument passed to {@link Mapper#destroyAll}. * @param {Object} opts The `opts` argument passed to {@link Mapper#destroyAll}. * @since 3.0.0 */ beforeDestroyAll: notify, /** * Mappers lifecycle hook called by {@link Mapper#find}. If this method * returns a promise then {@link Mapper#find} will wait for the promise * to resolve before continuing. * * @method Mapper#beforeFind * @param {(string|number)} id The `id` argument passed to {@link Mapper#find}. * @param {Object} opts The `opts` argument passed to {@link Mapper#find}. * @since 3.0.0 */ beforeFind: notify, /** * Mapper lifecycle hook called by {@link Mapper#findAll}. If this method * returns a promise then {@link Mapper#findAll} will wait for the promise * to resolve before continuing. * * @method Mapper#beforeFindAll * @param {Object} query The `query` argument passed to {@link Mapper#findAll}. * @param {Object} opts The `opts` argument passed to {@link Mapper#findAll}. * @since 3.0.0 */ beforeFindAll: notify, /** * Mapper lifecycle hook called by {@link Mapper#sum}. If this method * returns a promise then {@link Mapper#sum} will wait for the promise * to resolve before continuing. * * @method Mapper#beforeSum * @param {string} field The `field` argument passed to {@link Mapper#sum}. * @param {Object} query The `query` argument passed to {@link Mapper#sum}. * @param {Object} opts The `opts` argument passed to {@link Mapper#sum}. * @since 3.0.0 */ beforeSum: notify, /** * Mapper lifecycle hook called by {@link Mapper#update}. If this method * returns a promise then {@link Mapper#update} will wait for the promise * to resolve before continuing. * * @method Mapper#beforeUpdate * @param {(string|number)} id The `id` argument passed to {@link Mapper#update}. * @param {props} props The `props` argument passed to {@link Mapper#update}. * @param {Object} opts The `opts` argument passed to {@link Mapper#update}. * @since 3.0.0 */ beforeUpdate: notify, /** * Mapper lifecycle hook called by {@link Mapper#updateAll}. If this method * returns a promise then {@link Mapper#updateAll} will wait for the promise * to resolve before continuing. * * @method Mapper#beforeUpdateAll * @param {Object} props The `props` argument passed to {@link Mapper#updateAll}. * @param {Object} query The `query` argument passed to {@link Mapper#updateAll}. * @param {Object} opts The `opts` argument passed to {@link Mapper#updateAll}. * @since 3.0.0 */ beforeUpdateAll: notify, /** * Mapper lifecycle hook called by {@link Mapper#updateMany}. If this method * returns a promise then {@link Mapper#updateMany} will wait for the promise * to resolve before continuing. * * @method Mapper#beforeUpdateMany * @param {Array} records The `records` argument passed to {@link Mapper#updateMany}. * @param {Object} opts The `opts` argument passed to {@link Mapper#updateMany}. * @since 3.0.0 */ beforeUpdateMany: notify, /** * This method is called at the end of most lifecycle methods. It does the * following: * * 1. If `opts.raw` is `true`, add this Mapper's configuration to the `opts` * argument as metadata for the operation. * 2. Wrap the result data appropriately using {@link Mapper#wrap}, which * calls {@link Mapper#createRecord}. * * @method Mapper#_end * @private * @since 3.0.0 */ _end (result, opts, skip) { const self = this if (opts.raw) { utils._(result, opts) } if (skip) { return result } let _data = opts.raw ? result.data : result if (_data &amp;&amp; utils.isFunction(self.wrap)) { _data = self.wrap(_data, opts) if (opts.raw) { result.data = _data } else { result = _data } } return result }, /** * Define a belongsTo relationship. Only useful if you're managing your * Mappers manually and not using a Container or DataStore component. * * @example * PostService.belongsTo(UserService, { * // post.user_id points to user.id * foreignKey: 'user_id' * // user records will be attached to post records at &quot;post.user&quot; * localField: 'user' * }) * * CommentService.belongsTo(UserService, { * // comment.user_id points to user.id * foreignKey: 'user_id' * // user records will be attached to comment records at &quot;comment.user&quot; * localField: 'user' * }) * CommentService.belongsTo(PostService, { * // comment.post_id points to post.id * foreignKey: 'post_id' * // post records will be attached to comment records at &quot;comment.post&quot; * localField: 'post' * }) * * @method Mapper#belongsTo * @see http://www.js-data.io/v3.0/docs/relations * @since 3.0.0 */ belongsTo (relatedMapper, opts) { return belongsTo(relatedMapper, opts)(this) }, /** * Select records according to the `query` argument and return the count. * * {@link Mapper#beforeCount} will be called before calling the adapter. * {@link Mapper#afterCount} will be called after calling the adapter. * * @example &lt;caption&gt;Get the number of published blog posts&lt;/caption&gt; * PostService.count({ status: 'published' }).then((numPublished) =&gt; { * console.log(numPublished) // e.g. 45 * }) * * @method Mapper#count * @param {Object} [query={}] Selection query. See {@link query}. * @param {Object} [query.where] See {@link query.where}. * @param {number} [query.offset] See {@link query.offset}. * @param {number} [query.limit] See {@link query.limit}. * @param {string|Array[]} [query.orderBy] See {@link query.orderBy}. * @param {Object} [opts] Configuration options. Refer to the `count` method * of whatever adapter you're using for more configuration options. * @param {boolean} [opts.adapter={@link Mapper#defaultAdapter}] Name of the * adapter to use. * @param {boolean} [opts.notify={@link Mapper#notify}] See {@link Mapper#notify}. * @param {boolean} [opts.raw={@link Mapper#raw}] See {@link Mapper#raw}. * @returns {Promise} Resolves with the count of the selected records. * @since 3.0.0 */ count (query, opts) { return this.crud('count', query, opts) }, /** * Create and save a new the record using the provided `props`. * * {@link Mapper#beforeCreate} will be called before calling the adapter. * {@link Mapper#afterCreate} will be called after calling the adapter. * * @example &lt;caption&gt;Create and save a new blog post&lt;/caption&gt; * PostService.create({ * title: 'Modeling your data', * status: 'draft' * }).then((post) =&gt; { * console.log(post) // { id: 1234, status: 'draft', ... } * }) * * @method Mapper#create * @param {Object} props The properties for the new record. * @param {Object} [opts] Configuration options. Refer to the `create` method * of whatever adapter you're using for more configuration options. * @param {boolean} [opts.adapter={@link Mapper#defaultAdapter}] Name of the * adapter to use. * @param {boolean} [opts.notify={@link Mapper#notify}] See {@link Mapper#notify}. * @param {boolean} [opts.raw={@link Mapper#raw}] See {@link Mapper#raw}. * @param {string[]} [opts.with=[]] Relations to create in a cascading * create if `props` contains nested relations. NOT performed in a * transaction. Each nested create will result in another {@link Mapper#create} * or {@link Mapper#createMany} call. * @param {string[]} [opts.pass=[]] Relations to send to the adapter as part * of the payload. Normally relations are not sent. * @returns {Promise} Resolves with the created record. * @since 3.0.0 */ create (props, opts) { let op, adapter const self = this // Default values for arguments props || (props = {}) opts || (opts = {}) // Fill in &quot;opts&quot; with the Mapper's configuration utils._(opts, self) adapter = opts.adapter = self.getAdapterName(opts) // beforeCreate lifecycle hook op = opts.op = 'beforeCreate' return utils.resolve(self[op](props, opts)).then(function (_props) { // Allow for re-assignment from lifecycle hook props = utils.isUndefined(_props) ? props : _props // Deep pre-create belongsTo relations const belongsToRelationData = {} opts.with || (opts.with = []) let tasks = [] utils.forEachRelation(self, opts, function (def, optsCopy) { const relationData = def.getLocalField(props) const relatedMapper = def.getRelation() const relatedIdAttribute = relatedMapper.idAttribute optsCopy.raw = false if (!relationData) { return } if (def.type === belongsToType) { // Create belongsTo relation first because we need a generated id to // attach to the child tasks.push(relatedMapper.create(relationData, optsCopy).then(function (data) { def.setLocalField(belongsToRelationData, data) def.setForeignKey(props, data) })) } else if (def.type === hasManyType &amp;&amp; def.localKeys) { // Create his hasMany relation first because it uses localKeys tasks.push(relatedMapper.createMany(relationData, optsCopy).then(function (data) { def.setLocalField(belongsToRelationData, data) utils.set(props, def.localKeys, data.map(function (record) { return utils.get(record, relatedIdAttribute) })) })) } }) return utils.Promise.all(tasks).then(function () { // Now delegate to the adapter for the main create op = opts.op = 'create' self.dbg(op, props, opts) return utils.resolve(self.getAdapter(adapter)[op](self, self.toJSON(props, { with: opts.pass || [] }), opts)) }).then(function (data) { const createdRecord = opts.raw ? data.data : data // Deep post-create hasMany and hasOne relations tasks = [] utils.forEachRelation(self, opts, function (def, optsCopy) { const relationData = def.getLocalField(props) if (!relationData) { return } optsCopy.raw = false let task // Create hasMany and hasOne after the main create because we needed // a generated id to attach to these items if (def.type === hasManyType &amp;&amp; def.foreignKey) { def.setForeignKey(createdRecord, relationData) task = def.getRelation().createMany(relationData, optsCopy).then(function (data) { def.setLocalField(createdRecord, data) }) } else if (def.type === hasOneType) { def.setForeignKey(createdRecord, relationData) task = def.getRelation().create(relationData, optsCopy).then(function (data) { def.setLocalField(createdRecord, data) }) } else if (def.type === belongsToType &amp;&amp; def.getLocalField(belongsToRelationData)) { def.setLocalField(createdRecord, def.getLocalField(belongsToRelationData)) } else if (def.type === hasManyType &amp;&amp; def.localKeys &amp;&amp; def.getLocalField(belongsToRelationData)) { def.setLocalField(createdRecord, def.getLocalField(belongsToRelationData)) } if (task) { tasks.push(task) } }) return utils.Promise.all(tasks).then(function () { return data }) }) }).then(function (result) { result = self._end(result, opts) // afterCreate lifecycle hook op = opts.op = 'afterCreate' return utils.resolve(self[op](props, opts, result)).then(function (_result) { // Allow for re-assignment from lifecycle hook return utils.isUndefined(_result) ? result : _result }) }) }, /** * Use {@link Mapper#createRecord} instead. * @deprecated * @method Mapper#createInstance * @param {Object|Array} props See {@link Mapper#createRecord}. * @param {Object} [opts] See {@link Mapper#createRecord}. * @returns {Object|Array} See {@link Mapper#createRecord}. * @see Mapper#createRecord * @since 3.0.0 */ createInstance (props, opts) { return this.createRecord(props, opts) }, /** * Given an array of records, batch create them via an adapter. * * {@link Mapper#beforeCreateMany} will be called before calling the adapter. * {@link Mapper#afterCreateMany} will be called after calling the adapter. * * @example &lt;caption&gt;Create and save several new blog posts&lt;/caption&gt; * PostService.createMany([{ * title: 'Modeling your data', * status: 'draft' * }, { * title: 'Reading data', * status: 'draft' * }]).then((posts) =&gt; { * console.log(posts[0]) // { id: 1234, status: 'draft', ... } * console.log(posts[1]) // { id: 1235, status: 'draft', ... } * }) * * @method Mapper#createMany * @param {Record[]} records Array of records to be created in one batch. * @param {Object} [opts] Configuration options. Refer to the `createMany` * method of whatever adapter you're using for more configuration options. * @param {boolean} [opts.adapter={@link Mapper#defaultAdapter}] Name of the * adapter to use. * @param {boolean} [opts.notify={@link Mapper#notify}] See {@link Mapper#notify}. * @param {boolean} [opts.raw={@link Mapper#raw}] See {@link Mapper#raw}. * @param {string[]} [opts.with=[]] Relations to create in a cascading * create if `records` contains nested relations. NOT performed in a * transaction. Each nested create will result in another {@link Mapper#createMany} * call. * @param {string[]} [opts.pass=[]] Relations to send to the adapter as part * of the payload. Normally relations are not sent. * @returns {Promise} Resolves with the created records. * @since 3.0.0 * @tutorial [&quot;http://www.js-data.io/v3.0/docs/saving-data&quot;,&quot;Saving data&quot;] */ createMany (records, opts) { let op, adapter const self = this // Default values for arguments records || (records = []) opts || (opts = {}) // Fill in &quot;opts&quot; with the Mapper's configuration utils._(opts, self) adapter = opts.adapter = self.getAdapterName(opts) // beforeCreateMany lifecycle hook op = opts.op = 'beforeCreateMany' return utils.resolve(self[op](records, opts)).then(function (_records) { // Allow for re-assignment from lifecycle hook records = utils.isUndefined(_records) ? records : _records // Deep pre-create belongsTo relations const belongsToRelationData = {} opts.with || (opts.with = []) let tasks = [] utils.forEachRelation(self, opts, function (def, optsCopy) { const relationData = records.map(function (record) { return def.getLocalField(record) }).filter(function (relatedRecord) { return relatedRecord }) if (def.type === belongsToType &amp;&amp; relationData.length === records.length) { // Create belongsTo relation first because we need a generated id to // attach to the child tasks.push(def.getRelation().createMany(relationData, optsCopy).then(function (data) { const relatedRecords = optsCopy.raw ? data.data : data def.setLocalField(belongsToRelationData, relatedRecords) records.forEach(function (record, i) { def.setForeignKey(record, relatedRecords[i]) }) })) } }) return utils.Promise.all(tasks).then(function () { // Now delegate to the adapter op = opts.op = 'createMany' const json = records.map(function (record) { return self.toJSON(record, { with: opts.pass || [] }) }) self.dbg(op, records, opts) return utils.resolve(self.getAdapter(adapter)[op](self, json, opts)) }).then(function (data) { const createdRecords = opts.raw ? data.data : data // Deep post-create hasOne relations tasks = [] utils.forEachRelation(self, opts, function (def, optsCopy) { const relationData = records.map(function (record) { return def.getLocalField(record) }).filter(function (relatedRecord) { return relatedRecord }) if (relationData.length !== records.length) { return } const belongsToData = def.getLocalField(belongsToRelationData) let task // Create hasMany and hasOne after the main create because we needed // a generated id to attach to these items if (def.type === hasManyType) { // Not supported self.log('warn', 'deep createMany of hasMany type not supported!') } else if (def.type === hasOneType) { createdRecords.forEach(function (createdRecord, i) { def.setForeignKey(createdRecord, relationData[i]) }) task = def.getRelation().createMany(relationData, optsCopy).then(function (data) { const relatedData = opts.raw ? data.data : data createdRecords.forEach(function (createdRecord, i) { def.setLocalField(createdRecord, relatedData[i]) }) }) } else if (def.type === belongsToType &amp;&amp; belongsToData &amp;&amp; belongsToData.length === createdRecords.length) { createdRecords.forEach(function (createdRecord, i) { def.setLocalField(createdRecord, belongsToData[i]) }) } if (task) { tasks.push(task) } }) return utils.Promise.all(tasks).then(function () { return data }) }) }).then(function (result) { result = self._end(result, opts) // afterCreateMany lifecycle hook op = opts.op = 'afterCreateMany' return utils.resolve(self[op](records, opts, result)).then(function (_result) { // Allow for re-assignment from lifecycle hook return utils.isUndefined(_result) ? result : _result }) }) }, /** * Create an unsaved, uncached instance of this Mapper's * {@link Mapper#recordClass}. * * Returns `props` if `props` is already an instance of * {@link Mapper#recordClass}. * * __Note:__ This method does __not__ interact with any adapter, and does * __not__ save any data. It only creates new objects in memory. * * @example &lt;caption&gt;Create empty unsaved record instance&lt;/caption&gt; * const post = PostService.createRecord() * * @example &lt;caption&gt;Create an unsaved record instance with inital properties&lt;/caption&gt; * const post = PostService.createRecord({ * title: 'Modeling your data', * status: 'draft' * }) * * @example &lt;caption&gt;Create a record instance that corresponds to a saved record&lt;/caption&gt; * const post = PostService.createRecord({ * // JSData thinks this record has been saved if it has a primary key * id: 1234, * title: 'Modeling your data', * status: 'draft' * }) * * @example &lt;caption&gt;Create record instances from an array&lt;/caption&gt; * const posts = PostService.createRecord([{ * title: 'Modeling your data', * status: 'draft' * }, { * title: 'Reading data', * status: 'draft' * }]) * * @example &lt;caption&gt;Records are validated by default&lt;/caption&gt; * import {Mapper} from 'js-data' * const PostService = new Mapper({ * name: 'post', * schema: { properties: { title: { type: 'string' } } } * }) * try { * const post = PostService.createRecord({ * title: 1234, * }) * } catch (err) { * console.log(err.errors) // [{ expected: 'one of (string)', actual: 'number', path: 'title' }] * } * * @example &lt;caption&gt;Skip validation&lt;/caption&gt; * import {Mapper} from 'js-data' * const PostService = new Mapper({ * name: 'post', * schema: { properties: { title: { type: 'string' } } } * }) * const post = PostService.createRecord({ * title: 1234, * }, { noValidate: true }) * console.log(post.isValid()) // false * * @method Mapper#createRecord * @param {Object|Object[]} props The properties for the Record instance or an * array of property objects for the Record instances. * @param {Object} [opts] Configuration options. * @param {boolean} [opts.noValidate=false] Whether to skip validation when * the Record instances are created. * @returns {Record|Record[]} The Record instance or Record instances. * @since 3.0.0 */ createRecord (props, opts) { props || (props = {}) const self = this if (utils.isArray(props)) { return props.map(function (_props) { return self.createRecord(_props, opts) }) } if (!utils.isObject(props)) { throw utils.err(`${DOMAIN}#createRecord`, 'props')(400, 'array or object', props) } const recordClass = self.recordClass const relationList = self.relationList || [] relationList.forEach(function (def) { const relatedMapper = def.getRelation() const relationData = def.getLocalField(props) if (relationData &amp;&amp; !relatedMapper.is(relationData)) { if (utils.isArray(relationData) &amp;&amp; (!relationData.length || relatedMapper.is(relationData[0]))) { return } utils.set(props, def.localField, relatedMapper.createRecord(relationData, opts)) } }) // Check to make sure &quot;props&quot; is not already an instance of this Mapper. return recordClass ? (props instanceof recordClass ? props : new recordClass(props, opts)) : props // eslint-disable-line }, /** * Lifecycle invocation method. * * TODO: Improve documentation for this method. * * @method Mapper#crud * @param {string} method Name of the lifecycle method to invoke. * @param {...*} args Arguments to pass to the lifecycle method. * @returns {Promise} * @since 3.0.0 */ crud (method, ...args) { const self = this const config = self.lifecycleMethods[method] if (!config) { throw utils.err(`${DOMAIN}#crud`, method)(404, 'method') } const upper = `${method.charAt(0).toUpperCase()}${method.substr(1)}` const before = `before${upper}` const after = `after${upper}` let op, adapter // Default values for arguments config.defaults.forEach(function (value, i) { if (utils.isUndefined(args[i])) { args[i] = utils.copy(value) } }) const opts = args[args.length - 1] // Fill in &quot;opts&quot; with the Mapper's configuration utils._(opts, self) adapter = opts.adapter = self.getAdapterName(opts) // before lifecycle hook op = opts.op = before return utils.resolve(self[op](...args)).then(function (_value) { if (!utils.isUndefined(config.beforeAssign)) { // Allow for re-assignment from lifecycle hook args[config.beforeAssign] = utils.isUndefined(_value) ? args[config.beforeAssign] : _value } // Now delegate to the adapter op = opts.op = method args = config.adapterArgs ? config.adapterArgs(self, ...args) : args self.dbg(op, ...args) return utils.resolve(self.getAdapter(adapter)[op](self, ...args)) }).then(function (result) { result = self._end(result, opts, !!config.skip) args.push(result) // after lifecycle hook op = opts.op = after return utils.resolve(self[op](...args)).then(function (_result) { // Allow for re-assignment from lifecycle hook return utils.isUndefined(_result) ? result : _result }) }) }, /** * Using an adapter, destroy the record with the given primary key. * * {@link Mapper#beforeDestroy} will be called before destroying the record. * {@link Mapper#afterDestroy} will be called after destroying the record. * * @example &lt;caption&gt;Destroy a specific blog post&lt;/caption&gt; * PostService.destroy(1234).then(() =&gt; { * // Blog post #1234 has been destroyed * }) * * @example &lt;caption&gt;Get full response&lt;/caption&gt; * PostService.destroy(1234, { raw: true }).then((result) =&gt; { * console.log(result.deleted) e.g. 1 * console.log(...) // etc., more metadata can be found on the result * }) * * @method Mapper#destroy * @param {(string|number)} id The primary key of the record to destroy. * @param {Object} [opts] Configuration options. Refer to the `destroy` method * of whatever adapter you're using for more configuration options. * @param {boolean} [opts.adapter={@link Mapper#defaultAdapter}] Name of the * adapter to use. * @param {boolean} [opts.notify={@link Mapper#notify}] See {@link Mapper#notify}. * @param {boolean} [opts.raw={@link Mapper#raw}] See {@link Mapper#raw}. * @returns {Promise} Resolves when the record has been destroyed. Resolves * even if no record was found to be destroyed. * @since 3.0.0 * @tutorial [&quot;http://www.js-data.io/v3.0/docs/saving-data&quot;,&quot;Saving data&quot;] */ destroy (id, opts) { return this.crud('destroy', id, opts) }, /** * Destroy the records selected by `query` via an adapter. If no `query` is * provided then all records will be destroyed. * * {@link Mapper#beforeDestroyAll} will be called before destroying the records. * {@link Mapper#afterDestroyAll} will be called after destroying the records. * * @example &lt;caption&gt;Destroy all blog posts&lt;/caption&gt; * PostService.destroyAll().then(() =&gt; { * // All blog posts have been destroyed * }) * * @example &lt;caption&gt;Destroy all &quot;draft&quot; blog posts&lt;/caption&gt; * PostService.destroyAll({ status: 'draft' }).then(() =&gt; { * // All &quot;draft&quot; blog posts have been destroyed * }) * * @example &lt;caption&gt;Get full response&lt;/caption&gt; * const query = null * const options = { raw: true } * PostService.destroyAll(query, options).then((result) =&gt; { * console.log(result.deleted) e.g. 14 * console.log(...) // etc., more metadata can be found on the result * }) * * @method Mapper#destroyAll * @param {Object} [query={}] Selection query. See {@link query}. * @param {Object} [query.where] See {@link query.where}. * @param {number} [query.offset] See {@link query.offset}. * @param {number} [query.limit] See {@link query.limit}. * @param {string|Array[]} [query.orderBy] See {@link query.orderBy}. * @param {Object} [opts] Configuration options. Refer to the `destroyAll` * method of whatever adapter you're using for more configuration options. * @param {boolean} [opts.adapter={@link Mapper#defaultAdapter}] Name of the * adapter to use. * @param {boolean} [opts.notify={@link Mapper#notify}] See {@link Mapper#notify}. * @param {boolean} [opts.raw={@link Mapper#raw}] See {@link Mapper#raw}. * @returns {Promise} Resolves when the records have been destroyed. Resolves * even if no records were found to be destroyed. * @see query * @since 3.0.0 * @tutorial [&quot;http://www.js-data.io/v3.0/docs/saving-data&quot;,&quot;Saving data&quot;] */ destroyAll (query, opts) { return this.crud('destroyAll', query, opts) }, /** * Retrieve via an adapter the record with the given primary key. * * {@link Mapper#beforeFind} will be called before calling the adapter. * {@link Mapper#afterFind} will be called after calling the adapter. * * @example * PostService.find(1).then((post) =&gt; { * console.log(post) // { id: 1, ...} * }) * * @example &lt;caption&gt;Get full response&lt;/caption&gt; * PostService.find(1, { raw: true }).then((result) =&gt; { * console.log(result.data) // { id: 1, ...} * console.log(result.found) // 1 * console.log(...) // etc., more metadata can be found on the result * }) * * @method Mapper#find * @param {(string|number)} id The primary key of the record to retrieve. * @param {Object} [opts] Configuration options. Refer to the `find` method * of whatever adapter you're using for more configuration options. * @param {boolean} [opts.adapter={@link Mapper#defaultAdapter}] Name of the * adapter to use. * @param {boolean} [opts.notify={@link Mapper#notify}] See {@link Mapper#notify}. * @param {boolean} [opts.raw={@link Mapper#raw}] See {@link Mapper#raw}. * @param {string[]} [opts.with=[]] Relations to eager load in the request. * @returns {Promise} Resolves with the found record. Resolves with * `undefined` if no record was found. * @see http://www.js-data.io/v3.0/docs/reading-data * @since 3.0.0 * @tutorial [&quot;http://www.js-data.io/v3.0/docs/reading-data&quot;,&quot;Reading data&quot;] */ find (id, opts) { return this.crud('find', id, opts) }, /** * Using the `query` argument, select records to retrieve via an adapter. * * {@link Mapper#beforeFindAll} will be called before calling the adapter. * {@link Mapper#afterFindAll} will be called after calling the adapter. * * @example &lt;caption&gt;Find all &quot;published&quot; blog posts&lt;/caption&gt; * PostService.findAll({ status: 'published' }).then((posts) =&gt; { * console.log(posts) // [{ id: 1, status: 'published', ...}, ...] * }) * * @example &lt;caption&gt;Get full response&lt;/caption&gt; * PostService.findAll({ status: 'published' }, { raw: true }).then((result) =&gt; { * console.log(result.data) // [{ id: 1, status: 'published', ...}, ...] * console.log(result.found) // e.g. 13 * console.log(...) // etc., more metadata can be found on the result * }) * * @method Mapper#findAll * @param {Object} [query={}] Selection query. See {@link query}. * @param {Object} [query.where] See {@link query.where}. * @param {number} [query.offset] See {@link query.offset}. * @param {number} [query.limit] See {@link query.limit}. * @param {string|Array[]} [query.orderBy] See {@link query.orderBy}. * @param {Object} [opts] Configuration options. Refer to the `findAll` method * of whatever adapter you're using for more configuration options. * @param {boolean} [opts.adapter={@link Mapper#defaultAdapter}] Name of the * adapter to use. * @param {boolean} [opts.notify={@link Mapper#notify}] See {@link Mapper#notify}. * @param {boolean} [opts.raw={@link Mapper#raw}] See {@link Mapper#raw}. * @param {string[]} [opts.with=[]] Relations to eager load in the request. * @returns {Promise} Resolves with the found records, if any. * @see query * @since 3.0.0 * @tutorial [&quot;http://www.js-data.io/v3.0/docs/reading-data&quot;,&quot;Reading data&quot;] */ findAll (query, opts) { return this.crud('findAll', query, opts) }, /** * Return the registered adapter with the given name or the default adapter if * no name is provided. * * @method Mapper#getAdapter * @param {string} [name] The name of the adapter to retrieve. * @returns {Adapter} The adapter. * @since 3.0.0 * @tutorial [&quot;http://www.js-data.io/v3.0/docs/connecting-to-a-data-source&quot;,&quot;Connecting to a data source&quot;] */ getAdapter (name) { const self = this self.dbg('getAdapter', 'name:', name) const adapter = self.getAdapterName(name) if (!adapter) { throw utils.err(`${DOMAIN}#getAdapter`, 'name')(400, 'string', name) } return self.getAdapters()[adapter] }, /** * Return the name of a registered adapter based on the given name or options, * or the name of the default adapter if no name provided. * * @method Mapper#getAdapterName * @param {(Object|string)} [opts] The name of an adapter or options, if any. * @returns {string} The name of the adapter. * @since 3.0.0 * @tutorial [&quot;http://www.js-data.io/v3.0/docs/connecting-to-a-data-source&quot;,&quot;Connecting to a data source&quot;] */ getAdapterName (opts) { opts || (opts = {}) if (utils.isString(opts)) { opts = { adapter: opts } } return opts.adapter || opts.defaultAdapter }, /** * Get the object of registered adapters for this Mapper. * * @method Mapper#getAdapters * @returns {Object} {@link Mapper#_adapters} * @since 3.0.0 * @tutorial [&quot;http://www.js-data.io/v3.0/docs/connecting-to-a-data-source&quot;,&quot;Connecting to a data source&quot;] */ getAdapters () { return this._adapters }, /** * Returns this Mapper's {@link Schema}. * * @method Mapper#getSchema * @returns {Schema} This Mapper's {@link Schema}. * @see Mapper#schema * @since 3.0.0 */ getSchema () { return this.schema }, /** * Defines a hasMany relationship. Only useful if you're managing your * Mappers manually and not using a Container or DataStore component. * * @example * UserService.hasMany(PostService, { * // post.user_id points to user.id * foreignKey: 'user_id' * // post records will be attached to user records at &quot;user.posts&quot; * localField: 'posts' * }) * * @method Mapper#hasMany * @see http://www.js-data.io/v3.0/docs/relations * @since 3.0.0 */ hasMany (relatedMapper, opts) { return hasMany(relatedMapper, opts)(this) }, /** * Defines a hasOne relationship. Only useful if you're managing your Mappers * manually and not using a {@link Container} or {@link DataStore} component. * * @example * UserService.hasOne(ProfileService, { * // profile.user_id points to user.id * foreignKey: 'user_id' * // profile records will be attached to user records at &quot;user.profile&quot; * localField: 'profile' * }) * * @method Mapper#hasOne * @see http://www.js-data.io/v3.0/docs/relations * @since 3.0.0 */ hasOne (relatedMapper, opts) { return hasOne(relatedMapper, opts)(this) }, /** * Return whether `record` is an instance of this Mapper's recordClass. * * @example * const post = PostService.createRecord() * * console.log(PostService.is(post)) // true * // Equivalent to what's above * console.log(post instanceof PostService.recordClass) // true * * @method Mapper#is * @param {Object|Record} record The record to check. * @returns {boolean} Whether `record` is an instance of this Mapper's * {@link Mapper#recordClass}. * @since 3.0.0 */ is (record) { const recordClass = this.recordClass return recordClass ? record instanceof recordClass : false }, /** * Register an adapter on this Mapper under the given name. * * @method Mapper#registerAdapter * @param {string} name The name of the adapter to register. * @param {Adapter} adapter The adapter to register. * @param {Object} [opts] Configuration options. * @param {boolean} [opts.default=false] Whether to make the adapter the * default adapter for this Mapper. * @since 3.0.0 * @tutorial [&quot;http://www.js-data.io/v3.0/docs/connecting-to-a-data-source&quot;,&quot;Connecting to a data source&quot;] */ registerAdapter (name, adapter, opts) { const self = this opts || (opts = {}) self.getAdapters()[name] = adapter // Optionally make it the default adapter for the target. if (opts === true || opts.default) { self.defaultAdapter = name } }, /** * Select records according to the `query` argument, and aggregate the sum * value of the property specified by `field`. * * {@link Mapper#beforeSum} will be called before calling the adapter. * {@link Mapper#afterSum} will be called after calling the adapter. * * @example * PurchaseOrderService.sum('amount', { status: 'paid' }).then((amountPaid) =&gt; { * console.log(amountPaid) // e.g. 451125.34 * }) * * @method Mapper#sum * @param {string} field The field to sum. * @param {Object} [query={}] Selection query. See {@link query}. * @param {Object} [query.where] See {@link query.where}. * @param {number} [query.offset] See {@link query.offset}. * @param {number} [query.limit] See {@link query.limit}. * @param {string|Array[]} [query.orderBy] See {@link query.orderBy}. * @param {Object} [opts] Configuration options. Refer to the `sum` method * of whatever adapter you're using for more configuration options. * @param {boolean} [opts.adapter={@link Mapper#defaultAdapter}] Name of the * adapter to use. * @param {boolean} [opts.notify={@link Mapper#notify}] See {@link Mapper#notify}. * @param {boolean} [opts.raw={@link Mapper#raw}] See {@link Mapper#raw}. * @returns {Promise} Resolves with the aggregated sum. * @since 3.0.0 */ sum (field, query, opts) { return this.crud('sum', field, query, opts) }, /** * Return a plain object representation of the given record. Relations can * be optionally be included. Non-schema properties can be excluded. * * @example * import {Mapper, Schema} from 'js-data' * const PersonService = new Mapper({ * name: 'person', * schema: { * properties: { * name: { type: 'string' }, * id: { type: 'string' } * } * } * }) * const person = PersonService.createRecord({ id: 1, name: 'John', foo: 'bar' }) * console.log(PersonService.toJSON(person)) // {&quot;id&quot;:1,&quot;name&quot;:&quot;John&quot;,&quot;foo&quot;:&quot;bar&quot;} * console.log(PersonService.toJSON(person), { strict: true }) // {&quot;id&quot;:1,&quot;name&quot;:&quot;John&quot;} * * @method Mapper#toJSON * @param {Record|Record[]} records Record or records from which to create a * POJO representation. * @param {Object} [opts] Configuration options. * @param {boolean} [opts.strict] Whether to include properties that are not * defined in {@link Mapper#schema}. * @param {string[]} [opts.with] Array of relation names or relation fields * to include in the POJO representation. * @param {boolean} [opts.withAll] Whether to simply include all relations in * the representation. Overrides `opts.with`. * @returns {Object|Object[]} POJO representation of the record or records. * @since 3.0.0 */ toJSON (records, opts) { const self = this let record opts || (opts = {}) if (utils.isArray(records)) { return records.map(function (record) { return self.toJSON(record, opts) }) } else { record = records } const relationFields = (self ? self.relationFields : []) || [] let json = {} let properties if (self &amp;&amp; self.schema) { properties = self.schema.properties || {} // TODO: Make this work recursively utils.forOwn(properties, function (opts, prop) { json[prop] = utils.plainCopy(record[prop]) }) } properties || (properties = {}) if (!opts.strict) { for (var key in record) { if (!properties[key] &amp;&amp; relationFields.indexOf(key) === -1) { json[key] = utils.plainCopy(record[key]) } } } // The user wants to include relations in the resulting plain object // representation if (self &amp;&amp; opts.withAll) { opts.with = relationFields.slice() } if (self &amp;&amp; opts.with) { if (utils.isString(opts.with)) { opts.with = [opts.with] } utils.forEachRelation(self, opts, function (def, optsCopy) { const relationData = def.getLocalField(record) if (relationData) { // The actual recursion if (utils.isArray(relationData)) { def.setLocalField(json, relationData.map(function (item) { return def.getRelation().toJSON(item, optsCopy) })) } else { def.setLocalField(json, def.getRelation().toJSON(relationData, optsCopy)) } } }) } return json }, /** * Using an adapter, update the record with the primary key specified by the * `id` argument. * * {@link Mapper#beforeUpdate} will be called before updating the record. * {@link Mapper#afterUpdate} will be called after updating the record. * * @example &lt;caption&gt;Update a specific post&lt;/caption&gt; * PostService.update(1234, { * status: 'published', * published_at: new Date() * }).then((post) =&gt; { * console.log(post) // { id: 1234, status: 'published', ... } * }) * * @method Mapper#update * @param {(string|number)} id The primary key of the record to update. * @param {Object} props The update to apply to the record. * @param {Object} [opts] Configuration options. Refer to the `update` method * of whatever adapter you're using for more configuration options. * @param {boolean} [opts.adapter={@link Mapper#defaultAdapter}] Name of the * adapter to use. * @param {boolean} [opts.notify={@link Mapper#notify}] See {@link Mapper#notify}. * @param {boolean} [opts.raw={@link Mapper#raw}] See {@link Mapper#raw}. * transaction. * @returns {Promise} Resolves with the updated record. Rejects if the record * could not be found. * @since 3.0.0 * @tutorial [&quot;http://www.js-data.io/v3.0/docs/saving-data&quot;,&quot;Saving data&quot;] */ update (id, props, opts) { return this.crud('update', id, props, opts) }, /** * Using the `query` argument, perform the a single updated to the selected * records. * * {@link Mapper#beforeUpdateAll} will be called before making the update. * {@link Mapper#afterUpdateAll} will be called after making the update. * * @example &lt;caption&gt;Turn all of John's blog posts into drafts.&lt;/caption&gt; * const update = { status: draft: published_at: null } * const query = { userId: 1234 } * PostService.updateAll(update, query).then((posts) =&gt; { * console.log(posts) // [...] * }) * * @method Mapper#updateAll * @param {Object} props Update to apply to selected records. * @param {Object} [query={}] Selection query. See {@link query}. * @param {Object} [query.where] See {@link query.where}. * @param {number} [query.offset] See {@link query.offset}. * @param {number} [query.limit] See {@link query.limit}. * @param {string|Array[]} [query.orderBy] See {@link query.orderBy}. * @param {Object} [opts] Configuration options. Refer to the `updateAll` * method of whatever adapter you're using for more configuration options. * @param {boolean} [opts.adapter={@link Mapper#defaultAdapter}] Name of the * adapter to use. * @param {boolean} [opts.notify={@link Mapper#notify}] See {@link Mapper#notify}. * @param {boolean} [opts.raw={@link Mapper#raw}] See {@link Mapper#raw}. * @returns {Promise} Resolves with the update records, if any. * @see query * @since 3.0.0 * @tutorial [&quot;http://www.js-data.io/v3.0/docs/saving-data&quot;,&quot;Saving data&quot;] */ updateAll (props, query, opts) { return this.crud('updateAll', props, query, opts) }, /** * Given an array of updates, perform each of the updates via an adapter. Each * &quot;update&quot; is a hash of properties with which to update an record. Each * update must contain the primary key of the record to be updated. * * {@link Mapper#beforeUpdateMany} will be called before making the update. * {@link Mapper#afterUpdateMany} will be called after making the update. * * @example * PostService.updateMany([ * { id: 1234, status: 'draft' }, * { id: 2468, status: 'published', published_at: new Date() } * ]).then((posts) =&gt; { * console.log(posts) // [...] * }) * * @method Mapper#updateMany * @param {Record[]} records Array up record updates. * @param {Object} [opts] Configuration options. Refer to the `updateMany` * method of whatever adapter you're using for more configuration options. * @param {boolean} [opts.adapter={@link Mapper#defaultAdapter}] Name of the * adapter to use. * @param {boolean} [opts.notify={@link Mapper#notify}] See {@link Mapper#notify}. * @param {boolean} [opts.raw={@link Mapper#raw}] See {@link Mapper#raw}. * @returns {Promise} Resolves with the updated records. Rejects if any of the * records could be found. * @since 3.0.0 * @tutorial [&quot;http://www.js-data.io/v3.0/docs/saving-data&quot;,&quot;Saving data&quot;] */ updateMany (records, opts) { return this.crud('updateMany', records, opts) }, /** * Validate the given record or records according to this Mapper's * {@link Schema}. If there are no validation errors then the return value * will be `undefined`. * * @example * import {Mapper, Schema} from 'js-data' * const PersonSchema = new Schema({ * properties: { * name: { type: 'string' }, * id: { type: 'string' } * } * }) * const PersonService = new Mapper({ * name: 'person', * schema: PersonSchema * }) * let errors = PersonService.validate({ name: 'John' }) * console.log(errors) // undefined * errors = PersonService.validate({ name: 123 }) * console.log(errors) // [{ expected: 'one of (string)', actual: 'number', path: 'name' }] * * @method Mapper#validate * @param {Object|Object[]} record The record or records to validate. * @param {Object} [opts] Configuration options. Passed to * {@link Schema#validate}. * @returns {Object[]} Array of errors or `undefined` if no errors. * @since 3.0.0 */ validate (record, opts) { const self = this const schema = self.getSchema() if (utils.isArray(record)) { const errors = record.map(function (_record) { return schema.validate(_record, opts) }) let hasErrors = false errors.forEach(function (err) { if (err) { hasErrors = true } }) if (hasErrors) { return errors } return undefined } return schema.validate(record, opts) }, /** * Method used to wrap data returned by an adapter with this Mapper's * {@link Mapper#recordClass}. This method is used by all of a Mapper's CRUD * methods. The provided implementation of this method assumes that the `data` * passed to it is a record or records that need to be wrapped with * {@link Mapper#createRecord}. Override with care. * * Provided implementation of {@link Mapper#wrap}: * * ``` * function (data, opts) { * return this.createRecord(data, opts) * } * ``` * * @example &lt;caption&gt;Override to customize behavior&lt;/caption&gt; * const PostMapper = new Mapper({ * name: 'post', * wrap (data, opts) { * const originalWrap = this.constructor.prototype.wrap * // Let's say &quot;GET /post&quot; doesn't return JSON quite like JSData expects, * // but the actual post records are nested under a &quot;posts&quot; field. So, * // we override Mapper#wrap to handle this special case. * if (opts.op === 'findAll') { * return originalWrap.call(this, data.posts, opts) * } * // Otherwise perform original behavior * return originalWrap.call(this, data, opts) * } * }) * * @method Mapper#wrap * @param {Object|Object[]} data The record or records to be wrapped. * @param {Object} [opts] Configuration options. Passed to {@link Mapper#createRecord}. * @returns {Record|Record[]} The wrapped record or records. * @since 3.0.0 */ wrap (data, opts) { return this.createRecord(data, opts) } }) /** * Create a subclass of this Mapper. * * @example &lt;caption&gt;Extend the class in a cross-browser manner.&lt;/caption&gt; * import {Mapper} from 'js-data' * const CustomMapperClass = Mapper.extend({ * foo () { return 'bar' } * }) * const customMapper = new CustomMapperClass({ name: 'test' }) * console.log(customMapper.foo()) // &quot;bar&quot; * * @example &lt;caption&gt;Extend the class using ES2015 class syntax.&lt;/caption&gt; * class CustomMapperClass extends Mapper { * foo () { return 'bar' } * } * const customMapper = new CustomMapperClass({ name: 'test' }) * console.log(customMapper.foo()) // &quot;bar&quot; * * @method Mapper.extend * @param {Object} [props={}] Properties to add to the prototype of the * subclass. * @param {Object} [classProps={}] Static properties to add to the subclass. * @returns {Constructor} Subclass of this Mapper. * @since 3.0.0 */ × Search results Close api.js-data.io • js-data.io "},"index.js.html":{"id":"index.js.html","title":"Source: index.js","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentContainerDataStoreLinkedCollectionMapperQueryRecordSchema Source: index.js /** * Registered as `js-data` in NPM and Bower. * * Also available from CDN.JS and JSDelivr. * * @module js-data * * @example &lt;caption&gt;Install from NPM&lt;/caption&gt; * npm i --save js-data@beta * @example &lt;caption&gt;Install from Bower&lt;/caption&gt; * bower i --save js-data@3.0.0-beta.1 * @example &lt;caption&gt;Install from CDN.JS&lt;/caption&gt; * &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/js-data/3.0.0-beta.1/js-data.min.js&quot;&gt;&lt;/script&gt; * @example &lt;caption&gt;Install from JSDelivr&lt;/caption&gt; * &lt;script src=&quot;https://cdn.jsdelivr.net/js-data/3.0.0-beta.1/js-data.min.js&quot;&gt;&lt;/script&gt; * @example &lt;caption&gt;Load into your app via script tag&lt;/caption&gt; * &lt;script src=&quot;/path/to/js-data.min.js&quot;&gt;&lt;/script&gt; * &lt;script&gt; * console.log(JSData.version.full); // &quot;3.0.0-beta.1&quot; * &lt;/script&gt; * @example &lt;caption&gt;Load into your app via CommonJS&lt;/caption&gt; * var JSData = require('js-data'); * @example &lt;caption&gt;Load into your app via ES2015 Modules&lt;/caption&gt; * import * as JSData from 'js-data'; * @example &lt;caption&gt;Load into your app via AMD&lt;/caption&gt; * define('myApp', ['js-data'], function (JSData) { ... }) */ /** * Describes the version of this `JSData` object. * * @example * console.log(JSData.version.full) // &quot;3.0.0-beta.1&quot; * * @name version * @memberof module:js-data * @property {string} full The full semver value. * @property {number} major The major version number. * @property {number} minor The minor version number. * @property {number} patch The patch version number. * @property {(string|boolean)} alpha The alpha version value, otherwise `false` * if the current version is not alpha. * @property {(string|boolean)} beta The beta version value, otherwise `false` * if the current version is not beta. * @since 2.0.0 * @type {Object} */ export const version = '&lt;%= version %&gt;' /** * JSData's utility methods. * * @example * import {utils} from 'js-data' * console.log(utils.isString('foo')) // true * * @name module:js-data.utils * @property {Function} Promise See {@link utils.Promise}. * @see utils * @since 3.0.0 * @type {Object} */ import utils from './utils' /** * JSData's {@link Collection} class. * * @example * import {Collection} from 'js-data' * const collection = new Collection() * * @name module:js-data.Collection * @see Collection * @since 3.0.0 * @tutorial [&quot;http://www.js-data.io/v3.0/docs/components-of-jsdata#collection&quot;,&quot;Components of JSData: Collection&quot;] * @type {Constructor} */ import Collection from './Collection' /** * JSData's {@link Component} class. Most components in JSData extend this * class. * * @example * import {Component} from 'js-data' * // Make a custom component. * const MyComponent = Component.extend({ * myMethod (someArg) { ... } * }) * * @name module:js-data.Component * @see Component * @since 3.0.0 * @type {Constructor} */ import Component from './Component' /** * JSData's {@link Container} class. Defines and manages {@link Mapper}s. Used * in Node.js and in the browser, though in the browser you may want to use * {@link DataStore} instead. * * @example * import {Container} from 'js-data' * const store = new Container() * * @name module:js-data.Container * @see Container * @since 3.0.0 * @tutorial [&quot;http://www.js-data.io/v3.0/docs/components-of-jsdata#container&quot;,&quot;Components of JSData: Container&quot;] * @type {Constructor} */ import Container from './Container' /** * JSData's {@link DataStore} class. Primarily for use in the browser. In * Node.js you probably want to use {@link Container} instead. * * @example * import {DataStore} from 'js-data' * const store = new DataStore() * * @name module:js-data.DataStore * @see DataStore * @since 3.0.0 * @tutorial [&quot;http://www.js-data.io/v3.0/docs/components-of-jsdata#datastore&quot;,&quot;Components of JSData: DataStore&quot;] * @type {Constructor} */ import DataStore from './DataStore' /** * JSData's {@link Index} class, based on [mindex]{@link https://github.com/internalfx/mindex}. * * @name module:js-data.Index * @see Index * @since 3.0.0 * @type {Constructor} */ import Index from '../lib/mindex/index' /** * JSData's {@link LinkedCollection} class. Used by the {@link DataStore} * component. If you need to create a collection manually, you should probably * use the {@link Collection} class. * * @name module:js-data.LinkedCollection * @see DataStore * @see LinkedCollection * @since 3.0.0 * @type {Constructor} */ import LinkedCollection from './LinkedCollection' /** * JSData's {@link Mapper} class. The core of the ORM. * * @example &lt;caption&gt;Recommended use&lt;/caption&gt; * import {Container} from 'js-data' * const store = new Container() * const UserService = store.defineMapper('user') * * @example &lt;caption&gt;Create Mapper manually&lt;/caption&gt; * import {Mapper} from 'js-data' * const UserService = new Mapper({ name: 'user' }) * * @name module:js-data.Mapper * @see Container * @see Mapper * @since 3.0.0 * @tutorial [&quot;http://www.js-data.io/v3.0/docs/modeling-your-data&quot;,&quot;Modeling your data&quot;] * @tutorial [&quot;http://www.js-data.io/v3.0/docs/components-of-jsdata#mapper&quot;,&quot;Components of JSData: Mapper&quot;] * @type {Constructor} */ import Mapper from './Mapper' /** * JSData's {@link Query} class. Used by the {@link Collection} component. * * @name module:js-data.Query * @see Query * @since 3.0.0 * @type {Constructor} */ import Query from './Query' /** * JSData's {@link Record} class. * * @example * import {Container} from 'js-data' * const store = new Container() * const UserService = store.defineMapper('user') * const user = UserService.createRecord() * * @name module:js-data.Record * @see Record * @since 3.0.0 * @tutorial [&quot;http://www.js-data.io/v3.0/docs/components-of-jsdata#record&quot;,&quot;Components of JSData: Record&quot;] * @type {Constructor} */ import Record from './Record' /** * JSData's {@link Schema} class. Implements http://json-schema.org/draft-04. * * @example * import {Container, Schema} from 'js-data' * const userSchema = new Schema({ * properties: { * id: { type: 'string' }, * name: { type: 'string' } * } * }) * const store = new Container() * const UserService = store.defineMapper('user', { * schema: userSchema * }) * * @name module:js-data.Schema * @see Schema * @see http://json-schema.org/ * @since 3.0.0 * @tutorial [&quot;http://www.js-data.io/v3.0/docs/components-of-jsdata#schema&quot;,&quot;Components of JSData: schema&quot;] * @tutorial [&quot;http://www.js-data.io/v3.0/docs/schemas&quot;,&quot;JSData's Schema Syntax&quot;] * @type {Constructor} */ import Schema from './Schema' export * from './decorators' export { Collection, Component, Container, DataStore, Index, LinkedCollection, Mapper, Query, Record, Schema, utils } × Search results Close api.js-data.io • js-data.io "},"decorators.js.html":{"id":"decorators.js.html","title":"Source: decorators.js","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentContainerDataStoreLinkedCollectionMapperQueryRecordSchema Source: decorators.js import utils from './utils' export const belongsToType = 'belongsTo' export const hasManyType = 'hasMany' export const hasOneType = 'hasOne' const DOMAIN = 'Relation' function Relation (related, opts) { const self = this const DOMAIN_ERR = `new ${DOMAIN}` opts || (opts = {}) const localField = opts.localField if (!localField) { throw utils.err(DOMAIN_ERR, 'opts.localField')(400, 'string', localField) } const foreignKey = opts.foreignKey = opts.foreignKey || opts.localKey if (!foreignKey &amp;&amp; (opts.type === belongsToType || opts.type === hasOneType)) { throw utils.err(DOMAIN_ERR, 'opts.foreignKey')(400, 'string', foreignKey) } const localKeys = opts.localKeys const foreignKeys = opts.foreignKeys if (!foreignKey &amp;&amp; !localKeys &amp;&amp; !foreignKeys &amp;&amp; opts.type === hasManyType) { throw utils.err(DOMAIN_ERR, 'opts.&lt;foreignKey|localKeys|foreignKeys&gt;')(400, 'string', foreignKey) } if (utils.isString(related)) { opts.relation = related if (!utils.isFunction(opts.getRelation)) { throw utils.err(DOMAIN_ERR, 'opts.getRelation')(400, 'function', opts.getRelation) } } else if (related) { opts.relation = related.name Object.defineProperty(self, 'relatedMapper', { value: related }) } else { throw utils.err(DOMAIN_ERR, 'related')(400, 'Mapper or string', related) } Object.defineProperty(self, 'inverse', { value: undefined, writable: true }) utils.fillIn(self, opts) } utils.addHiddenPropsToTarget(Relation.prototype, { getRelation () { return this.relatedMapper }, getForeignKey (record) { if (this.type === belongsToType) { return utils.get(record, this.foreignKey) } return utils.get(record, this.mapper.idAttribute) }, setForeignKey (record, relatedRecord) { const self = this if (!record || !relatedRecord) { return } if (self.type === belongsToType) { utils.set(record, self.foreignKey, utils.get(relatedRecord, self.getRelation().idAttribute)) } else { const idAttribute = self.mapper.idAttribute if (utils.isArray(relatedRecord)) { relatedRecord.forEach(function (relatedRecordItem) { utils.set(relatedRecordItem, self.foreignKey, utils.get(record, idAttribute)) }) } else { utils.set(relatedRecord, self.foreignKey, utils.get(record, idAttribute)) } } }, getLocalField (record) { return utils.get(record, this.localField) }, setLocalField (record, data) { return utils.set(record, this.localField, data) }, getInverse (mapper) { const self = this if (self.inverse) { return self.inverse } self.getRelation().relationList.forEach(function (def) { if (def.getRelation() === mapper) { if (def.foreignKey &amp;&amp; def.foreignKey !== self.foreignKey) { return } self.inverse = def return false } }) return self.inverse } }) const relatedTo = function (mapper, related, opts) { opts.name = mapper.name const relation = new Relation(related, opts) Object.defineProperty(relation, 'mapper', { value: mapper }) mapper.relationList || Object.defineProperty(mapper, 'relationList', { value: [] }) mapper.relationFields || Object.defineProperty(mapper, 'relationFields', { value: [] }) mapper.relationList.push(relation) mapper.relationFields.push(relation.localField) } /** * TODO * * @name module:js-data.belongsTo * @method * @param {Mapper} related The relation the target belongs to. * @param {Object} opts Configuration options. * @param {string} opts.foreignKey The field that holds the primary key of the * related record. * @param {string} opts.localField The field that holds a reference to the * related record object. * @returns {Function} Invocation function, which accepts the target as the only * parameter. */ export const belongsTo = function (related, opts) { opts || (opts = {}) opts.type = belongsToType return function (target) { relatedTo(target, related, opts) } } /** * TODO * * @name module:js-data.hasMany * @method * @param {Mapper} related The relation of which the target has many. * @param {Object} opts Configuration options. * @param {string} [opts.foreignKey] The field that holds the primary key of the * related record. * @param {string} opts.localField The field that holds a reference to the * related record object. * @returns {Function} Invocation function, which accepts the target as the only * parameter. */ export const hasMany = function (related, opts) { opts || (opts = {}) opts.type = hasManyType return function (target) { relatedTo(target, related, opts) } } /** * TODO * * @name module:js-data.hasOne * @method * @param {Mapper} related The relation of which the target has one. * @param {Object} opts Configuration options. * @param {string} [opts.foreignKey] The field that holds the primary key of the * related record. * @param {string} opts.localField The field that holds a reference to the * related record object. * @returns {Function} Invocation function, which accepts the target as the only * parameter. */ export const hasOne = function (related, opts) { opts || (opts = {}) opts.type = hasOneType return function (target) { relatedTo(target, related, opts) } } × Search results Close api.js-data.io • js-data.io "},"Query.js.html":{"id":"Query.js.html","title":"Source: Query.js","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentContainerDataStoreLinkedCollectionMapperQueryRecordSchema Source: Query.js import utils from './utils' import Component from './Component' const DOMAIN = 'Query' const INDEX_ERR = 'Index inaccessible after first operation' // Reserved words used by JSData's Query Syntax const reserved = { limit: '', offset: '', orderBy: '', skip: '', sort: '', where: '' } // Used by our JavaScript implementation of the LIKE operator const escapeRegExp = /([.*+?^=!:${}()|[\\]\\/\\\\])/g const percentRegExp = /%/g const underscoreRegExp = /_/g const escape = function (pattern) { return pattern.replace(escapeRegExp, '\\\\$1') } /** * A class used by the {@link Collection} class to build queries to be executed * against the collection's data. An instance of `Query` is returned by * {@link Collection#query}. Query instances are typically short-lived, and you * shouldn't have to create them yourself. Just use {@link Collection#query}. * * ```javascript * import {Query} from 'js-data' * ``` * * @example * const posts = store.query('post').filter({ status: 'draft' }).limit(2).run() * * @class Query * @extends Component * @param {Collection} collection The collection on which this query operates. * @since 3.0.0 */ export default Component.extend({ constructor: function Query (collection) { const self = this utils.classCallCheck(self, Query) /** * The {@link Collection} on which this query operates. * * @name Query#collection * @since 3.0.0 * @type {Collection} */ self.collection = collection /** * The current data result of this query. * * @name Query#data * @since 3.0.0 * @type {Array} */ self.data = null }, /** * Find all entities between two boundaries. * * @example &lt;caption&gt;Get the users ages 18 to 30.&lt;/caption&gt; * const users = query.between(18, 30, { index: 'age' }).run() * * @example &lt;caption&gt;Same as above.&lt;/caption&gt; * const users = query.between([18], [30], { index: 'age' }).run() * * @method Query#between * @param {Array} leftKeys Keys defining the left boundary. * @param {Array} rightKeys Keys defining the right boundary. * @param {Object} [opts] Configuration options. * @param {string} [opts.index] Name of the secondary index to use in the * query. If no index is specified, the main index is used. * @param {boolean} [opts.leftInclusive=true] Whether to include entities * on the left boundary. * @param {boolean} [opts.rightInclusive=false] Whether to include entities * on the left boundary. * @param {boolean} [opts.limit] Limit the result to a certain number. * @param {boolean} [opts.offset] The number of resulting entities to skip. * @returns {Query} A reference to itself for chaining. * @since 3.0.0 */ between (leftKeys, rightKeys, opts) { const self = this opts || (opts = {}) if (self.data) { throw utils.err(`${DOMAIN}#between`)(500, 'Cannot access index') } self.data = self.collection.getIndex(opts.index).between(leftKeys, rightKeys, opts) return self }, /** * The comparison function used by the {@link Query} class. * * @method Query#compare * @param {Array} orderBy An orderBy clause used for sorting and sub-sorting. * @param {number} index The index of the current orderBy clause being used. * @param {*} a The first item in the comparison. * @param {*} b The second item in the comparison. * @returns {number} -1 if `b` should preceed `a`. 0 if `a` and `b` are equal. * 1 if `a` should preceed `b`. * @since 3.0.0 */ compare (orderBy, index, a, b) { const def = orderBy[index] let cA = utils.get(a, def[0]) let cB = utils.get(b, def[0]) if (cA &amp;&amp; utils.isString(cA)) { cA = cA.toUpperCase() } if (cB &amp;&amp; utils.isString(cB)) { cB = cB.toUpperCase() } if (a === undefined) { a = null } if (b === undefined) { b = null } if (def[1].toUpperCase() === 'DESC') { const temp = cB cB = cA cA = temp } if (cA &lt; cB) { return -1 } else if (cA &gt; cB) { return 1 } else { if (index &lt; orderBy.length - 1) { return this.compare(orderBy, index + 1, a, b) } else { return 0 } } }, /** * Predicate evaluation function used by the {@link Query} class. * * @method Query#evaluate * @param {*} value The value to evaluate. * @param {string} op The operator to use in this evaluation. * @param {*} predicate The predicate to use in this evaluation. * @returns {boolean} Whether the value passed the evaluation or not. * @since 3.0.0 */ evaluate (value, op, predicate) { const ops = this.constructor.ops if (ops[op]) { return ops[op](value, predicate) } if (op.indexOf('like') === 0) { return !utils.isNull(this.like(predicate, op.substr(4)).exec(value)) } else if (op.indexOf('notLike') === 0) { return utils.isNull(this.like(predicate, op.substr(7)).exec(value)) } }, /** * Find the record or records that match the provided query or are accepted by * the provided filter function. * * @example &lt;caption&gt;Get the draft posts created less than three months&lt;/caption&gt; * const posts = query.filter({ * where: { * status: { * '==': 'draft' * }, * created_at_timestamp: { * '&gt;=': (new Date().getTime() (1000 * 60 * 60 * 24 * 30 * 3)) // 3 months ago * } * } * }).run() * * @example &lt;caption&gt;Use a custom filter function&lt;/caption&gt; * const posts = query.filter(function (post) { * return post.isReady() * }).run() * * @method Query#filter * @param {(Object|Function)} [queryOrFn={}] Selection query or filter * function. * @param {Function} [thisArg] Context to which to bind `queryOrFn` if * `queryOrFn` is a function. * @returns {Query} A reference to itself for chaining. * @since 3.0.0 */ filter (query, thisArg) { const self = this /** * Selection query as defined by JSData's [Query Syntax][querysyntax]. * * [querysyntax]: http://www.js-data.io/v3.0/docs/query-syntax * * @example &lt;caption&gt;Empty &quot;findAll&quot; query&lt;/caption&gt; * store.findAll('post').then((posts) =&gt; { * console.log(posts) // [...] * }) * * @example &lt;caption&gt;Empty &quot;filter&quot; query&lt;/caption&gt; * const posts = store.filter('post') * console.log(posts) // [...] * * @example &lt;caption&gt;Complex &quot;findAll&quot; query&lt;/caption&gt; * const PAGE_SIZE = 10 * let currentPage = 3 * * // Retrieve a filtered page of blog posts * store.findAll('post', { * where: { * status: { * // WHERE status = 'published' * '==': 'published' * }, * author: { * // AND author IN ('bob', 'alice') * 'in': ['bob', 'alice'], * // OR author IN ('karen') * '|in': ['karen'] * } * }, * orderBy: [ * // ORDER BY date_published DESC, * ['date_published', 'DESC'], * // ORDER BY title ASC * ['title', 'ASC'] * ], * // LIMIT 10 * limit: PAGE_SIZE, * // SKIP 20 * offset: PAGE_SIZE * (currentPage 1) * }).then((posts) =&gt; { * console.log(posts) // [...] * }) * * @namespace query * @property {number} [limit] See {@link query.limit}. * @property {number} [offset] See {@link query.offset}. * @property {string|Array[]} [orderBy] See {@link query.orderBy}. * @property {number} [skip] Alias for {@link query.offset}. * @property {string|Array[]} [sort] Alias for {@link query.orderBy}. * @property {Object} [where] See {@link query.where}. * @since 3.0.0 * @tutorial [&quot;http://www.js-data.io/v3.0/docs/query-syntax&quot;,&quot;JSData's Query Syntax&quot;] */ query || (query = {}) self.getData() if (utils.isObject(query)) { let where = {} /** * Filtering criteria. Records that do not meet this criteria will be exluded * from the result. * * @example * TODO * * @name query.where * @type {Object} * @see http://www.js-data.io/v3.0/docs/query-syntax * @since 3.0.0 */ if (utils.isObject(query.where)) { where = query.where } utils.forOwn(query, function (value, key) { if (!(key in reserved) &amp;&amp; !(key in where)) { where[key] = { '==': value } } }) const fields = [] const ops = [] const predicates = [] utils.forOwn(where, function (clause, field) { if (!utils.isObject(clause)) { clause = { '==': clause } } utils.forOwn(clause, function (expr, op) { fields.push(field) ops.push(op) predicates.push(expr) }) }) if (fields.length) { let i let len = fields.length self.data = self.data.filter(function (item) { let first = true let keep = true for (i = 0; i &lt; len; i++) { let op = ops[i] const isOr = op.charAt(0) === '|' op = isOr ? op.substr(1) : op const expr = self.evaluate(utils.get(item, fields[i]), op, predicates[i]) if (expr !== undefined) { keep = first ? expr : (isOr ? keep || expr : keep &amp;&amp; expr) } first = false } return keep }) } // Sort let orderBy = query.orderBy || query.sort if (utils.isString(orderBy)) { orderBy = [ [orderBy, 'ASC'] ] } if (!utils.isArray(orderBy)) { orderBy = null } /** * Determines how records should be ordered in the result. * * @example * TODO * * @name query.orderBy * @type {string|Array[]} * @see http://www.js-data.io/v3.0/docs/query-syntax * @since 3.0.0 */ if (orderBy) { let index = 0 orderBy.forEach(function (def, i) { if (utils.isString(def)) { orderBy[i] = [def, 'ASC'] } }) self.data.sort(function (a, b) { return self.compare(orderBy, index, a, b) }) } /** * Number of records to skip. * * @example &lt;caption&gt;Retrieve the first &quot;page&quot; of blog posts&lt;/caption&gt; * const PAGE_SIZE = 10 * let currentPage = 1 * PostService.findAll({ * offset: PAGE_SIZE * (currentPage 1) * limit: PAGE_SIZE * }) * * @name query.offset * @type {number} * @see http://www.js-data.io/v3.0/docs/query-syntax * @since 3.0.0 */ if (utils.isNumber(query.skip)) { self.skip(query.skip) } else if (utils.isNumber(query.offset)) { self.skip(query.offset) } /** * Maximum number of records to retrieve. * * @example &lt;caption&gt;Retrieve the first &quot;page&quot; of blog posts&lt;/caption&gt; * const PAGE_SIZE = 10 * let currentPage = 1 * PostService.findAll({ * offset: PAGE_SIZE * (currentPage 1) * limit: PAGE_SIZE * }) * * @name query.limit * @type {number} * @see http://www.js-data.io/v3.0/docs/query-syntax * @since 3.0.0 */ if (utils.isNumber(query.limit)) { self.limit(query.limit) } } else if (utils.isFunction(query)) { self.data = self.data.filter(query, thisArg) } return self }, /** * Iterate over all entities. * * @method Query#forEach * @param {Function} forEachFn Iteration function. * @param {*} [thisArg] Context to which to bind `forEachFn`. * @returns {Query} A reference to itself for chaining. * @since 3.0.0 */ forEach (forEachFn, thisArg) { this.getData().forEach(forEachFn, thisArg) return this }, /** * Find the entity or entities that match the provided key. * * @example &lt;caption&gt;Get the entity whose primary key is 25.&lt;/caption&gt; * const entities = query.get(25).run() * * @example &lt;caption&gt;Same as above.&lt;/caption&gt; * const entities = query.get([25]).run() * * @example &lt;caption&gt;Get all users who are active and have the &quot;admin&quot; role.&lt;/caption&gt; * const activeAdmins = query.get(['active', 'admin'], { * index: 'activityAndRoles' * }).run() * * @example &lt;caption&gt;Get all entities that match a certain weather condition.&lt;/caption&gt; * const niceDays = query.get(['sunny', 'humid', 'calm'], { * index: 'weatherConditions' * }).run() * * @method Query#get * @param {Array} keyList Key(s) defining the entity to retrieve. If * `keyList` is not an array (i.e. for a single-value key), it will be * wrapped in an array. * @param {Object} [opts] Configuration options. * @param {string} [opts.string] Name of the secondary index to use in the * query. If no index is specified, the main index is used. * @returns {Query} A reference to itself for chaining. * @since 3.0.0 */ get (keyList, opts) { const self = this keyList || (keyList = []) opts || (opts = {}) if (self.data) { throw utils.err(`${DOMAIN}#get`)(500, INDEX_ERR) } if (keyList &amp;&amp; !utils.isArray(keyList)) { keyList = [keyList] } if (!keyList.length) { self.getData() return self } self.data = self.collection.getIndex(opts.index).get(keyList) return self }, /** * Find the entity or entities that match the provided keyLists. * * @example &lt;caption&gt;Get the posts where &quot;status&quot; is &quot;draft&quot; or &quot;inReview&quot;.&lt;/caption&gt; * const posts = query.getAll('draft', 'inReview', { index: 'status' }).run() * * @example &lt;caption&gt;Same as above.&lt;/caption&gt; * const posts = query.getAll(['draft'], ['inReview'], { index: 'status' }).run() * * @method Query#getAll * @param {...Array} [keyList] Provide one or more keyLists, and all * entities matching each keyList will be retrieved. If no keyLists are * provided, all entities will be returned. * @param {Object} [opts] Configuration options. * @param {string} [opts.index] Name of the secondary index to use in the * query. If no index is specified, the main index is used. * @returns {Query} A reference to itself for chaining. * @since 3.0.0 */ getAll (...args) { const self = this let opts = {} if (self.data) { throw utils.err(`${DOMAIN}#getAll`)(500, INDEX_ERR) } if (!args.length || args.length === 1 &amp;&amp; utils.isObject(args[0])) { self.getData() return self } else if (args.length &amp;&amp; utils.isObject(args[args.length - 1])) { opts = args[args.length - 1] args.pop() } const collection = self.collection const index = collection.getIndex(opts.index) self.data = [] args.forEach(function (keyList) { self.data = self.data.concat(index.get(keyList)) }) return self }, /** * Return the current data result of this query. * * @method Query#getData * @returns {Array} The data in this query. * @since 3.0.0 */ getData () { const self = this if (!self.data) { self.data = self.collection.index.getAll() } return self.data }, /** * Implementation used by the `like` operator. Takes a pattern and flags and * returns a `RegExp` instance that can test strings. * * @method Query#like * @param {string} pattern Testing pattern. * @param {string} flags Flags for the regular expression. * @returns {RegExp} Regular expression for testing strings. * @since 3.0.0 */ like (pattern, flags) { return new RegExp(`^${(escape(pattern).replace(percentRegExp, '.*').replace(underscoreRegExp, '.'))}$`, flags) }, /** * Limit the result. * * @example &lt;caption&gt;Get only the first 10 draft posts.&lt;/caption&gt; * const posts = query.get('draft', { index: 'status' }).limit(10).run() * * @method Query#limit * @param {number} num The maximum number of entities to keep in the result. * @returns {Query} A reference to itself for chaining. * @since 3.0.0 */ limit (num) { if (!utils.isNumber(num)) { throw utils.err(`${DOMAIN}#limit`, 'num')(400, 'number', num) } const data = this.getData() this.data = data.slice(0, Math.min(data.length, num)) return this }, /** * Apply a mapping function to the result data. * * @example * const ages = UserCollection.query().map((user) =&gt; { * return user.age * }).run() * * @method Query#map * @param {Function} mapFn Mapping function. * @param {*} [thisArg] Context to which to bind `mapFn`. * @returns {Query} A reference to itself for chaining. * @since 3.0.0 */ map (mapFn, thisArg) { this.data = this.getData().map(mapFn, thisArg) return this }, /** * Return the result of calling the specified function on each item in this * collection's main index. * * @example * const stringAges = UserCollection.query().mapCall('toString').run() * * @method Query#mapCall * @param {string} funcName Name of function to call * @parama {...*} [args] Remaining arguments to be passed to the function. * @returns {Query} A reference to itself for chaining. * @since 3.0.0 */ mapCall (funcName, ...args) { this.data = this.getData().map(function (item) { return item[funcName](...args) }) return this }, /** * Complete the execution of the query and return the resulting data. * * @method Query#run * @returns {Array} The result of executing this query. * @since 3.0.0 */ run () { const data = this.data this.data = null return data }, /** * Skip a number of results. * * @example &lt;caption&gt;Get all but the first 10 draft posts.&lt;/caption&gt; * const posts = query.get('draft', { index: 'status' }).skip(10).run() * * @method Query#skip * @param {number} num The number of entities to skip. * @returns {Query} A reference to itself for chaining. * @since 3.0.0 */ skip (num) { if (!utils.isNumber(num)) { throw utils.err(`${DOMAIN}#skip`, 'num')(400, 'number', num) } const data = this.getData() if (num &lt; data.length) { this.data = data.slice(num) } else { this.data = [] } return this } }, { /** * The filtering operators supported by {@link Query#filter}, and which are * implemented by adapters (for the most part). * * @example &lt;caption&gt;Variant 1&lt;/caption&gt; * const publishedPosts = store.filter('post', { * status: 'published', * limit: 2 * }) * * @example &lt;caption&gt;Variant 2&lt;/caption&gt; * const publishedPosts = store.filter('post', { * where: { * status: { * '==': 'published' * } * }, * limit: 2 * }) * * @example &lt;caption&gt;Variant 3&lt;/caption&gt; * const publishedPosts = store.query('post').filter({ * status: 'published' * }).limit(2).run() * * @example &lt;caption&gt;Variant 4&lt;/caption&gt; * const publishedPosts = store.query('post').filter({ * where: { * status: { * '==': 'published' * } * } * }).limit(2).run() * * @example &lt;caption&gt;Multiple operators&lt;/caption&gt; * const myPublishedPosts = store.filter('post', { * where: { * status: { * '==': 'published' * }, * user_id: { * '==': currentUser.id * } * } * }) * * @name Query.ops * @property {Function} == Equality operator. * @property {Function} != Inequality operator. * @property {Function} &gt; Greater than operator. * @property {Function} &gt;= Greater than (inclusive) operator. * @property {Function} &lt; Less than operator. * @property {Function} &lt;= Less than (inclusive) operator. * @property {Function} isectEmpty Operator that asserts that the intersection * between two arrays is empty. * @property {Function} isectNotEmpty Operator that asserts that the * intersection between two arrays is __not__ empty. * @property {Function} in Operator that asserts whether a value is in an * array. * @property {Function} notIn Operator that asserts whether a value is __not__ * in an array. * @property {Function} contains Operator that asserts whether an array * contains a value. * @property {Function} notContains Operator that asserts whether an array * does __not__ contain a value. * @since 3.0.0 * @type {Object} */ ops: { '==': function (value, predicate) { return value == predicate // eslint-disable-line }, '===': function (value, predicate) { return value === predicate }, '!=': function (value, predicate) { return value != predicate // eslint-disable-line }, '!==': function (value, predicate) { return value !== predicate }, '&gt;': function (value, predicate) { return value &gt; predicate }, '&gt;=': function (value, predicate) { return value &gt;= predicate }, '&lt;': function (value, predicate) { return value &lt; predicate }, '&lt;=': function (value, predicate) { return value &lt;= predicate }, 'isectEmpty': function (value, predicate) { return !utils.intersection((value || []), (predicate || [])).length }, 'isectNotEmpty': function (value, predicate) { return utils.intersection((value || []), (predicate || [])).length }, 'in': function (value, predicate) { return predicate.indexOf(value) !== -1 }, 'notIn': function (value, predicate) { return predicate.indexOf(value) === -1 }, 'contains': function (value, predicate) { return (value || []).indexOf(predicate) !== -1 }, 'notContains': function (value, predicate) { return (value || []).indexOf(predicate) === -1 } } }) /** * Create a subclass of this Query. * * @example &lt;caption&gt;Extend the class in a cross-browser manner.&lt;/caption&gt; * import {Query} from 'js-data' * const CustomQueryClass = Query.extend({ * foo () { return 'bar' } * }) * const customQuery = new CustomQueryClass({ name: 'test' }) * console.log(customQuery.foo()) // &quot;bar&quot; * * @example &lt;caption&gt;Extend the class using ES2015 class syntax.&lt;/caption&gt; * class CustomQueryClass extends Query { * foo () { return 'bar' } * } * const customQuery = new CustomQueryClass({ name: 'test' }) * console.log(customQuery.foo()) // &quot;bar&quot; * * @method Query.extend * @param {Object} [props={}] Properties to add to the prototype of the * subclass. * @param {Object} [classProps={}] Static properties to add to the subclass. * @returns {Constructor} Subclass of this Query. * @since 3.0.0 */ × Search results Close api.js-data.io • js-data.io "},"Record.js.html":{"id":"Record.js.html","title":"Source: Record.js","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentContainerDataStoreLinkedCollectionMapperQueryRecordSchema Source: Record.js import utils from './utils' import Component from './Component' const DOMAIN = 'Record' const superMethod = function (mapper, name) { const store = mapper.datastore if (store &amp;&amp; store[name]) { return function (...args) { return store[name](mapper.name, ...args) } } return mapper[name].bind(mapper) } /** * js-data's Record class. * * ```javascript * import {Record} from 'js-data' * ``` * * @class Record * @extends Component * @param {Object} [props] The initial properties of the new Record instance. * @param {Object} [opts] Configuration options. * @param {boolean} [opts.noValidate=false] Whether to skip validation on the * initial properties. */ const Record = Component.extend({ constructor: function Record (props, opts) { const self = this utils.classCallCheck(self, Record) props || (props = {}) opts || (opts = {}) const _props = {} Object.defineProperties(self, { _get: { value (key) { return utils.get(_props, key) } }, _set: { value (key, value) { return utils.set(_props, key, value) } }, _unset: { value (key) { return utils.unset(_props, key) } } }) const _set = self._set // TODO: Optimize these strings _set('creating', true) if (opts.noValidate) { _set('noValidate', true) } utils.fillIn(self, props) _set('creating', false) _set('noValidate', false) _set('previous', utils.copy(props)) }, /** * TODO * * @name Record#_mapper * @method * @ignore */ _mapper () { const self = this const mapper = self.constructor.mapper if (!mapper) { throw utils.err(`${DOMAIN}#_mapper`, '')(404, 'mapper') } return mapper }, /** * TODO * * @name Record#afterLoadRelations * @method * @param {string[]} relations TODO * @param {Object} opts TODO */ afterLoadRelations () {}, /** * TODO * * @name Record#beforeLoadRelations * @method * @param {string[]} relations TODO * @param {Object} opts TODO */ beforeLoadRelations () {}, /** * Return changes to this record since it was instantiated or * {@link Record#commit} was called. * * @name Record#changes * @method * @param [opts] Configuration options. * @param {Function} [opts.equalsFn] Equality function. Default uses `===`. * @param {Array} [opts.ignore] Array of strings or RegExp of fields to ignore. */ changes (opts) { const self = this opts || (opts = {}) return utils.diffObjects(self, self._get('previous'), opts) }, /** * TODO * * @name Record#commit * @method */ commit () { const self = this self._set('changed') // unset self._set('previous', utils.copy(self)) return self }, /** * Call {@link Mapper#destroy} using this record's primary key. * * @name Record#destroy * @method * @param {Object} [opts] Configuration options passed to {@link Mapper#destroy}. * @returns {Promise} The result of calling {@link Mapper#destroy}. */ destroy (opts) { const self = this opts || (opts = {}) const mapper = self._mapper() return superMethod(mapper, 'destroy')(utils.get(self, mapper.idAttribute), opts) }, /** * Return the value at the given path for this instance. * * @name Record#get * @method * @param {string} key - Path of value to retrieve. * @returns {*} Value at path. */ 'get' (key) { return utils.get(this, key) }, /** * Return whether this record has changed since it was instantiated or * {@link Record#commit} was called. * * @name Record#hasChanges * @method * @param [opts] Configuration options. * @param {Function} [opts.equalsFn] Equality function. Default uses `===`. * @param {Array} [opts.ignore] Array of strings or RegExp of fields to ignore. */ hasChanges (opts) { const self = this const quickHasChanges = !!(self._get('changed') || []).length return quickHasChanges || utils.areDifferent(self, self._get('previous'), opts) }, /** * TODO * * @name Record#hashCode * @method */ hashCode () { const self = this return utils.get(self, self._mapper().idAttribute) }, isValid (opts) { const self = this return !self._mapper().validate(self, opts) }, /** * TODO * * @name Record#loadRelations * @method * @param {string[]} [relations] TODO * @param {Object} [opts] TODO */ loadRelations (relations, opts) { let op const self = this const mapper = self._mapper() // Default values for arguments relations || (relations = []) if (utils.isString(relations)) { relations = [relations] } opts || (opts = {}) opts.with = relations // Fill in &quot;opts&quot; with the Model's configuration utils._(opts, mapper) opts.adapter = mapper.getAdapterName(opts) // beforeLoadRelations lifecycle hook op = opts.op = 'beforeLoadRelations' return utils.resolve(self[op](relations, opts)).then(function () { // Now delegate to the adapter op = opts.op = 'loadRelations' mapper.dbg(op, self, relations, opts) let tasks = [] let task utils.forEachRelation(mapper, opts, function (def, optsCopy) { const relatedMapper = def.getRelation() optsCopy.raw = false if (utils.isFunction(def.load)) { task = def.load(mapper, def, self, opts) } else if (def.type === 'hasMany' || def.type === 'hasOne') { if (def.foreignKey) { task = superMethod(relatedMapper, 'findAll')({ [def.foreignKey]: utils.get(self, mapper.idAttribute) }, optsCopy).then(function (relatedData) { if (def.type === 'hasOne') { return relatedData.length ? relatedData[0] : undefined } return relatedData }) } else if (def.localKeys) { task = superMethod(relatedMapper, 'findAll')({ where: { [relatedMapper.idAttribute]: { 'in': utils.get(self, def.localKeys) } } }) } else if (def.foreignKeys) { task = superMethod(relatedMapper, 'findAll')({ where: { [def.foreignKeys]: { 'contains': utils.get(self, mapper.idAttribute) } } }, opts) } } else if (def.type === 'belongsTo') { const key = utils.get(self, def.foreignKey) if (utils.isSorN(key)) { task = superMethod(relatedMapper, 'find')(key, optsCopy) } } if (task) { task = task.then(function (relatedData) { def.setLocalField(self, relatedData) }) tasks.push(task) } }) return Promise.all(tasks) }).then(function () { // afterLoadRelations lifecycle hook op = opts.op = 'afterLoadRelations' return utils.resolve(self[op](relations, opts)).then(function () { return self }) }) }, /** * TODO * * @name Record#previous * @method * @param {string} [key] TODO */ previous (key) { const self = this if (key) { return self._get(`previous.${key}`) } return self._get('previous') }, /** * TODO * * @name Record#revert * @method * @param {Object} [opts] Configuration options. */ revert (opts) { const self = this const previous = self._get('previous') opts || (opts = {}) opts.preserve || (opts.preserve = []) utils.forOwn(self, (value, key) =&gt; { if (key !== self._mapper().idAttribute &amp;&amp; !previous.hasOwnProperty(key) &amp;&amp; self.hasOwnProperty(key) &amp;&amp; opts.preserve.indexOf(key) === -1) { delete self[key] } }) utils.forOwn(previous, (value, key) =&gt; { if (opts.preserve.indexOf(key) === -1) { self[key] = value } }) self.commit() return self }, /** * Delegates to {@link Mapper#create} or {@link Mapper#update}. * * @name Record#save * @method * @param {Object} [opts] Configuration options. See {@link Mapper#create}. * @param [opts] Configuration options. * @param {boolean} [opts.changesOnly] Equality function. Default uses `===`. * @param {Function} [opts.equalsFn] Passed to {@link Record#changes} when * `changesOnly` is `true`. * @param {Array} [opts.ignore] Passed to {@link Record#changes} when * `changesOnly` is `true`. * @returns {Promise} The result of calling {@link Mapper#create} or * {@link Mapper#update}. */ save (opts) { const self = this opts || (opts = {}) const mapper = self._mapper() const id = utils.get(self, mapper.idAttribute) let props = self if (utils.isUndefined(id)) { return superMethod(mapper, 'create')(props, opts) } if (opts.changesOnly) { const changes = self.changes(opts) props = {} utils.fillIn(props, changes.added) utils.fillIn(props, changes.changed) } return superMethod(mapper, 'update')(id, props, opts) }, /** * Set the value for a given key, or the values for the given keys if &quot;key&quot; is * an object. * * @name Record#set * @method * @param {(string|Object)} key - Key to set or hash of key-value pairs to set. * @param {*} [value] - Value to set for the given key. * @param {Object} [opts] - Optional configuration. * @param {boolean} [opts.silent=false] - Whether to trigger change events. */ 'set' (key, value, opts) { const self = this if (utils.isObject(key)) { opts = value } opts || (opts = {}) if (opts.silent) { self._set('silent', true) } utils.set(self, key, value) if (!self._get('eventId')) { self._set('silent') // unset } }, // TODO: move logic for single-item async operations onto the instance. /** * Return a plain object representation of this record. If the class from * which this record was created has a mapper, then {@link Mapper#toJSON} will * be called instead. * * @name Record#toJSON * @method * @param {Object} [opts] Configuration options. * @param {string[]} [opts.with] Array of relation names or relation fields * to include in the representation. Only available as an option if the class * from which this record was created has a mapper. * @returns {Object} Plain object representation of this record. */ toJSON (opts) { const mapper = this.constructor.mapper if (mapper) { return mapper.toJSON(this, opts) } else { const json = {} utils.forOwn(this, function (prop, key) { json[key] = utils.copy(prop) }) return json } }, /** * Unset the value for a given key. * * @name Record#unset * @method * @param {string} key - Key to unset. * @param {Object} [opts] - Optional configuration. * @param {boolean} [opts.silent=false] - Whether to trigger change events. */ unset (key, opts) { this.set(key, undefined, opts) }, validate (opts) { return this._mapper().validate(this, opts) } }) /** * Allow records to emit events. * * An record's registered listeners are stored in the record's private data. */ utils.eventify( Record.prototype, function () { return this._get('events') }, function (value) { this._set('events', value) } ) export default Record × Search results Close api.js-data.io • js-data.io "},"Schema.js.html":{"id":"Schema.js.html","title":"Source: Schema.js","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentContainerDataStoreLinkedCollectionMapperQueryRecordSchema Source: Schema.js import utils from './utils' import Component from './Component' const DOMAIN = 'Schema' /** * TODO * * @name Schema.types * @type {Object} */ const types = { array: utils.isArray, boolean: utils.isBoolean, integer: utils.isInteger, 'null': utils.isNull, number: utils.isNumber, object: utils.isObject, string: utils.isString } /** * @ignore */ const segmentToString = function (segment, prev) { let str = '' if (segment) { if (utils.isNumber(segment)) { str += `[${segment}]` } else if (prev) { str += `.${segment}` } else { str += `${segment}` } } return str } /** * @ignore */ const makePath = function (opts) { opts || (opts = {}) let path = '' const segments = opts.path || [] segments.forEach(function (segment) { path += segmentToString(segment, path) }) path += segmentToString(opts.prop, path) return path } /** * @ignore */ const makeError = function (actual, expected, opts) { return { expected, actual: '' + actual, path: makePath(opts) } } /** * @ignore */ const addError = function (actual, expected, opts, errors) { errors.push(makeError(actual, expected, opts)) } /** * @ignore */ const maxLengthCommon = function (keyword, value, schema, opts) { const max = schema[keyword] if (value.length &gt; max) { return makeError(value.length, `length no more than ${max}`, opts) } } /** * @ignore */ const minLengthCommon = function (keyword, value, schema, opts) { const min = schema[keyword] if (value.length &lt; min) { return makeError(value.length, `length no less than ${min}`, opts) } } /** * TODO * * @name Schema.validationKeywords * @type {Object} */ const validationKeywords = { /** * http://json-schema.org/latest/json-schema-validation.html#anchor82 * * @name Schema.validationKeywords.allOf * @method * @param {*} value TODO * @param {Object} schema TODO * @param {Object} opts TODO */ allOf (value, schema, opts) { let allErrors = [] schema.allOf.forEach(function (_schema) { allErrors = allErrors.concat(validate(value, _schema, opts) || []) }) return allErrors.length ? undefined : allErrors }, /** * http://json-schema.org/latest/json-schema-validation.html#anchor85 * * @name Schema.validationKeywords.anyOf * @method * @param {*} value TODO * @param {Object} schema TODO * @param {Object} opts TODO */ anyOf (value, schema, opts) { let validated = false let allErrors = [] schema.anyOf.forEach(function (_schema) { const errors = validate(value, _schema, opts) if (errors) { allErrors = allErrors.concat(errors) } else { validated = true } }) return validated ? undefined : allErrors }, /** * http://json-schema.org/latest/json-schema-validation.html#anchor70 * * @name Schema.validationKeywords.dependencies * @method * @param {*} value TODO * @param {Object} schema TODO * @param {Object} opts TODO */ dependencies (value, schema, opts) { // TODO }, /** * http://json-schema.org/latest/json-schema-validation.html#anchor76 * * @name Schema.validationKeywords.enum * @method * @param {*} value TODO * @param {Object} schema TODO * @param {Object} opts TODO */ enum (value, schema, opts) { const possibleValues = schema['enum'] if (possibleValues.indexOf(value) === -1) { return makeError(value, `one of (${possibleValues.join(', ')})`, opts) } }, /** * http://json-schema.org/latest/json-schema-validation.html#anchor37 * * @name Schema.validationKeywords.items * @method * @param {*} value TODO * @param {Object} schema TODO * @param {Object} opts TODO */ items (value, schema, opts) { opts || (opts = {}) // TODO: additionalItems let items = schema.items let errors = [] const checkingTuple = utils.isArray(items) const length = value.length for (var prop = 0; prop &lt; length; prop++) { if (checkingTuple) { // Validating a tuple, instead of just checking each item against the // same schema items = schema.items[prop] } opts.prop = prop errors = errors.concat(validate(value[prop], items, opts) || []) } return errors.length ? errors : undefined }, /** * http://json-schema.org/latest/json-schema-validation.html#anchor17 * * @name Schema.validationKeywords.maximum * @method * @param {*} value TODO * @param {Object} schema TODO * @param {Object} opts TODO */ maximum (value, schema, opts) { // Must be a number const maximum = schema.maximum // Must be a boolean // Depends on maximum // default: false const exclusiveMaximum = schema.exclusiveMaximum if (typeof value === typeof maximum &amp;&amp; (exclusiveMaximum ? maximum &lt; value : maximum &lt;= value)) { // TODO: Account for value of exclusiveMaximum in messaging return makeError(value, `no more than ${maximum}`, opts) } }, /** * http://json-schema.org/latest/json-schema-validation.html#anchor42 * * @name Schema.validationKeywords.maxItems * @method * @param {*} value TODO * @param {Object} schema TODO * @param {Object} opts TODO */ maxItems (value, schema, opts) { return maxLengthCommon('maxItems', value, schema, opts) }, /** * http://json-schema.org/latest/json-schema-validation.html#anchor26 * * @name Schema.validationKeywords.maxLength * @method * @param {*} value TODO * @param {Object} schema TODO * @param {Object} opts TODO */ maxLength (value, schema, opts) { return maxLengthCommon('maxLength', value, schema, opts) }, /** * http://json-schema.org/latest/json-schema-validation.html#anchor54 * * @name Schema.validationKeywords.maxProperties * @method * @param {*} value TODO * @param {Object} schema TODO * @param {Object} opts TODO */ maxProperties (value, schema, opts) { const maxProperties = schema.maxProperties const length = Object.keys(value).length if (length &gt; maxProperties) { return makeError(length, `no more than ${maxProperties} properties`, opts) } }, /** * http://json-schema.org/latest/json-schema-validation.html#anchor21 * * @name Schema.validationKeywords.minimum * @method * @param {*} value TODO * @param {Object} schema TODO * @param {Object} opts TODO */ minimum (value, schema, opts) { // Must be a number const minimum = schema.minimum // Must be a boolean // Depends on minimum // default: false const exclusiveMinimum = schema.exclusiveMinimum if (typeof value === typeof minimum &amp;&amp; (exclusiveMinimum ? minimum &gt; value : minimum &gt;= value)) { // TODO: Account for value of exclusiveMinimum in messaging return makeError(value, `no less than ${minimum}`, opts) } }, /** * http://json-schema.org/latest/json-schema-validation.html#anchor42 * * @name Schema.validationKeywords.minItems * @method * @param {*} value TODO * @param {Object} schema TODO * @param {Object} opts TODO */ minItems (value, schema, opts) { return minLengthCommon('minItems', value, schema, opts) }, /** * http://json-schema.org/latest/json-schema-validation.html#anchor29 * * @name Schema.validationKeywords.minLength * @method * @param {*} value TODO * @param {Object} schema TODO * @param {Object} opts TODO */ minLength (value, schema, opts) { return minLengthCommon('minLength', value, schema, opts) }, /** * http://json-schema.org/latest/json-schema-validation.html#anchor57 * * @name Schema.validationKeywords.minProperties * @method * @param {*} value TODO * @param {Object} schema TODO * @param {Object} opts TODO */ minProperties (value, schema, opts) { const minProperties = schema.minProperties const length = Object.keys(value).length if (length &lt; minProperties) { return makeError(length, `no more than ${minProperties} properties`, opts) } }, /** * http://json-schema.org/latest/json-schema-validation.html#anchor14 * * @name Schema.validationKeywords.multipleOf * @method * @param {*} value TODO * @param {Object} schema TODO * @param {Object} opts TODO */ multipleOf (value, schema, opts) { // TODO }, /** * http://json-schema.org/latest/json-schema-validation.html#anchor91 * * @name Schema.validationKeywords.not * @method * @param {*} value TODO * @param {Object} schema TODO * @param {Object} opts TODO */ not (value, schema, opts) { if (!validate(value, schema.not, opts)) { // TODO: better messaging return makeError('succeeded', 'should have failed', opts) } }, /** * http://json-schema.org/latest/json-schema-validation.html#anchor88 * * @name Schema.validationKeywords.oneOf * @method * @param {*} value TODO * @param {Object} schema TODO * @param {Object} opts TODO */ oneOf (value, schema, opts) { let validated = false let allErrors = [] schema.oneOf.forEach(function (_schema) { const errors = validate(value, _schema, opts) if (errors) { allErrors = allErrors.concat(errors) } else if (validated) { allErrors = [makeError('valid against more than one', 'valid against only one', opts)] validated = false return false } else { validated = true } }) return validated ? undefined : allErrors }, /** * http://json-schema.org/latest/json-schema-validation.html#anchor33 * * @name Schema.validationKeywords.pattern * @method * @param {*} value TODO * @param {Object} schema TODO * @param {Object} opts TODO */ pattern (value, schema, opts) { const pattern = schema.pattern if (utils.isString(value) &amp;&amp; !value.match(pattern)) { return makeError(value, pattern, opts) } }, /** * http://json-schema.org/latest/json-schema-validation.html#anchor64 * * @name Schema.validationKeywords.properties * @method * @param {*} value TODO * @param {Object} schema TODO * @param {Object} opts TODO */ properties (value, schema, opts) { opts || (opts = {}) // Can be a boolean or an object // Technically the default is an &quot;empty schema&quot;, but here &quot;true&quot; is // functionally the same const additionalProperties = utils.isUndefined(schema.additionalProperties) ? true : schema.additionalProperties // &quot;s&quot;: The property set of the instance to validate. const toValidate = {} // &quot;p&quot;: The property set from &quot;properties&quot;. // Default is an object const properties = schema.properties || {} // &quot;pp&quot;: The property set from &quot;patternProperties&quot;. // Default is an object const patternProperties = schema.patternProperties || {} let errors = [] // Collect set &quot;s&quot; utils.forOwn(value, function (_value, prop) { toValidate[prop] = undefined }) // Remove from &quot;s&quot; all elements of &quot;p&quot;, if any. utils.forOwn(properties || {}, function (_schema, prop) { if (utils.isUndefined(value[prop]) &amp;&amp; !utils.isUndefined(_schema['default'])) { value[prop] = utils.copy(_schema['default']) } opts.prop = prop errors = errors.concat(validate(value[prop], _schema, opts) || []) delete toValidate[prop] }) // For each regex in &quot;pp&quot;, remove all elements of &quot;s&quot; which this regex // matches. utils.forOwn(patternProperties, function (_schema, pattern) { utils.forOwn(toValidate, function (undef, prop) { if (prop.match(pattern)) { opts.prop = prop errors = errors.concat(validate(value[prop], _schema, opts) || []) delete toValidate[prop] } }) }) const keys = Object.keys(toValidate) // If &quot;s&quot; is not empty, validation fails if (additionalProperties === false) { if (keys.length) { addError(`extra fields: ${keys.join(', ')}`, 'no extra fields', opts, errors) } } else if (utils.isObject(additionalProperties)) { // Otherwise, validate according to provided schema keys.forEach(function (prop) { opts.prop = prop errors = errors.concat(validate(value[prop], additionalProperties, opts) || []) }) } return errors.length ? errors : undefined }, /** * http://json-schema.org/latest/json-schema-validation.html#anchor61 * * @name Schema.validationKeywords.required * @method * @param {*} value TODO * @param {Object} schema TODO * @param {Object} opts TODO */ required (value, schema, opts) { const required = schema.required let errors = [] if (!opts.existingOnly) { required.forEach(function (prop) { if (utils.isUndefined(utils.get(value, prop))) { const prevProp = opts.prop opts.prop = prop addError(undefined, 'a value', opts, errors) opts.prop = prevProp } }) } return errors.length ? errors : undefined }, /** * http://json-schema.org/latest/json-schema-validation.html#anchor79 * * @name Schema.validationKeywords.type * @method * @param {*} value TODO * @param {Object} schema TODO * @param {Object} opts TODO */ type (value, schema, opts) { let type = schema.type let validType // Can be one of several types if (utils.isString(type)) { type = [type] } // Try to match the value against an expected type type.forEach(function (_type) { // TODO: throw an error if type is not defined if (types[_type](value, schema, opts)) { // Matched a type validType = _type return false } }) // Value did not match any expected type if (!validType) { return makeError(value ? typeof value : '' + value, `one of (${type.join(', ')})`, opts) } // Run keyword validators for matched type // http://json-schema.org/latest/json-schema-validation.html#anchor12 const validator = typeGroupValidators[validType] if (validator) { return validator(value, schema, opts) } }, /** * http://json-schema.org/latest/json-schema-validation.html#anchor49 * * @name Schema.validationKeywords.uniqueItems * @method * @param {*} value TODO * @param {Object} schema TODO * @param {Object} opts TODO */ uniqueItems (value, schema, opts) { if (value &amp;&amp; value.length &amp;&amp; schema.uniqueItems) { const length = value.length let item, i, j // Check n - 1 items for (i = length - 1; i &gt; 0; i--) { item = value[i] // Only compare against unchecked items for (j = i - 1; j &gt;= 0; j--) { // Found a duplicate if (item === value[j]) { return makeError(item, 'no duplicates', opts) } } } } } } /** * @ignore */ const validateKeyword = function (op, value, schema, opts) { return !utils.isUndefined(schema[op]) &amp;&amp; validationKeywords[op](value, schema, opts) } /** * @ignore */ const runOps = function (ops, value, schema, opts) { let errors = [] ops.forEach(function (op) { errors = errors.concat(validateKeyword(op, value, schema, opts) || []) }) return errors.length ? errors : undefined } const ANY_OPS = ['enum', 'type', 'allOf', 'anyOf', 'oneOf', 'not'] const ARRAY_OPS = ['items', 'maxItems', 'minItems', 'uniqueItems'] const NUMERIC_OPS = ['multipleOf', 'maximum', 'minimum'] const OBJECT_OPS = ['maxProperties', 'minProperties', 'required', 'properties', 'dependencies'] const STRING_OPS = ['maxLength', 'minLength', 'pattern'] /** * http://json-schema.org/latest/json-schema-validation.html#anchor75 * @ignore */ const validateAny = function (value, schema, opts) { return runOps(ANY_OPS, value, schema, opts) } /** * TODO * * @name Schema.validate * @method * @param {*} value TODO * @param {Object} [schema] TODO * @param {Object} [opts] Configuration options. */ const validate = function (value, schema, opts) { let errors = [] opts || (opts = {}) let shouldPop let prevProp = opts.prop if (utils.isUndefined(schema)) { return } if (!utils.isObject(schema)) { throw utils.err(`${DOMAIN}#validate`)(500, `Invalid schema at path: &quot;${opts.path}&quot;`) } if (utils.isUndefined(opts.path)) { opts.path = [] } // Track our location as we recurse if (!utils.isUndefined(opts.prop)) { shouldPop = true opts.path.push(opts.prop) opts.prop = undefined } // Validate against parent schema if (schema['extends']) { // opts.path = path // opts.prop = prop if (utils.isFunction(schema['extends'].validate)) { errors = errors.concat(schema['extends'].validate(value, opts) || []) } else { errors = errors.concat(validate(value, schema['extends'], opts) || []) } } if (utils.isUndefined(value)) { // Check if property is required if (schema.required === true) { addError(value, 'a value', opts, errors) } if (shouldPop) { opts.path.pop() opts.prop = prevProp } return errors.length ? errors : undefined } errors = errors.concat(validateAny(value, schema, opts) || []) if (shouldPop) { opts.path.pop() opts.prop = prevProp } return errors.length ? errors : undefined } // These strings are cached for optimal performance of the change detection // boolean - Whether a Record is changing in the current execution frame const changingPath = 'changing' // string[] - Properties that have changed in the current execution frame const changedPath = 'changed' // boolean - Whether a Record is currently being instantiated const creatingPath = 'creating' // number - The setTimeout change event id of a Record, if any const eventIdPath = 'eventId' // boolean - Whether to skip validation for a Record's currently changing property const noValidatePath = 'noValidate' // boolean - Whether to skip change notification for a Record's currently // changing property const silentPath = 'silent' const validationFailureMsg = 'validation failed' /** * Assemble a property descriptor which will be added to the prototype of * {@link Mapper#recordClass}. This method is called when * {@link Mapper#applySchema} is set to `true`. * * TODO: Make this more configurable, i.e. not so tied to the Record class. * * @ignore */ const makeDescriptor = function (prop, schema, opts) { const descriptor = { // These properties are enumerable by default, but regardless of their // enumerability, they won't be &quot;own&quot; properties of individual records enumerable: utils.isUndefined(schema.enumerable) ? true : !!schema.enumerable } // Cache a few strings for optimal performance const keyPath = `props.${prop}` const previousPath = `previous.${prop}` const getter = opts.getter const setter = opts.setter const unsetter = opts.unsetter descriptor.get = function () { return this._get(keyPath) } descriptor.set = function (value) { const self = this // These are accessed a lot const _get = self[getter] const _set = self[setter] const _unset = self[unsetter] // Optionally check that the new value passes validation if (!_get(noValidatePath)) { const errors = schema.validate(value) if (errors) { // Immediately throw an error, preventing the record from getting into // an invalid state const error = new Error(validationFailureMsg) error.errors = errors throw error } } // TODO: Make it so tracking can be turned on for all properties instead of // only per-property if (schema.track &amp;&amp; !_get(creatingPath)) { const previous = _get(previousPath) const current = _get(keyPath) let changing = _get(changingPath) let changed = _get(changedPath) if (!changing) { // Track properties that are changing in the current event loop changed = [] } // Add changing properties to this array once at most const index = changed.indexOf(prop) if (current !== value &amp;&amp; index === -1) { changed.push(prop) } if (previous === value) { if (index &gt;= 0) { changed.splice(index, 1) } } // No changes in current event loop if (!changed.length) { changing = false _unset(changingPath) _unset(changedPath) // Cancel pending change event if (_get(eventIdPath)) { clearTimeout(_get(eventIdPath)) _unset(eventIdPath) } } // Changes detected in current event loop if (!changing &amp;&amp; changed.length) { _set(changedPath, changed) _set(changingPath, true) // Saving the timeout id allows us to batch all changes in the same // event loop into a single &quot;change&quot; // TODO: Optimize _set(eventIdPath, setTimeout(() =&gt; { // Previous event loop where changes were gathered has ended, so // notify any listeners of those changes and prepare for any new // changes _unset(changedPath) _unset(eventIdPath) _unset(changingPath) // TODO: Optimize if (!_get(silentPath)) { let i for (i = 0; i &lt; changed.length; i++) { self.emit('change:' + changed[i], self, utils.get(self, changed[i])) } self.emit('change', self, self.changes()) } _unset(silentPath) }, 0)) } } _set(keyPath, value) return value } return descriptor } /** * TODO * * @name Schema.typeGroupValidators * @type {Object} */ const typeGroupValidators = { /** * TODO * * @name Schema.typeGroupValidators.array * @method * @param {*} value TODO * @param {Object} schema TODO * @param {Object} opts TODO */ array: function (value, schema, opts) { return runOps(ARRAY_OPS, value, schema, opts) }, /** * TODO * * @name Schema.typeGroupValidators.integer * @method * @param {*} value TODO * @param {Object} schema TODO * @param {Object} opts TODO */ integer: function (value, schema, opts) { // Additional validations for numerics are the same return typeGroupValidators.numeric(value, schema, opts) }, /** * TODO * * @name Schema.typeGroupValidators.number * @method * @param {*} value TODO * @param {Object} schema TODO * @param {Object} opts TODO */ number: function (value, schema, opts) { // Additional validations for numerics are the same return typeGroupValidators.numeric(value, schema, opts) }, /** * TODO * * See http://json-schema.org/latest/json-schema-validation.html#anchor13. * * @name Schema.typeGroupValidators.numeric * @method * @param {*} value TODO * @param {Object} schema TODO * @param {Object} opts TODO */ numeric: function (value, schema, opts) { return runOps(NUMERIC_OPS, value, schema, opts) }, /** * TODO * * See http://json-schema.org/latest/json-schema-validation.html#anchor53. * * @name Schema.typeGroupValidators.object * @method * @param {*} value TODO * @param {Object} schema TODO * @param {Object} opts TODO */ object: function (value, schema, opts) { return runOps(OBJECT_OPS, value, schema, opts) }, /** * TODO * * See http://json-schema.org/latest/json-schema-validation.html#anchor25. * * @name Schema.typeGroupValidators.string * @method * @param {*} value TODO * @param {Object} schema TODO * @param {Object} opts TODO */ string: function (value, schema, opts) { return runOps(STRING_OPS, value, schema, opts) } } /** * js-data's Schema class. * * ```javascript * import {Schema} from 'js-data' * ``` * * @class Schema * @extends Component * @param {Object} definition Schema definition according to json-schema.org */ export default Component.extend({ constructor: function Schema (definition) { // const self = this definition || (definition = {}) // TODO: schema validation utils.fillIn(this, definition) // TODO: rework this to make sure all possible keywords are converted if (definition.properties) { utils.forOwn(definition.properties, function (_definition, prop) { if (!(_definition instanceof Schema)) { definition.properties[prop] = new Schema(_definition) } }) } }, /** * This adds ES5 getters/setters to the target based on the &quot;properties&quot; in * this Schema, which makes possible change tracking and validation on * property assignment. * * @name Schema#validate * @method * @param {Object} target The prototype to which to apply this schema. */ apply (target, opts) { opts || (opts = {}) opts.getter = opts.getter || '_get' opts.setter = opts.setter || '_set' opts.unsetter = opts.unsetter || '_unset' const properties = this.properties || {} utils.forOwn(properties, function (schema, prop) { Object.defineProperty( target, prop, makeDescriptor(prop, schema, opts) ) }) }, /** * Validate the provided value against this schema. * * @name Schema#validate * @method * @param {*} value Value to validate. * @param {Object} [opts] Configuration options. * @returns {(array|undefined)} Array of errors or `undefined` if valid. */ validate (value, opts) { return validate(value, this, opts) } }, { typeGroupValidators, types, validate, validationKeywords }) × Search results Close api.js-data.io • js-data.io "},"utils.js.html":{"id":"utils.js.html","title":"Source: utils.js","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentContainerDataStoreLinkedCollectionMapperQueryRecordSchema Source: utils.js /** * Utility methods used by JSData. * * @example * import {utils} from 'js-data' * console.log(utils.isString('foo')) // true * * @namespace utils * @type {Object} */ const DOMAIN = 'utils' const INFINITY = 1 / 0 const MAX_INTEGER = 1.7976931348623157e+308 const BOOL_TAG = '[object Boolean]' const DATE_TAG = '[object Date]' const FUNC_TAG = '[object Function]' const NUMBER_TAG = '[object Number]' const OBJECT_TAG = '[object Object]' const REGEXP_TAG = '[object RegExp]' const STRING_TAG = '[object String]' const objToString = Object.prototype.toString const PATH = /^(.+)\\.(.+)$/ const ERRORS = { '400' () { return `expected: ${arguments[0]}, found: ${arguments[2] ? arguments[1] : typeof arguments[1]}` }, '404' () { return `${arguments[0]} not found` } } const toInteger = function (value) { if (!value) { return 0 } // Coerce to number value = +value if (value === INFINITY || value === -INFINITY) { const sign = (value &lt; 0 ? -1 : 1) return sign * MAX_INTEGER } const remainder = value % 1 return value === value ? (remainder ? value - remainder : value) : 0 // eslint-disable-line } const toStr = function (value) { return objToString.call(value) } const isPlainObject = function (value) { return (!!value &amp;&amp; typeof value === 'object' &amp;&amp; value.constructor === Object) } const mkdirP = function (object, path) { if (!path) { return object } const parts = path.split('.') parts.forEach(function (key) { if (!object[key]) { object[key] = {} } object = object[key] }) return object } const utils = { /** * Reference to the Promise constructor used by JSData. Defaults to * `window.Promise` or `global.Promise`. * * @example &lt;caption&gt;Make JSData use a different `Promise` constructor&lt;/caption&gt; * import Promise from 'bluebird' * import {utils} from 'js-data' * utils.Promise = Promise * * @name utils.Promise * @since 3.0.0 * @type {Function} */ Promise: Promise, /** * Shallow copy properties that meet the following criteria from `src` to * `dest`: * * - own enumerable * - not a function * - does not start with &quot;_&quot; * * @name utils._ * @param {Object} dest Destination object. * @param {Object} src Source object. * @private * @since 3.0.0 */ _ (dest, src) { utils.forOwn(src, function (value, key) { if (key &amp;&amp; utils.isUndefined(dest[key]) &amp;&amp; !utils.isFunction(value) &amp;&amp; key.indexOf('_') !== 0) { dest[key] = value } }) }, /** * TODO * * @name utils._forRelation * @private */ _forRelation (opts, def, fn, ctx) { const relationName = def.relation let containedName = null let index opts || (opts = {}) opts.with || (opts.with = []) if ((index = utils._getIndex(opts.with, relationName)) &gt;= 0) { containedName = relationName } else if ((index = utils._getIndex(opts.with, def.localField)) &gt;= 0) { containedName = def.localField } if (opts.withAll) { fn.call(ctx, def, {}) return } else if (!containedName) { return } let optsCopy = {} utils.fillIn(optsCopy, def.getRelation()) utils.fillIn(optsCopy, opts) optsCopy.with = opts.with.slice() optsCopy._activeWith = optsCopy.with.splice(index, 1)[0] optsCopy.with.forEach(function (relation, i) { if (relation &amp;&amp; relation.indexOf(containedName) === 0 &amp;&amp; relation.length &gt;= containedName.length &amp;&amp; relation[containedName.length] === '.') { optsCopy.with[i] = relation.substr(containedName.length + 1) } else { optsCopy.with[i] = '' } }) fn.call(ctx, def, optsCopy) }, /** * TODO * * @name utils._getIndex * @private */ _getIndex (list, relation) { let index = -1 list.forEach(function (_relation, i) { if (_relation === relation) { index = i return false } else if (utils.isObject(_relation)) { if (_relation.relation === relation) { index = i return false } } }) return index }, /** * Define hidden (non-enumerable), writable properties on `target` from the * provided `props`. * * @name utils.addHiddenPropsToTarget * @param {Object} target That to which `props` should be added. * @param {Object} props Properties to be added to `target`. */ addHiddenPropsToTarget (target, props) { const map = {} utils.forOwn(props, function (value, key) { map[key] = { writable: true, value } }) Object.defineProperties(target, map) }, /** * TODO * * @ignore */ areDifferent (a, b, opts) { opts || (opts = {}) const diff = utils.diffObjects(a, b, opts) const diffCount = Object.keys(diff.added).length + Object.keys(diff.removed).length + Object.keys(diff.changed).length return diffCount &gt; 0 }, /** * TODO * * @ignore */ classCallCheck (instance, ctor) { if (!(instance instanceof ctor)) { throw utils.err(`${ctor.name}`)(500, 'Cannot call a class as a function') } }, /** * Deep copy a value. * * @ignore * @param {*} from Value to deep copy. * @returns {*} Deep copy of `from`. */ copy (from, to, stackFrom, stackTo, blacklist, plain) { if (!to) { to = from if (from) { if (utils.isArray(from)) { to = utils.copy(from, [], stackFrom, stackTo, blacklist, plain) } else if (utils.isDate(from)) { to = new Date(from.getTime()) } else if (utils.isRegExp(from)) { to = new RegExp(from.source, from.toString().match(/[^\\/]*$/)[0]) to.lastIndex = from.lastIndex } else if (utils.isObject(from)) { if (plain) { to = utils.copy(from, {}, stackFrom, stackTo, blacklist, plain) } else { to = utils.copy(from, Object.create(Object.getPrototypeOf(from)), stackFrom, stackTo, blacklist, plain) } } } } else { if (from === to) { throw utils.err(`${DOMAIN}.copy`)(500, 'Cannot copy! Source and destination are identical.') } stackFrom = stackFrom || [] stackTo = stackTo || [] if (utils.isObject(from)) { let index = stackFrom.indexOf(from) if (index !== -1) { return stackTo[index] } stackFrom.push(from) stackTo.push(to) } let result if (utils.isArray(from)) { let i to.length = 0 for (i = 0; i &lt; from.length; i++) { result = utils.copy(from[i], null, stackFrom, stackTo, blacklist, plain) if (utils.isObject(from[i])) { stackFrom.push(from[i]) stackTo.push(result) } to.push(result) } } else { if (utils.isArray(to)) { to.length = 0 } else { utils.forOwn(to, function (value, key) { delete to[key] }) } for (var key in from) { if (from.hasOwnProperty(key)) { if (utils.isBlacklisted(key, blacklist)) { continue } result = utils.copy(from[key], null, stackFrom, stackTo, blacklist, plain) if (utils.isObject(from[key])) { stackFrom.push(from[key]) stackTo.push(result) } to[key] = result } } } } return to }, /** * Recursively shallow fill in own enumberable properties from `source` to `dest`. * * @ignore * @param {Object} dest The destination object. * @param {Object} source The source object. */ deepFillIn (dest, source) { if (source) { utils.forOwn(source, function (value, key) { const existing = dest[key] if (isPlainObject(value) &amp;&amp; isPlainObject(existing)) { utils.deepFillIn(existing, value) } else if (!dest.hasOwnProperty(key) || dest[key] === undefined) { dest[key] = value } }) } return dest }, /** * Recursively shallow copy own enumberable properties from `source` to `dest`. * * @ignore * @param {Object} dest The destination object. * @param {Object} source The source object. */ deepMixIn (dest, source) { if (source) { utils.forOwn(source, function (value, key) { const existing = dest[key] if (isPlainObject(value) &amp;&amp; isPlainObject(existing)) { utils.deepMixIn(existing, value) } else { dest[key] = value } }) } return dest }, /** * @param {Object} a Base object. * @param {Object} b Comparison object. * @returns {Object} Diff. */ diffObjects (a, b, opts) { opts || (opts = {}) let equalsFn = opts.equalsFn let bl = opts.ignore const diff = { added: {}, changed: {}, removed: {} } if (!utils.isFunction(equalsFn)) { equalsFn = utils.strictEqual } utils.forOwn(b, function (oldValue, key) { const newValue = a[key] if (utils.isBlacklisted(key, bl) || equalsFn(newValue, oldValue)) { return } if (utils.isUndefined(newValue)) { diff.removed[key] = undefined } else if (!equalsFn(newValue, oldValue)) { diff.changed[key] = newValue } }) utils.forOwn(a, function (newValue, key) { if (!utils.isUndefined(b[key]) || utils.isBlacklisted(key, bl)) { return } diff.added[key] = newValue }) return diff }, /** * TODO */ equal (a, b) { return a == b // eslint-disable-line }, /** * TODO */ err (domain, target) { return function (code) { const prefix = `[${domain}:${target}] ` let message = ERRORS[code].apply(null, Array.prototype.slice.call(arguments, 1)) message = `${prefix}${message}\\nhttp://www.js-data.io/v3.0/docs/errors#${code}` return new Error(message) } }, /** * Add eventing capabilities into the target object. * * @ignore * @param {Object} target Target object. * @param {Function} [getter] Custom getter for retrieving the object's event * listeners. * @param {Function} [setter] Custom setter for setting the object's event * listeners. */ eventify (target, getter, setter) { target = target || this let _events = {} if (!getter &amp;&amp; !setter) { getter = function () { return _events } setter = function (value) { _events = value } } Object.defineProperties(target, { emit: { value (...args) { const events = getter.call(this) || {} const type = args.shift() let listeners = events[type] || [] let i for (i = 0; i &lt; listeners.length; i++) { listeners[i].f.apply(listeners[i].c, args) } listeners = events.all || [] args.unshift(type) for (i = 0; i &lt; listeners.length; i++) { listeners[i].f.apply(listeners[i].c, args) } } }, off: { value (type, func) { const events = getter.call(this) const listeners = events[type] if (!listeners) { setter.call(this, {}) } else if (func) { for (let i = 0; i &lt; listeners.length; i++) { if (listeners[i].f === func) { listeners.splice(i, 1) break } } } else { listeners.splice(0, listeners.length) } } }, on: { value (type, func, ctx) { if (!getter.call(this)) { setter.call(this, {}) } const events = getter.call(this) events[type] = events[type] || [] events[type].push({ c: ctx, f: func }) } } }) }, /** * TODO * * @ignore */ extend (props, classProps) { const superClass = this let subClass props || (props = {}) classProps || (classProps = {}) if (props.hasOwnProperty('constructor')) { subClass = props.constructor delete props.constructor } else { subClass = function (...args) { utils.classCallCheck(this, subClass) superClass.apply(this, args) } } // Setup inheritance of instance members subClass.prototype = Object.create(superClass &amp;&amp; superClass.prototype, { constructor: { configurable: true, enumerable: false, value: subClass, writable: true } }) const obj = Object // Setup inheritance of static members if (obj.setPrototypeOf) { obj.setPrototypeOf(subClass, superClass) } else if (classProps.strictEs6Class) { subClass.__proto__ = superClass // eslint-disable-line } else { utils.forOwn(superClass, function (value, key) { subClass[key] = value }) } Object.defineProperty(subClass, '__super__', { configurable: true, value: superClass }) utils.addHiddenPropsToTarget(subClass.prototype, props) utils.fillIn(subClass, classProps) return subClass }, /** * Shallow copy own enumerable properties from `src` to `dest` that are on `src` * but are missing from `dest. * * @ignore * @param {Object} dest The destination object. * @param {Object} source The source object. */ fillIn (dest, src) { utils.forOwn(src, function (value, key) { if (!dest.hasOwnProperty(key) || dest[key] === undefined) { dest[key] = value } }) return dest }, /** * Find the index of something according to the given checker function. * * @ignore * @param {Array} array The array to search. * @param {Function} fn Checker function. * @param {number} Index if found or -1 if not found. */ findIndex (array, fn) { let index = -1 if (!array) { return index } array.forEach(function (record, i) { if (fn(record)) { index = i return false } }) return index }, /** * TODO * * @ignore */ forEachRelation (mapper, opts, fn, ctx) { const relationList = mapper.relationList || [] if (!relationList.length) { return } relationList.forEach(function (def) { utils._forRelation(opts, def, fn, ctx) }) }, /** * Iterate over an object's own enumerable properties. * * @ignore * @param {Object} object The object whose properties are to be enumerated. * @param {Function} fn Iteration function. * @param {Object} [thisArg] Content to which to bind `fn`. */ forOwn (obj, fn, thisArg) { const keys = Object.keys(obj) const len = keys.length let i for (i = 0; i &lt; len; i++) { fn.call(thisArg, obj[keys[i]], keys[i], obj) } }, /** * Proxy for `JSON.parse`. * * @ignore * @param {string} json JSON to parse. * @returns {Object} Parsed object. */ fromJson (json) { return utils.isString(json) ? JSON.parse(json) : json }, /** * TODO * * @ignore */ 'get': function (object, prop) { if (!prop) { return } const parts = prop.split('.') const last = parts.pop() while (prop = parts.shift()) { // eslint-disable-line object = object[prop] if (object == null) { // eslint-disable-line return } } return object[last] }, /** * TODO * * @ignore */ getSuper (instance, isCtor) { const ctor = isCtor ? instance : instance.constructor return (ctor.__super__ || Object.getPrototypeOf(ctor) || ctor.__proto__) // eslint-disable-line }, /** * Return the intersection of two arrays. * * @ignore * @param {Array} array1 First array. * @param {Array} array2 Second array. * @returns {Array} Array of elements common to both arrays. */ intersection (array1, array2) { if (!array1 || !array2) { return [] } const result = [] let item let i const len = array1.length for (i = 0; i &lt; len; i++) { item = array1[i] if (result.indexOf(item) !== -1) { continue } if (array2.indexOf(item) !== -1) { result.push(item) } } return result }, /** * TODO * * @ignore */ isArray: Array.isArray, /** * Return whether `prop` is matched by any string or regular expression in `bl`. * * @ignore * @param {string} prop The name of a property. * @param {Array} bl Array of strings and regular expressions. * @returns {boolean} Whether `prop` was matched. */ isBlacklisted (prop, bl) { if (!bl || !bl.length) { return false } let matches for (var i = 0; i &lt; bl.length; i++) { if ((toStr(bl[i]) === REGEXP_TAG &amp;&amp; bl[i].test(prop)) || bl[i] === prop) { matches = prop return matches } } return !!matches }, /** * TODO * * @ignore */ isBoolean (value) { return toStr(value) === BOOL_TAG }, /** * TODO * * @ignore */ isBrowser: false, /** * TODO * * @ignore */ isDate (value) { return (value &amp;&amp; typeof value === 'object' &amp;&amp; toStr(value) === DATE_TAG) }, /** * TODO * * @ignore */ isFunction (value) { return typeof value === 'function' || (value &amp;&amp; toStr(value) === FUNC_TAG) }, /** * TODO * * @ignore */ isInteger (value) { return toStr(value) === NUMBER_TAG &amp;&amp; value == toInteger(value) // eslint-disable-line }, /** * TODO * * @ignore */ isNull (value) { return value === null }, /** * TODO * * @ignore */ isNumber (value) { const type = typeof value return type === 'number' || (value &amp;&amp; type === 'object' &amp;&amp; toStr(value) === NUMBER_TAG) }, /** * TODO * * @ignore */ isObject (value) { return toStr(value) === OBJECT_TAG }, /** * TODO * * @ignore */ isRegExp (value) { return toStr(value) === REGEXP_TAG }, /** * TODO * * @ignore */ isSorN (value) { return utils.isString(value) || utils.isNumber(value) }, /** * TODO * * @ignore */ isString (value) { return typeof value === 'string' || (value &amp;&amp; typeof value === 'object' &amp;&amp; toStr(value) === STRING_TAG) }, /** * TODO * * @ignore */ isUndefined (value) { return value === undefined }, /** * TODO * * @ignore */ logify (target) { utils.addHiddenPropsToTarget(target, { dbg (...args) { this.log('debug', ...args) }, log (level, ...args) { if (level &amp;&amp; !args.length) { args.push(level) level = 'debug' } if (level === 'debug' &amp;&amp; !this.debug) { return } const prefix = `${level.toUpperCase()}: (${this.name || this.constructor.name})` if (console[level]) { console[level](prefix, ...args) } else { console.log(prefix, ...args) } } }) }, /** * TODO * * @ignore */ noDupeAdd (array, record, fn) { if (!array) { return } const index = this.findIndex(array, fn) if (index &lt; 0) { array.push(record) } }, /** * TODO * * @ignore */ omit (props, keys) { // Remove relations const _props = {} utils.forOwn(props, function (value, key) { if (keys.indexOf(key) === -1) { _props[key] = value } }) return _props }, /** * TODO * * @ignore */ plainCopy (from) { return utils.copy(from, undefined, undefined, undefined, undefined, true) }, /** * Proxy for `Promise.reject`. * * @ignore * @param {*} [value] Value with which to reject the Promise. * @returns {Promise} Promise reject with `value`. */ reject (value) { return utils.Promise.reject(value) }, /** * TODO * * @ignore */ remove (array, fn) { if (!array || !array.length) { return } const index = this.findIndex(array, fn) if (index &gt;= 0) { array.splice(index, 1) } }, /** * Proxy for `Promise.resolve`. * * @ignore * @param {*} [value] Value with which to resolve the Promise. * @returns {Promise} Promise resolved with `value`. */ resolve (value) { return utils.Promise.resolve(value) }, /** * Set the value at the provided key or path. * * @ignore * @param {Object} object The object on which to set a property. * @param {(string|Object)} path The key or path to the property. Can also * pass in an object of path/value pairs, which will all be set on the target * object. * @param {*} [value] The value to set. */ set: function (object, path, value) { if (utils.isObject(path)) { utils.forOwn(path, function (value, _path) { utils.set(object, _path, value) }) } else { const parts = PATH.exec(path) if (parts) { mkdirP(object, parts[1])[parts[2]] = value } else { object[path] = value } } }, /** * TODO * * @ignore */ strictEqual (a, b) { let _equal = a === b if (!_equal) { if (utils.isObject(a) &amp;&amp; utils.isObject(b)) { utils.forOwn(a, function (value, key) { _equal = _equal &amp;&amp; utils.strictEqual(value, b[key]) }) utils.forOwn(b, function (value, key) { _equal = _equal &amp;&amp; utils.strictEqual(value, a[key]) }) } else if (utils.isArray(a) &amp;&amp; utils.isArray(b)) { a.forEach(function (value, i) { _equal = _equal &amp;&amp; utils.strictEqual(value, b[i]) }) } } return _equal }, /** * Proxy for `JSON.stringify`. * * @ignore * @param {*} value Value to serialize to JSON. * @returns {string} JSON string. */ toJson: JSON.stringify, /** * Unset the value at the provided key or path. * * @ignore * @param {Object} object The object from which to delete the property. * @param {string} path The key or path to the property. */ unset (object, path) { const parts = path.split('.') const last = parts.pop() while (path = parts.shift()) { // eslint-disable-line object = object[path] if (object == null) { // eslint-disable-line return } } object[last] = undefined } } // Attempt to detect whether we are in the browser. try { utils.isBrowser = !!window } catch (e) { utils.isBrowser = false } export default utils × Search results Close api.js-data.io • js-data.io "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentContainerDataStoreLinkedCollectionMapperQueryRecordSchema Modules Details Classes Collection Component Container DataStore LinkedCollection Mapper Query Record Schema Namespaces query utils × Search results Close api.js-data.io • js-data.io "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentContainerDataStoreLinkedCollectionMapperQueryRecordSchema Classes Details Classes Collection Component Container DataStore LinkedCollection Mapper Query Record Schema Namespaces query utils × Search results Close api.js-data.io • js-data.io "},"namespaces.list.html":{"id":"namespaces.list.html","title":"Namespaces","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentContainerDataStoreLinkedCollectionMapperQueryRecordSchema Namespaces Details Classes Collection Component Container DataStore LinkedCollection Mapper Query Record Schema Namespaces query utils × Search results Close api.js-data.io • js-data.io "},"index.html":{"id":"index.html","title":"Index","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentContainerDataStoreLinkedCollectionMapperQueryRecordSchema js-data 3.0.0-beta.2 js-data v3 beta Browser tests Node.js tests JSData v3 beta is stable. More features may be added before 3.0.0. Some adapters still need to be updated to work with v3. Message @jmdobry on the JSData Slack channel if you want to help with tests, documentation, tutorials, adapters, etc. JSData is a framework-agnostic, datastore-agnostic ORM/ODM for Node.js and the Browser. Adapters allow JSData to connect to various data sources such as Firebase, MySql, RethinkDB, MongoDB, localStorage, Redis, a REST API, etc. With JSData you can re-use your data modeling code between environments, keep your data layer intact when transitioning between app frameworks, and work with a unified data API on the server and the client. JSData employs conventions for rapid development, but allows for endless customization in order to meet your particular needs. To get started, visit the main website at http://js-data.io. Links Quick start - Get started in 5 minutes Guides and Tutorials - Learn how to use JSData API Reference Docs - Explore components, methods, options, etc. Community &amp; Support - Find solutions and chat with the community General Contributing Guide - Give back and move the project forward Contributing to js-data core LicenseThe MIT License (MIT) Copyright (c) 2014-2016 js-data project authors LICENSE AUTHORS CONTRIBUTORS × Search results Close api.js-data.io • js-data.io "},"Collection.html":{"id":"Collection.html","title":"Class: Collection","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentContainerDataStoreLinkedCollectionMapperQueryRecordSchema Class: Collection Collection new Collection(records, opts) An ordered set of Record instances. Method parameters: Name Type Argument Description records Array &lt;optional&gt; Initial set of records to insert into the collection. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description idAttribute String &lt;optional&gt; See Collection#idAttribute. onConflict String &lt;optional&gt; &quot;merge&quot; See Collection#onConflict. mapper String &lt;optional&gt; See Collection#mapper. Details Type Source Function Collection.js, line 46 Example import {Collection, Record} from 'js-data' const user1 = new Record({ id: 1 }) const user2 = new Record({ id: 2 }) const UserCollection = new Collection([user1, user2]) UserCollection.get(1) === user1 // true Extends This class extends the Component class. Members _listeners Event listeners attached to this Component. Do not modify. Use Component#on and Component#off instead. Details Type Since Source Object 3.0.0 Component.js, line 7 Inherited From: Component#_listeners idAttribute Field to be used as the unique identifier for records in this collection. Defaults to &quot;id&quot; unless Collection#mapper is set, in which case this will default to Mapper#idAttribute. Details Type Default value Source String &quot;id&quot; Collection.js, line 9 index The main index, which uses @{link Collection#recordId} as the key. Details Type Source Index Collection.js, line 125 indexes Object that holds the secondary indexes of this collection. Details Type Source Object.&lt;string, Index&gt; Collection.js, line 139 mapper Default Mapper for this collection. Optional. If a Mapper is provided, then the collection will use the Mapper#idAttribute setting, and will wrap records in Mapper#recordClass. Details Type Default value Source Mapper null Collection.js, line 84 Example import {Collection, Mapper} from 'js-data' class MyMapperClass extends Mapper { foo () { return 'bar' } } const myMapper = new MyMapperClass() const collection = new Collection(null, { mapper: myMapper }) onConflict What to do when inserting a record into this Collection that shares a primary key with a record already in this Collection. Possible values: merge replace Merge: Recursively shallow copy properties from the new record onto the existing record. Replace: Shallow copy top-level properties from the new record onto the existing record. Any top-level own properties of the existing record that are not on the new record will be removed. Details Type Default value Source String &quot;merge&quot; Collection.js, line 20 Methods add(data, opts) Insert the provided record or records. If a record is already in the collection then the provided record will either merge with or replace the existing record based on the value of the onConflict option. The collection's secondary indexes will be updated as each record is visited. Method parameters: Name Type Argument Description data Object | Array.&lt;Object&gt; | Record | Array.&lt;Record&gt; The record or records to insert. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Description onConflict String &lt;optional&gt; What to do when a record is already in the collection. Possible values are merge or replace. Return value: Type Description Object | Array.&lt;Object&gt; | Record | Array.&lt;Record&gt; The added record or records. Details Since Source 3.0.0 Collection.js, line 168 afterRemove(id, opts, record) Lifecycle hook called by Collection#remove. If this method returns a value then Collection#remove will return that same value. Method parameters: Name Type Description id String | Number The id argument passed to Collection#remove. opts Object The opts argument passed to Collection#remove. record Object The result that will be returned by Collection#remove. Details Since Source 3.0.0 Collection.js, line 278 afterRemoveAll(query, opts, records) Lifecycle hook called by Collection#removeAll. If this method returns a value then Collection#removeAll will return that same value. Method parameters: Name Type Description query Object The query argument passed to Collection#removeAll. opts Object The opts argument passed to Collection#removeAll. records Object The result that will be returned by Collection#removeAll. Details Since Source 3.0.0 Collection.js, line 290 beforeAdd(records, opts) Lifecycle hook called by Collection#add. If this method returns a value then the records argument in Collection#add will be re-assigned to the returned value. Method parameters: Name Type Description records Object | Array.&lt;Object&gt; | Record | Array.&lt;Record&gt; The records argument passed to Collection#add. opts Object The opts argument passed to Collection#add. Details Since Source 3.0.0 Collection.js, line 303 beforeRemove(id, opts) Lifecycle hook called by Collection#remove. Method parameters: Name Type Description id String | Number The id argument passed to Collection#remove. opts Object The opts argument passed to Collection#remove. Details Since Source 3.0.0 Collection.js, line 315 beforeRemoveAll(query, opts) Lifecycle hook called by Collection#removeAll. Method parameters: Name Type Description query Object The query argument passed to Collection#removeAll. opts Object The opts argument passed to Collection#removeAll. Details Since Source 3.0.0 Collection.js, line 325 between(leftKeys, rightKeys, opts) Find all records between two boundaries. Shortcut for collection.query().between(18, 30, { index: 'age' }).run() Method parameters: Name Type Argument Description leftKeys Array Keys defining the left boundary. rightKeys Array Keys defining the right boundary. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description index String &lt;optional&gt; Name of the secondary index to use in the query. If no index is specified, the main index is used. leftInclusive Boolean &lt;optional&gt; true Whether to include records on the left boundary. rightInclusive Boolean &lt;optional&gt; false Whether to include records on the left boundary. limit Boolean &lt;optional&gt; Limit the result to a certain number. offset Boolean &lt;optional&gt; The number of resulting records to skip. Return value: Type Description Array The result. Details Since Source 3.0.0 Collection.js, line 335 Examples Get all users ages 18 to 30 const users = collection.between(18, 30, { index: 'age' }) Same as above const users = collection.between([18], [30], { index: 'age' }) createIndex(name, fieldList) Create a new secondary index on the contents of the collection. Method parameters: Name Type Argument Description name String The name of the new secondary index. fieldList Array.&lt;String&gt; &lt;optional&gt; Array of field names to use as the key or compound key of the new secondary index. If no fieldList is provided, then the name will also be the field that is used to index the collection. Return value: Type Description Collection A reference to itself for chaining. Details Since Source 3.0.0 Collection.js, line 365 Examples Index users by age collection.createIndex('age') Index users by status and role collection.createIndex('statusAndRole', ['status', 'role']) dbg(args) Log the provided values at the &quot;debug&quot; level. Method parameters: Name Type Argument Description args * &lt;optional&gt; &lt;repeatable&gt; Values to log. Details Since Source 3.0.0 Component.js, line 32 Inherited From: Component#dbg emit(event, args) Trigger an event on this Component. Method parameters: Name Type Argument Description event String Name of event to emit. args * &lt;optional&gt; &lt;repeatable&gt; Arguments to pass to any listeners. Details Since Source 3.0.0 Component.js, line 98 Inherited From: Component#emit Examples collection.on('foo', (msg) =&gt; { console.log(msg) // &quot;bar&quot; }) collection.emit('foo', 'bar') store.on('foo', (msg, val1, val2) =&gt; { console.log(msg, val1, val2) // &quot;bar&quot; &quot;beep&quot; &quot;boop&quot; }) store.emit('foo', 'bar', 'beep', 'boop') filter(queryOrFn, thisArg) Find the record or records that match the provided query or pass the provided filter function. Shortcut for collection.query().filter(queryOrFn[, thisArg]).run() Method parameters: Name Type Argument Default Description queryOrFn Object | Function &lt;optional&gt; {} Selection query or filter function. thisArg Object &lt;optional&gt; Context to which to bind queryOrFn if queryOrFn is a function. Return value: Type Description Array The result. Details Since Source 3.0.0 Collection.js, line 396 Examples Get the draft posts created less than three months const posts = collection.filter({ where: { status: { '==': 'draft' }, created_at_timestamp: { '&gt;=': (new Date().getTime() - (1000 * 60 * 60 * 24 * 30 * 3)) // 3 months ago } } }) Use a custom filter function const posts = collection.filter(function (post) { return post.isReady() }) forEach(forEachFn, thisArg) Iterate over all records. Method parameters: Name Type Argument Description forEachFn Function Iteration function. thisArg * &lt;optional&gt; Context to which to bind forEachFn. Return value: Type Description Array The result. Details Since Source 3.0.0 Collection.js, line 431 Example collection.forEach(function (record) { // do something }) get(id) Get the record with the given id. Method parameters: Name Type Description id String | Number The primary key of the record to get. Return value: Type Description Object | Record The record with the given id. Details Since Source 3.0.0 Collection.js, line 449 getAll(keyList, opts) Find the record or records that match the provided keyLists. Shortcut for collection.query().getAll(keyList1, keyList2, ...).run() Method parameters: Name Type Argument Description keyList Array &lt;optional&gt; &lt;repeatable&gt; Provide one or more keyLists, and all records matching each keyList will be retrieved. If no keyLists are provided, all records will be returned. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Description index String &lt;optional&gt; Name of the secondary index to use in the query. If no index is specified, the main index is used. Return value: Type Description Array The result. Details Since Source 3.0.0 Collection.js, line 462 Examples Get the posts where &quot;status&quot; is &quot;draft&quot; or &quot;inReview&quot; const posts = collection.getAll('draft', 'inReview', { index: 'status' }) Same as above const posts = collection.getAll(['draft'], ['inReview'], { index: 'status' }) getIndex(name) Return the index with the given name. If no name is provided, return the main index. Throws an error if the specified index does not exist. Method parameters: Name Type Argument Description name String &lt;optional&gt; The name of the index to retrieve. Details Since Source 3.0.0 Collection.js, line 487 limit(num) Limit the result. Shortcut for collection.query().limit(maximumNumber).run() Method parameters: Name Type Description num Number The maximum number of records to keep in the result. Return value: Type Description Array The result. Details Since Source 3.0.0 Collection.js, line 503 Example const posts = collection.limit(10) log(level, args) Log the provided values. By default sends values to console[level]. Method parameters: Name Type Argument Description level String Log level args * &lt;optional&gt; &lt;repeatable&gt; Values to log. Details Since Source 3.0.0 Component.js, line 39 Inherited From: Component#log map(mapFn, thisArg) Apply a mapping function to all records. Method parameters: Name Type Argument Description mapFn Function Mapping function. thisArg * &lt;optional&gt; Context to which to bind mapFn. Return value: Type Description Array The result of the mapping. Details Since Source 3.0.0 Collection.js, line 520 Example const names = collection.map(function (user) { return user.name }) mapCall(funcName) Return the result of calling the specified function on each record in this collection's main index. Method parameters: Name Type Description funcName String Name of function to call Return value: Type Description Array The result. Details Since Source 3.0.0 Collection.js, line 542 method(result, opts) Lifecycle hook called by Collection#add. If this method returns a value then Collection#add will return that same value. Method parameters: Name Type Description result Object | Array.&lt;Object&gt; | Record | Array.&lt;Record&gt; The record or records that were added to this Collection by Collection#add. opts Object The opts argument passed to Collection#add. Details Since Source 3.0.0 Collection.js, line 266 off(event, listener) Remove an event listener from this Component. If no listener is provided, then all listeners for the specified event will be removed. If no event is specified then all listeners for all events will be removed. Method parameters: Name Type Argument Description event String &lt;optional&gt; Name of event to unsubsribe to. listener Function &lt;optional&gt; Listener to remove. Details Since Source 3.0.0 Component.js, line 79 Inherited From: Component#off Examples Remove a listener to a single event collection.off('add', handler) Remove all listeners to a single event record.off('change') Remove all listeners to all events store.off() on(event, listener, ctx) Register a new event listener on this Component. Method parameters: Name Type Argument Description event String Name of event to subsribe to. listener Function Listener function to handle the event. ctx * &lt;optional&gt; Optional content in which to invoke the listener. Details Since Source 3.0.0 Component.js, line 49 Inherited From: Component#on Examples Listen for all &quot;afterCreate&quot; events in a DataStore store.on('afterCreate', (mapperName, props, opts, result) =&gt; { console.log(mapperName) // &quot;post&quot; console.log(props.id) // undefined console.log(result.id) // 1234 }) store.create('post', { title: 'Modeling your data' }).then((post) =&gt; { console.log(post.id) // 1234 }) Listen for the &quot;add&quot; event on a collection collection.on('add', (records) =&gt; { console.log(records) // [...] }) Listen for &quot;change&quot; events on a record post.on('change', (record, changes) =&gt; { console.log(changes) // { changed: { title: 'Modeling your data' } } }) post.title = 'Modeling your data' query() Create a new query to be executed against the contents of the collection. The result will be all or a subset of the contents of the collection. Return value: Type Description Query New query object. Details Since Source 3.0.0 Collection.js, line 579 Example Grab page 2 of users between ages 18 and 30 collection.query() .between(18, 30, { index: 'age' }) // between ages 18 and 30 .skip(10) // second page .limit(10) // page size .run() recordId(record) Return the primary key of the given, or if no record is provided, return the name of the field that holds the primary key of records in this Collection. Method parameters: Name Type Argument Description record Object | Record &lt;optional&gt; The record whose primary key is to be returned. Return value: Type Description String | Number Primary key or name of field that holds primary key. Details Since Source 3.0.0 Collection.js, line 560 reduce(cb, initialValue) Reduce the data in the collection to a single value and return the result. Method parameters: Name Type Description cb Function Reduction callback. initialValue * Initial value of the reduction. Return value: Type Description * The result. Details Since Source 3.0.0 Collection.js, line 599 Example const totalVotes = collection.reduce(function (prev, record) { return prev + record.upVotes + record.downVotes }, 0) remove(id, opts) Remove the record with the given id from this Collection. Method parameters: Name Type Argument Description id String | Number The primary key of the record to be removed. opts Object &lt;optional&gt; Configuration options. Return value: Type Description Object | Record The removed record, if any. Details Since Source 3.0.0 Collection.js, line 618 removeAll(query, opts) Remove the record selected by &quot;query&quot; from this collection. Method parameters: Name Type Argument Default Description query Object &lt;optional&gt; {} Selection query. Properties Name Type Argument Description where Object &lt;optional&gt; Filtering criteria. skip Number &lt;optional&gt; Number to skip. limit Number &lt;optional&gt; Number to limit to. orderBy Array &lt;optional&gt; Sorting criteria. opts Object &lt;optional&gt; Configuration options. Return value: Type Description Array.&lt;Object&gt; | Array.&lt;Record&gt; The removed records, if any. Details Since Source 3.0.0 Collection.js, line 649 skip(num) Skip a number of results. Shortcut for collection.query().skip(numberToSkip).run() Method parameters: Name Type Description num Number The number of records to skip. Return value: Type Description Array The result. Details Since Source 3.0.0 Collection.js, line 676 Example const posts = collection.skip(10) toJSON(opts) Return the plain JSON representation of all items in this collection. Assumes records in this collection have a toJSON method. Method parameters: Name Type Argument Description opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Description with Array.&lt;String&gt; &lt;optional&gt; Array of relation names or relation fields to include in the representation. Return value: Type Description Array The records. Details Since Source 3.0.0 Collection.js, line 693 updateIndex(record, opts) Update a record's position in a single index of this collection. See Collection#updateIndexes to update a record's position in all indexes at once. Method parameters: Name Type Argument Description record Object The record to update. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Description index String &lt;optional&gt; The index in which to update the record's position. If you don't specify an index then the record will be updated in the main index. Details Since Source 3.0.0 Collection.js, line 708 updateIndexes(record, opts) TODO Method parameters: Name Type Argument Description record Object TODO opts Object &lt;optional&gt; Configuration options. Details Since Source 3.0.0 Collection.js, line 726 × Search results Close api.js-data.io • js-data.io "},"Component.html":{"id":"Component.html","title":"Class: Component","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentContainerDataStoreLinkedCollectionMapperQueryRecordSchema Class: Component Component new Component() Details Source Component.js, line 3 Members _listeners Event listeners attached to this Component. Do not modify. Use Component#on and Component#off instead. Details Type Since Source Object 3.0.0 Component.js, line 7 Methods &lt;static&gt; extend(props, classProps) Create a subclass of this component. Method parameters: Name Type Argument Default Description props Object &lt;optional&gt; {} Properties to add to the prototype of the subclass. classProps Object &lt;optional&gt; {} Static properties to add to the subclass. Return value: Type Description Constructor Subclass of this component. Details Since Source 3.0.0 Component.js, line 19 dbg(args) Log the provided values at the &quot;debug&quot; level. Method parameters: Name Type Argument Description args * &lt;optional&gt; &lt;repeatable&gt; Values to log. Details Since Source 3.0.0 Component.js, line 32 emit(event, args) Trigger an event on this Component. Method parameters: Name Type Argument Description event String Name of event to emit. args * &lt;optional&gt; &lt;repeatable&gt; Arguments to pass to any listeners. Details Since Source 3.0.0 Component.js, line 98 Examples collection.on('foo', (msg) =&gt; { console.log(msg) // &quot;bar&quot; }) collection.emit('foo', 'bar') store.on('foo', (msg, val1, val2) =&gt; { console.log(msg, val1, val2) // &quot;bar&quot; &quot;beep&quot; &quot;boop&quot; }) store.emit('foo', 'bar', 'beep', 'boop') log(level, args) Log the provided values. By default sends values to console[level]. Method parameters: Name Type Argument Description level String Log level args * &lt;optional&gt; &lt;repeatable&gt; Values to log. Details Since Source 3.0.0 Component.js, line 39 off(event, listener) Remove an event listener from this Component. If no listener is provided, then all listeners for the specified event will be removed. If no event is specified then all listeners for all events will be removed. Method parameters: Name Type Argument Description event String &lt;optional&gt; Name of event to unsubsribe to. listener Function &lt;optional&gt; Listener to remove. Details Since Source 3.0.0 Component.js, line 79 Examples Remove a listener to a single event collection.off('add', handler) Remove all listeners to a single event record.off('change') Remove all listeners to all events store.off() on(event, listener, ctx) Register a new event listener on this Component. Method parameters: Name Type Argument Description event String Name of event to subsribe to. listener Function Listener function to handle the event. ctx * &lt;optional&gt; Optional content in which to invoke the listener. Details Since Source 3.0.0 Component.js, line 49 Examples Listen for all &quot;afterCreate&quot; events in a DataStore store.on('afterCreate', (mapperName, props, opts, result) =&gt; { console.log(mapperName) // &quot;post&quot; console.log(props.id) // undefined console.log(result.id) // 1234 }) store.create('post', { title: 'Modeling your data' }).then((post) =&gt; { console.log(post.id) // 1234 }) Listen for the &quot;add&quot; event on a collection collection.on('add', (records) =&gt; { console.log(records) // [...] }) Listen for &quot;change&quot; events on a record post.on('change', (record, changes) =&gt; { console.log(changes) // { changed: { title: 'Modeling your data' } } }) post.title = 'Modeling your data' × Search results Close api.js-data.io • js-data.io "},"Container.html":{"id":"Container.html","title":"Class: Container","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentContainerDataStoreLinkedCollectionMapperQueryRecordSchema Class: Container Container new Container(opts) import {Container} from 'js-data'The Container class is a place to store Mapper instances. Without a container, you need to manage mappers yourself, including resolving circular dependencies among relations. All mappers in a container share the same adapters, so you don't have to add each adapter to all of your mappers. Method parameters: Name Type Argument Description opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Description mapperClass Function &lt;optional&gt; Constructor function to use in Container#defineMapper to create a new mapper. mapperDefaults Object &lt;optional&gt; Defaults options to pass to Container#mapperClass when creating a new mapper. Return value: Type Description Container Unspecified Details Since Source Tutorials 3.0.0 Container.js, line 698 Components of JSData: Container Notes on using JSData in the Browser Notes on using JSData in Node.js Examples Without Container import {Mapper} from 'js-data' import HttpAdapter from 'js-data-http' const adapter = new HttpAdapter() const userMapper = new Mapper({ name: 'user' }) userMapper.registerAdapter('http', adapter, { default: true }) const commentMapper = new Mapper({ name: 'comment' }) commentMapper.registerAdapter('http', adapter, { default: true }) // This might be more difficult if the mappers were defined in different // modules. userMapper.hasMany(commentMapper, { localField: 'comments', foreignKey: 'userId' }) commentMapper.belongsTo(userMapper, { localField: 'user', foreignKey: 'userId' }) With Container import {Container} from 'js-data' import HttpAdapter from 'js-data-http' const container = new Container() // All mappers in container share adapters container.registerAdapter('http', new HttpAdapter(), { default: true }) // These could be defined in separate modules without a problem. container.defineMapper('user', { relations: { hasMany: { comment: { localField: 'comments', foreignKey: 'userId' } } } }) container.defineMapper('comment', { relations: { belongsTo: { user: { localField: 'user', foreignKey: 'userId' } } } }) Extends This class extends the Component class. Members _listeners Event listeners attached to this Component. Do not modify. Use Component#on and Component#off instead. Details Type Since Source Object 3.0.0 Component.js, line 7 Inherited From: Component#_listeners mapperClass Constructor function to use in Container#defineMapper to create a new mapper. Mapper Details Type Since Source Constructor 3.0.0 Container.js, line 457 mapperDefaults Defaults options to pass to Container#mapperClass when creating a new Mapper. Details Type Since Default value Source Object 3.0.0 {} Container.js, line 446 Methods &lt;static&gt; extend(props, classProps) Create a subclass of this Container. Method parameters: Name Type Argument Default Description props Object &lt;optional&gt; {} Properties to add to the prototype of the subclass. classProps Object &lt;optional&gt; {} Static properties to add to the subclass. Return value: Type Description Constructor Subclass of this Container. Details Since Source 3.0.0 Container.js, line 773 Examples Extend the class in a cross-browser manner. import {Container} from 'js-data' const CustomContainerClass = Container.extend({ foo () { return 'bar' } }) const customContainer = new CustomContainerClass() console.log(customContainer.foo()) // &quot;bar&quot; Extend the class using ES2015 class syntax. class CustomContainerClass extends Container { foo () { return 'bar' } } const customContainer = new CustomContainerClass() console.log(customContainer.foo()) // &quot;bar&quot; count(name, query, opts) Wrapper for Mapper#count. Method parameters: Name Type Argument Description name String Name of the Mapper to target. query Object &lt;optional&gt; See Mapper#count. opts Object &lt;optional&gt; See Mapper#count. Return value: Type Description Promise See Mapper#count. Details Since Source See 3.0.0 Container.js, line 13 Mapper#count Example Get the number of published blog posts import {Container} from 'js-data' import RethinkDBAdapter from 'js-data-rethinkdb' const store = new Container() store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }) store.defineMapper('post') store.count('post', { status: 'published' }).then((numPublished) =&gt; { console.log(numPublished) // e.g. 45 }) create(name, props, opts) Wrapper for Mapper#create. Method parameters: Name Type Argument Description name String Name of the Mapper to target. props Object See Mapper#create. opts Object &lt;optional&gt; See Mapper#create. Return value: Type Description Promise See Mapper#create. Details Since Source See 3.0.0 Container.js, line 37 Mapper#create Example Create and save a new blog post import {Container} from 'js-data' import RethinkDBAdapter from 'js-data-rethinkdb' const store = new Container() store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }) store.defineMapper('post') store.create('post', { title: 'Modeling your data', status: 'draft' }).then((post) =&gt; { console.log(post) // { id: 1234, status: 'draft', ... } }) createMany(name, records, opts) Wrapper for Mapper#createMany. Method parameters: Name Type Argument Description name String Name of the Mapper to target. records Array.&lt;Record&gt; See Mapper#createMany. opts Object &lt;optional&gt; See Mapper#createMany. Return value: Type Description Promise See Mapper#createMany. Details Since Source See 3.0.0 Container.js, line 64 Mapper#createMany Example Create and save several new blog posts import {Container} from 'js-data' import RethinkDBAdapter from 'js-data-rethinkdb' const store = new Container() store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }) store.defineMapper('post') store.createMany('post', [{ title: 'Modeling your data', status: 'draft' }, { title: 'Reading data', status: 'draft' }]).then((posts) =&gt; { console.log(posts[0]) // { id: 1234, status: 'draft', ... } console.log(posts[1]) // { id: 1235, status: 'draft', ... } }) createRecord(name, props, opts) Wrapper for Mapper#createRecord. Note: This method does not interact with any adapter, and does not save any data. It only creates new objects in memory. Method parameters: Name Type Argument Description name String Name of the Mapper to target. props Object | Array.&lt;Object&gt; See Mapper#createRecord. opts Object &lt;optional&gt; See Mapper#createRecord. Return value: Type Description Promise See Mapper#createRecord. Details Since Source See 3.0.0 Container.js, line 95 Mapper#createRecord Example Create empty unsaved record instance import {Container} from 'js-data' const store = new Container() store.defineMapper('post') const post = PostService.createRecord() dbg(name, args) Wrapper for Mapper#dbg. Method parameters: Name Type Argument Description name String Name of the Mapper to target. args * &lt;repeatable&gt; See Mapper#dbg. Details Since Source Overrides See 3.0.0 Container.js, line 117 Component#dbg Mapper#dbg defineMapper(name, opts) Create a new mapper and register it in this container. Method parameters: Name Type Argument Description name String Name under which to register the new Mapper. Mapper#name will be set to this value. opts Object &lt;optional&gt; Configuration options. Passed to Container#mapperClass when creating the new Mapper. Return value: Type Description Mapper Unspecified Details Since Source 3.0.0 Container.js, line 503 Example import {Container} from 'js-data' const store = new Container({ mapperDefaults: { foo: 'bar' } }) const userMapper = store.defineMapper('user') userMapper.foo // &quot;bar&quot; destroy(name, id, opts) Wrapper for Mapper#destroy. Method parameters: Name Type Argument Description name String Name of the Mapper to target. id String | Number See Mapper#destroy. opts Object &lt;optional&gt; See Mapper#destroy. Return value: Type Description Promise See Mapper#destroy. Details Since Source See 3.0.0 Container.js, line 128 Mapper#destroy Example Destroy a specific blog post import {Container} from 'js-data' import RethinkDBAdapter from 'js-data-rethinkdb' const store = new Container() store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }) store.defineMapper('post') store.destroy('post', 1234).then(() =&gt; { // Blog post #1234 has been destroyed }) destroyAll(name, query, opts) Wrapper for Mapper#destroyAll. Method parameters: Name Type Argument Description name String Name of the Mapper to target. query Object &lt;optional&gt; See Mapper#destroyAll. opts Object &lt;optional&gt; See Mapper#destroyAll. Return value: Type Description Promise See Mapper#destroyAll. Details Since Source See 3.0.0 Container.js, line 152 Mapper#destroyAll Example Destroy all &quot;draft&quot; blog posts import {Container} from 'js-data' import RethinkDBAdapter from 'js-data-rethinkdb' const store = new Container() store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }) store.defineMapper('post') store.destroyAll('post', { status: 'draft' }).then(() =&gt; { // All &quot;draft&quot; blog posts have been destroyed }) emit(event, args) Trigger an event on this Component. Method parameters: Name Type Argument Description event String Name of event to emit. args * &lt;optional&gt; &lt;repeatable&gt; Arguments to pass to any listeners. Details Since Source 3.0.0 Component.js, line 98 Inherited From: Component#emit Examples collection.on('foo', (msg) =&gt; { console.log(msg) // &quot;bar&quot; }) collection.emit('foo', 'bar') store.on('foo', (msg, val1, val2) =&gt; { console.log(msg, val1, val2) // &quot;bar&quot; &quot;beep&quot; &quot;boop&quot; }) store.emit('foo', 'bar', 'beep', 'boop') find(name, id, opts) Wrapper for Mapper#find. Method parameters: Name Type Argument Description name String Name of the Mapper to target. id String | Number See Mapper#find. opts Object &lt;optional&gt; See Mapper#find. Return value: Type Description Promise See Mapper#find. Details Since Source See 3.0.0 Container.js, line 176 Mapper#find Example import {Container} from 'js-data' import RethinkDBAdapter from 'js-data-rethinkdb' const store = new Container() store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }) store.defineMapper('post') store.find('post', 1).then((post) =&gt; { console.log(post) // { id: 1, ...} }) findAll(name, query, opts) Wrapper for Mapper#createRecord. Method parameters: Name Type Argument Description name String Name of the Mapper to target. query Object &lt;optional&gt; See Mapper#findAll. opts Object &lt;optional&gt; See Mapper#findAll. Return value: Type Description Promise See Mapper#findAll. Details Since Source See 3.0.0 Container.js, line 200 Mapper#findAll Example Find all &quot;published&quot; blog posts import {Container} from 'js-data' import RethinkDBAdapter from 'js-data-rethinkdb' const store = new Container() store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }) store.defineMapper('post') store.findAll('post', { status: 'published' }).then((posts) =&gt; { console.log(posts) // [{ id: 1, ...}, ...] }) getAdapter(name) Return the registered adapter with the given name or the default adapter if no name is provided. Method parameters: Name Type Argument Description name String &lt;optional&gt; The name of the adapter to retrieve. Return value: Type Description Adapter The adapter. Details Since Source 3.0.0 Container.js, line 591 getAdapterName(opts) Return the name of a registered adapter based on the given name or options, or the name of the default adapter if no name provided. Method parameters: Name Type Argument Description opts Object | String &lt;optional&gt; The name of an adapter or options, if any. Return value: Type Description String The name of the adapter. Details Since Source 3.0.0 Container.js, line 609 getAdapters() Return the registered adapters of this container. Return value: Type Description Adapter Unspecified Details Since Source 3.0.0 Container.js, line 626 getMapper(name) Return the mapper registered under the specified name. Method parameters: Name Type Description name String Mapper#name. Return value: Type Description Mapper Unspecified Details Since Source 3.0.0 Container.js, line 637 Example import {Container} from 'js-data' const container = new Container() const userMapper = container.defineMapper('user') userMapper === container.getMapper('user') // true getSchema(name) Wrapper for Mapper#getSchema. Method parameters: Name Type Description name String Name of the Mapper to target. Return value: Type Description Schema See Mapper#getSchema. Details Since Source See 3.0.0 Container.js, line 224 Mapper#getSchema is(name, record) Wrapper for Mapper#is. Method parameters: Name Type Description name String Name of the Mapper to target. record Object | Record See Mapper#is. Return value: Type Description Boolean See Mapper#is. Details Since Source See 3.0.0 Container.js, line 235 Mapper#is Example import {Container} from 'js-data' const store = new Container() store.defineMapper('post') const post = store.createRecord() console.log(store.is('post', post)) // true // Equivalent to what's above console.log(post instanceof store.getMapper('post').recordClass) // true log(name, args) Wrapper for Mapper#log. Method parameters: Name Type Argument Description name String Name of the Mapper to target. args * &lt;repeatable&gt; See Mapper#log. Details Since Source Overrides See 3.0.0 Container.js, line 257 Component#log Mapper#log off(event, listener) Remove an event listener from this Component. If no listener is provided, then all listeners for the specified event will be removed. If no event is specified then all listeners for all events will be removed. Method parameters: Name Type Argument Description event String &lt;optional&gt; Name of event to unsubsribe to. listener Function &lt;optional&gt; Listener to remove. Details Since Source 3.0.0 Component.js, line 79 Inherited From: Component#off Examples Remove a listener to a single event collection.off('add', handler) Remove all listeners to a single event record.off('change') Remove all listeners to all events store.off() on(event, listener, ctx) Register a new event listener on this Container. Proxy for Component#on. If an event was emitted by a Mapper in the Container, then the name of the Mapper will be prepended to the arugments passed to the listener. Method parameters: Name Type Argument Description event String Name of event to subsribe to. listener Function Listener function to handle the event. ctx * &lt;optional&gt; Optional content in which to invoke the listener. Details Since Source Overrides 3.0.0 Container.js, line 475 Component#on registerAdapter(name, adapter, opts) Register an adapter on this container under the given name. Adapters registered on a container are shared by all mappers in the container. Method parameters: Name Type Argument Description name String The name of the adapter to register. adapter Adapter The adapter to register. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description default Boolean &lt;optional&gt; false Whether to make the adapter the default adapter for all Mappers in this container. Details Since Source Tutorials 3.0.0 Container.js, line 659 Connecting to a data source Example import {Container} from 'js-data' import HttpAdapter from 'js-data-http' const container = new Container() container.registerAdapter('http', new HttpAdapter, { default: true }) sum(name, field, query, opts) Wrapper for Mapper#sum. Method parameters: Name Type Argument Description name String Name of the Mapper to target. field String See Mapper#sum. query Object &lt;optional&gt; See Mapper#sum. opts Object &lt;optional&gt; See Mapper#sum. Return value: Type Description Promise See Mapper#sum. Details Since Source See 3.0.0 Container.js, line 268 Mapper#sum Example import {Container} from 'js-data' import RethinkDBAdapter from 'js-data-rethinkdb' const store = new Container() store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }) store.defineMapper('purchase_order') store.sum('purchase_order', 'amount', { status: 'paid' }).then((amountPaid) =&gt; { console.log(amountPaid) // e.g. 451125.34 }) toJSON(name, records, opts) Wrapper for Mapper#toJSON. Method parameters: Name Type Argument Description name String Name of the Mapper to target. records Record | Array.&lt;Record&gt; See Mapper#toJSON. opts Object &lt;optional&gt; See Mapper#toJSON. Return value: Type Description Object | Array.&lt;Object&gt; See Mapper#toJSON. Details Since Source See 3.0.0 Container.js, line 293 Mapper#toJSON Example import {Container} from 'js-data' import RethinkDBAdapter from 'js-data-rethinkdb' const store = new Container() store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }) store.defineMapper('person', { schema: { properties: { name: { type: 'string' }, id: { type: 'string' } } } }) const person = store.createRecord('person', { id: 1, name: 'John', foo: 'bar' }) console.log(store.toJSON('person', person)) // {&quot;id&quot;:1,&quot;name&quot;:&quot;John&quot;,&quot;foo&quot;:&quot;bar&quot;} console.log(store.toJSON('person', person), { strict: true }) // {&quot;id&quot;:1,&quot;name&quot;:&quot;John&quot;} update(name, id, record, opts) Wrapper for Mapper#update. Method parameters: Name Type Argument Description name String Name of the Mapper to target. id String | Number See Mapper#update. record Object See Mapper#update. opts Object &lt;optional&gt; See Mapper#update. Return value: Type Description Promise See Mapper#update. Details Since Source Tutorials See 3.0.0 Container.js, line 323 Saving data Mapper#update Example import {Container} from 'js-data' import RethinkDBAdapter from 'js-data-rethinkdb' const store = new Container() store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }) store.defineMapper('post') store.update('post', 1234, { status: 'published', published_at: new Date() }).then((post) =&gt; { console.log(post) // { id: 1234, status: 'published', ... } }) updateAll(name, update, query, opts) Wrapper for Mapper#updateAll. Method parameters: Name Type Argument Description name String Name of the Mapper to target. update Object See Mapper#updateAll. query Object &lt;optional&gt; See Mapper#updateAll. opts Object &lt;optional&gt; See Mapper#updateAll. Return value: Type Description Promise See Mapper#updateAll. Details Since Source See 3.0.0 Container.js, line 352 Mapper#updateAll Example Turn all of John's blog posts into drafts. import {Container} from 'js-data' import RethinkDBAdapter from 'js-data-rethinkdb' const store = new Container() store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }) store.defineMapper('post') const update = { status: draft: published_at: null } const query = { userId: 1234 } store.updateAll('post', update, query).then((posts) =&gt; { console.log(posts) // [...] }) updateMany(name, records, opts) Wrapper for Mapper#updateMany. Method parameters: Name Type Argument Description name String Name of the Mapper to target. records Array.&lt;Object&gt; | Array.&lt;Record&gt; See Mapper#updateMany. opts Object &lt;optional&gt; See Mapper#updateMany. Return value: Type Description Promise See Mapper#updateMany. Details Since Source See 3.0.0 Container.js, line 379 Mapper#updateMany Example import {Container} from 'js-data' import RethinkDBAdapter from 'js-data-rethinkdb' const store = new Container() store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }) store.defineMapper('post') store.updateMany('post', [ { id: 1234, status: 'draft' }, { id: 2468, status: 'published', published_at: new Date() } ]).then((posts) =&gt; { console.log(posts) // [...] }) validate(name, records, opts) Wrapper for Mapper#validate. Method parameters: Name Type Argument Description name String Name of the Mapper to target. records Array.&lt;Object&gt; | Array.&lt;Record&gt; See Mapper#validate. opts Object &lt;optional&gt; See Mapper#validate. Return value: Type Description Promise See Mapper#validate. Details Since Source See 3.0.0 Container.js, line 406 Mapper#validate Example import {Container} from 'js-data' const store = new Container() store.defineMapper('post', { schema: { properties: { name: { type: 'string' }, id: { type: 'string' } } } }) let errors = store.validate('post', { name: 'John' }) console.log(errors) // undefined errors = store.validate('post', { name: 123 }) console.log(errors) // [{ expected: 'one of (string)', actual: 'number', path: 'name' }] × Search results Close api.js-data.io • js-data.io "},"DataStore.html":{"id":"DataStore.html","title":"Class: DataStore","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentContainerDataStoreLinkedCollectionMapperQueryRecordSchema Class: DataStore DataStore new DataStore(opts) The DataStore class is an extension of Container. Not only does DataStore manage mappers, but also collections. DataStore implements the asynchronous Mapper methods, such as Mapper#find and Mapper#create. If you use the asynchronous DataStore methods instead of calling them directly on the mappers, then the results of the method calls will be inserted into the store's collections. You can think of a DataStore as an Identity Map for the ORM (the Mappers). import {DataStore} from 'js-data' Method parameters: Name Type Argument Description opts Object &lt;optional&gt; Configuration options. See Container. Return value: Type Description DataStore Unspecified Details Since Source Tutorials See 3.0.0 DataStore.js, line 835 Components of JSData: DataStore Working with the DataStore Notes on using JSData in the Browser Container Example import {DataStore} from 'js-data' import HttpAdapter from 'js-data-http' const store = new DataStore() const UserMapper = store.defineMapper('user') // Call &quot;find&quot; on &quot;UserMapper&quot; (Stateless ORM) UserMapper.find(1).then((user) =&gt; { // retrieved a &quot;user&quot; record via the http adapter, but that's it // Call &quot;find&quot; on &quot;store&quot; targeting &quot;user&quot; (Stateful DataStore) return store.find('user', 1) }).then((user) =&gt; { // not only was a &quot;user&quot; record retrieved, but it was added to the // store's &quot;user&quot; collection const cachedUser = store.getCollection('user').get(1) console.log(user === cachedUser) // true }) Extends This class extends the Container class. Members _listeners Event listeners attached to this Component. Do not modify. Use Component#on and Component#off instead. Details Type Since Source Object 3.0.0 Component.js, line 7 Inherited From: Component#_listeners mapperClass Constructor function to use in Container#defineMapper to create a new mapper. Mapper Details Type Since Source Constructor 3.0.0 Container.js, line 457 Inherited From: Container#mapperClass mapperDefaults Defaults options to pass to Container#mapperClass when creating a new Mapper. Details Type Since Default value Source Object 3.0.0 {} Container.js, line 446 Inherited From: Container#mapperDefaults Methods &lt;static&gt; extend(props, classProps) Create a subclass of this DataStore. Method parameters: Name Type Argument Default Description props Object &lt;optional&gt; {} Properties to add to the prototype of the subclass. classProps Object &lt;optional&gt; {} Static properties to add to the subclass. Return value: Type Description Constructor Subclass of this DataStore. Details Since Source 3.0.0 DataStore.js, line 881 Examples Extend the class in a cross-browser manner. import {DataStore} from 'js-data' const CustomDataStoreClass = DataStore.extend({ foo () { return 'bar' } }) const customDataStore = new CustomDataStoreClass() console.log(customDataStore.foo()) // &quot;bar&quot; Extend the class using ES2015 class syntax. class CustomDataStoreClass extends DataStore { foo () { return 'bar' } } const customDataStore = new CustomDataStoreClass() console.log(customDataStore.foo()) // &quot;bar&quot; addToCache(name, data, opts) TODO Method parameters: Name Type Argument Description name String Name of the Mapper to target. data * Data from which data should be selected for add. opts Object &lt;optional&gt; Configuration options. Details Source DataStore.js, line 99 cachedFind(name, id, opts) Retrieve a cached find result, if any. Method parameters: Name Type Description name String The name argument passed to DataStore#find. id String | Number The id argument passed to DataStore#find. opts Object The opts argument passed to DataStore#find. Details Source DataStore.js, line 112 cachedFindAll(name, hash, opts) Retrieve a cached findAll result, if any. Method parameters: Name Type Description name String The name argument passed to DataStore#findAll. hash String The result of calling DataStore#hashQuery on the query argument passed to DataStore#findAll. opts Object The opts argument passed to DataStore#findAll. Details Source DataStore.js, line 123 cacheFind(name, data, id, opts) Cache a find result. The default implementation does the following: // Find and return the record from the data store return this.get(name, id)Override this method to customize. Method parameters: Name Type Description name String The name argument passed to DataStore#find. data * The result to cache. id String | Number The id argument passed to DataStore#find. opts Object The opts argument passed to DataStore#find. Details Source DataStore.js, line 135 cacheFindAll(name, data, hash, opts) Cache a findAll result. The default implementation does the following: // Find and return the records from the data store return this.filter(name, utils.fromJson(hash))Override this method to customize. Method parameters: Name Type Description name String The name argument passed to DataStore#findAll. data * The result to cache. hash String The result of calling DataStore#hashQuery on the query argument passed to DataStore#findAll. opts Object The opts argument passed to DataStore#findAll. Details Source DataStore.js, line 159 count(name, query, opts) Wrapper for Mapper#count. Method parameters: Name Type Argument Description name String Name of the Mapper to target. query Object &lt;optional&gt; See Mapper#count. opts Object &lt;optional&gt; See Mapper#count. Return value: Type Description Promise See Mapper#count. Details Since Source See 3.0.0 Container.js, line 13 Mapper#count Inherited From: Container#count Example Get the number of published blog posts import {Container} from 'js-data' import RethinkDBAdapter from 'js-data-rethinkdb' const store = new Container() store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }) store.defineMapper('post') store.count('post', { status: 'published' }).then((numPublished) =&gt; { console.log(numPublished) // e.g. 45 }) create(name, record, opts) TODO Method parameters: Name Type Argument Description name String Name of the Mapper to target. record Object Passed to Mapper#create. opts Object &lt;optional&gt; Passed to Mapper#create. See Mapper#create for more configuration options. Return value: Type Description Promise Unspecified Details Source Overrides DataStore.js, line 184 Container#create createMany(name, records, opts) TODO Method parameters: Name Type Argument Description name String Name of the Mapper to target. records Array Passed to Mapper#createMany. opts Object &lt;optional&gt; Passed to Mapper#createMany. See Mapper#createMany for more configuration options. Return value: Type Description Promise Unspecified Details Source Overrides DataStore.js, line 203 Container#createMany createRecord(name, props, opts) Wrapper for Mapper#createRecord. Note: This method does not interact with any adapter, and does not save any data. It only creates new objects in memory. Method parameters: Name Type Argument Description name String Name of the Mapper to target. props Object | Array.&lt;Object&gt; See Mapper#createRecord. opts Object &lt;optional&gt; See Mapper#createRecord. Return value: Type Description Promise See Mapper#createRecord. Details Since Source See 3.0.0 Container.js, line 95 Mapper#createRecord Inherited From: Container#createRecord Example Create empty unsaved record instance import {Container} from 'js-data' const store = new Container() store.defineMapper('post') const post = PostService.createRecord() dbg(name, args) Wrapper for Mapper#dbg. Method parameters: Name Type Argument Description name String Name of the Mapper to target. args * &lt;repeatable&gt; See Mapper#dbg. Details Since Source See 3.0.0 Container.js, line 117 Mapper#dbg Inherited From: Container#dbg defineMapper(name, opts) Create a new mapper and register it in this container. Method parameters: Name Type Argument Description name String Name under which to register the new Mapper. Mapper#name will be set to this value. opts Object &lt;optional&gt; Configuration options. Passed to Container#mapperClass when creating the new Mapper. Return value: Type Description Mapper Unspecified Details Since Source 3.0.0 Container.js, line 503 Inherited From: Container#defineMapper Example import {Container} from 'js-data' const store = new Container({ mapperDefaults: { foo: 'bar' } }) const userMapper = store.defineMapper('user') userMapper.foo // &quot;bar&quot; destroy(name, id, opts) TODO Method parameters: Name Type Argument Description name String Name of the Mapper to target. id String | Number Passed to Mapper#destroy. opts Object &lt;optional&gt; Passed to Mapper#destroy. See Mapper#destroy for more configuration options. Return value: Type Description Promise Unspecified Details Source Overrides DataStore.js, line 532 Container#destroy destroyAll(name, query, opts) TODO Method parameters: Name Type Argument Description name String Name of the Mapper to target. query Object &lt;optional&gt; Passed to Mapper#destroyAll. opts Object &lt;optional&gt; Passed to Mapper#destroyAll. See Mapper#destroyAll for more configuration options. Return value: Type Description Promise Unspecified Details Source Overrides DataStore.js, line 558 Container#destroyAll emit(event, args) Trigger an event on this Component. Method parameters: Name Type Argument Description event String Name of event to emit. args * &lt;optional&gt; &lt;repeatable&gt; Arguments to pass to any listeners. Details Since Source 3.0.0 Component.js, line 98 Inherited From: Component#emit Examples collection.on('foo', (msg) =&gt; { console.log(msg) // &quot;bar&quot; }) collection.emit('foo', 'bar') store.on('foo', (msg, val1, val2) =&gt; { console.log(msg, val1, val2) // &quot;bar&quot; &quot;beep&quot; &quot;boop&quot; }) store.emit('foo', 'bar', 'beep', 'boop') find(name, id, opts) TODO Method parameters: Name Type Argument Description name String Name of the Mapper to target. id String | Number Passed to Mapper#find. opts Object &lt;optional&gt; Passed to Mapper#find. Return value: Type Description Promise Unspecified Details Source Overrides DataStore.js, line 593 Container#find findAll(name, query, opts) TODO Method parameters: Name Type Argument Description name String Name of the Mapper to target. query Object &lt;optional&gt; Passed to Model.findAll. opts Object &lt;optional&gt; Passed to Model.findAll. Return value: Type Description Promise Unspecified Details Source Overrides DataStore.js, line 632 Container#findAll getAdapter(name) Return the registered adapter with the given name or the default adapter if no name is provided. Method parameters: Name Type Argument Description name String &lt;optional&gt; The name of the adapter to retrieve. Return value: Type Description Adapter The adapter. Details Since Source 3.0.0 Container.js, line 591 Inherited From: Container#getAdapter getAdapterName(opts) Return the name of a registered adapter based on the given name or options, or the name of the default adapter if no name provided. Method parameters: Name Type Argument Description opts Object | String &lt;optional&gt; The name of an adapter or options, if any. Return value: Type Description String The name of the adapter. Details Since Source 3.0.0 Container.js, line 609 Inherited From: Container#getAdapterName getAdapters() Return the registered adapters of this container. Return value: Type Description Adapter Unspecified Details Since Source 3.0.0 Container.js, line 626 Inherited From: Container#getAdapters getCollection(name) TODO Method parameters: Name Type Description name String Name of the LinkedCollection to retrieve. Return value: Type Description LinkedCollection Unspecified Details Source DataStore.js, line 673 getMapper(name) Return the mapper registered under the specified name. Method parameters: Name Type Description name String Mapper#name. Return value: Type Description Mapper Unspecified Details Since Source 3.0.0 Container.js, line 637 Inherited From: Container#getMapper Example import {Container} from 'js-data' const container = new Container() const userMapper = container.defineMapper('user') userMapper === container.getMapper('user') // true getSchema(name) Wrapper for Mapper#getSchema. Method parameters: Name Type Description name String Name of the Mapper to target. Return value: Type Description Schema See Mapper#getSchema. Details Since Source See 3.0.0 Container.js, line 224 Mapper#getSchema Inherited From: Container#getSchema is(name, record) Wrapper for Mapper#is. Method parameters: Name Type Description name String Name of the Mapper to target. record Object | Record See Mapper#is. Return value: Type Description Boolean See Mapper#is. Details Since Source See 3.0.0 Container.js, line 235 Mapper#is Inherited From: Container#is Example import {Container} from 'js-data' const store = new Container() store.defineMapper('post') const post = store.createRecord() console.log(store.is('post', post)) // true // Equivalent to what's above console.log(post instanceof store.getMapper('post').recordClass) // true log(name, args) Wrapper for Mapper#log. Method parameters: Name Type Argument Description name String Name of the Mapper to target. args * &lt;repeatable&gt; See Mapper#log. Details Since Source See 3.0.0 Container.js, line 257 Mapper#log Inherited From: Container#log off(event, listener) Remove an event listener from this Component. If no listener is provided, then all listeners for the specified event will be removed. If no event is specified then all listeners for all events will be removed. Method parameters: Name Type Argument Description event String &lt;optional&gt; Name of event to unsubsribe to. listener Function &lt;optional&gt; Listener to remove. Details Since Source 3.0.0 Component.js, line 79 Inherited From: Component#off Examples Remove a listener to a single event collection.off('add', handler) Remove all listeners to a single event record.off('change') Remove all listeners to all events store.off() on(event, listener, ctx) Register a new event listener on this DataStore. Proxy for Container#on. If an event was emitted by a Mapper or Collection in the DataStore, then the name of the Mapper or Collection will be prepended to the arugments passed to the provided event handler. Method parameters: Name Type Argument Description event String Name of event to subsribe to. listener Function Listener function to handle the event. ctx * &lt;optional&gt; Optional content in which to invoke the listener. Details Source Overrides DataStore.js, line 71 Container#on registerAdapter(name, adapter, opts) Register an adapter on this container under the given name. Adapters registered on a container are shared by all mappers in the container. Method parameters: Name Type Argument Description name String The name of the adapter to register. adapter Adapter The adapter to register. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description default Boolean &lt;optional&gt; false Whether to make the adapter the default adapter for all Mappers in this container. Details Since Source Tutorials 3.0.0 Container.js, line 659 Connecting to a data source Inherited From: Container#registerAdapter Example import {Container} from 'js-data' import HttpAdapter from 'js-data-http' const container = new Container() container.registerAdapter('http', new HttpAdapter, { default: true }) sum(name, field, query, opts) Wrapper for Mapper#sum. Method parameters: Name Type Argument Description name String Name of the Mapper to target. field String See Mapper#sum. query Object &lt;optional&gt; See Mapper#sum. opts Object &lt;optional&gt; See Mapper#sum. Return value: Type Description Promise See Mapper#sum. Details Since Source See 3.0.0 Container.js, line 268 Mapper#sum Inherited From: Container#sum Example import {Container} from 'js-data' import RethinkDBAdapter from 'js-data-rethinkdb' const store = new Container() store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }) store.defineMapper('purchase_order') store.sum('purchase_order', 'amount', { status: 'paid' }).then((amountPaid) =&gt; { console.log(amountPaid) // e.g. 451125.34 }) toJSON(name, records, opts) Wrapper for Mapper#toJSON. Method parameters: Name Type Argument Description name String Name of the Mapper to target. records Record | Array.&lt;Record&gt; See Mapper#toJSON. opts Object &lt;optional&gt; See Mapper#toJSON. Return value: Type Description Object | Array.&lt;Object&gt; See Mapper#toJSON. Details Since Source See 3.0.0 Container.js, line 293 Mapper#toJSON Inherited From: Container#toJSON Example import {Container} from 'js-data' import RethinkDBAdapter from 'js-data-rethinkdb' const store = new Container() store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }) store.defineMapper('person', { schema: { properties: { name: { type: 'string' }, id: { type: 'string' } } } }) const person = store.createRecord('person', { id: 1, name: 'John', foo: 'bar' }) console.log(store.toJSON('person', person)) // {&quot;id&quot;:1,&quot;name&quot;:&quot;John&quot;,&quot;foo&quot;:&quot;bar&quot;} console.log(store.toJSON('person', person), { strict: true }) // {&quot;id&quot;:1,&quot;name&quot;:&quot;John&quot;} update(name, id, record, opts) TODO Method parameters: Name Type Argument Description name String Name of the Mapper to target. id String | Number Passed to Mapper#update. record Object Passed to Mapper#update. opts Object &lt;optional&gt; Passed to Mapper#update. See Mapper#update for more configuration options. Return value: Type Description Promise Unspecified Details Source Overrides DataStore.js, line 758 Container#update updateAll(name, props, query, opts) TODO Method parameters: Name Type Argument Description name String Name of the Mapper to target. props Object Passed to Mapper#updateAll. query Object &lt;optional&gt; Passed to Mapper#updateAll. opts Object &lt;optional&gt; Passed to Mapper#updateAll. See Mapper#updateAll for more configuration options. Return value: Type Description Promise Unspecified Details Source Overrides DataStore.js, line 778 Container#updateAll updateMany(name, records, opts) TODO Method parameters: Name Type Argument Description name String Name of the Mapper to target. records Array.&lt;Object&gt; | Array.&lt;Record&gt; Passed to Mapper#updateMany. opts Object &lt;optional&gt; Passed to Mapper#updateMany. See Mapper#updateMany for more configuration options. Return value: Type Description Promise Unspecified Details Source Overrides DataStore.js, line 798 Container#updateMany validate(name, records, opts) Wrapper for Mapper#validate. Method parameters: Name Type Argument Description name String Name of the Mapper to target. records Array.&lt;Object&gt; | Array.&lt;Record&gt; See Mapper#validate. opts Object &lt;optional&gt; See Mapper#validate. Return value: Type Description Promise See Mapper#validate. Details Since Source See 3.0.0 Container.js, line 406 Mapper#validate Inherited From: Container#validate Example import {Container} from 'js-data' const store = new Container() store.defineMapper('post', { schema: { properties: { name: { type: 'string' }, id: { type: 'string' } } } }) let errors = store.validate('post', { name: 'John' }) console.log(errors) // undefined errors = store.validate('post', { name: 123 }) console.log(errors) // [{ expected: 'one of (string)', actual: 'number', path: 'name' }] × Search results Close api.js-data.io • js-data.io "},"LinkedCollection.html":{"id":"LinkedCollection.html","title":"Class: LinkedCollection","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentContainerDataStoreLinkedCollectionMapperQueryRecordSchema Class: LinkedCollection LinkedCollection new LinkedCollection(records, opts) TODO import {LinkedCollection} from 'js-data' Method parameters: Name Type Argument Description records Array &lt;optional&gt; Initial set of records to insert into the collection. See Collection. opts Object &lt;optional&gt; Configuration options. See Collection. Return value: Type Description Mapper Unspecified Details Source LinkedCollection.js, line 11 Extends This class extends the Collection class. Members _listeners Event listeners attached to this Component. Do not modify. Use Component#on and Component#off instead. Details Type Since Source Object 3.0.0 Component.js, line 7 Inherited From: Component#_listeners idAttribute Field to be used as the unique identifier for records in this collection. Defaults to &quot;id&quot; unless Collection#mapper is set, in which case this will default to Mapper#idAttribute. Details Type Default value Source String &quot;id&quot; Collection.js, line 9 Inherited From: Collection#idAttribute index The main index, which uses @{link Collection#recordId} as the key. Details Type Source Index Collection.js, line 125 Inherited From: Collection#index indexes Object that holds the secondary indexes of this collection. Details Type Source Object.&lt;string, Index&gt; Collection.js, line 139 Inherited From: Collection#indexes mapper Default Mapper for this collection. Optional. If a Mapper is provided, then the collection will use the Mapper#idAttribute setting, and will wrap records in Mapper#recordClass. Details Type Default value Source Mapper null Collection.js, line 84 Inherited From: Collection#mapper Example import {Collection, Mapper} from 'js-data' class MyMapperClass extends Mapper { foo () { return 'bar' } } const myMapper = new MyMapperClass() const collection = new Collection(null, { mapper: myMapper }) onConflict What to do when inserting a record into this Collection that shares a primary key with a record already in this Collection. Possible values: merge replace Merge: Recursively shallow copy properties from the new record onto the existing record. Replace: Shallow copy top-level properties from the new record onto the existing record. Any top-level own properties of the existing record that are not on the new record will be removed. Details Type Default value Source String &quot;merge&quot; Collection.js, line 20 Inherited From: Collection#onConflict Methods add(data, opts) Insert the provided record or records. If a record is already in the collection then the provided record will either merge with or replace the existing record based on the value of the onConflict option. The collection's secondary indexes will be updated as each record is visited. Method parameters: Name Type Argument Description data Object | Array.&lt;Object&gt; | Record | Array.&lt;Record&gt; The record or records to insert. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Description onConflict String &lt;optional&gt; What to do when a record is already in the collection. Possible values are merge or replace. Return value: Type Description Object | Array.&lt;Object&gt; | Record | Array.&lt;Record&gt; The added record or records. Details Since Source 3.0.0 Collection.js, line 168 Inherited From: Collection#add afterRemove(id, opts, record) Lifecycle hook called by Collection#remove. If this method returns a value then Collection#remove will return that same value. Method parameters: Name Type Description id String | Number The id argument passed to Collection#remove. opts Object The opts argument passed to Collection#remove. record Object The result that will be returned by Collection#remove. Details Since Source 3.0.0 Collection.js, line 278 Inherited From: Collection#afterRemove afterRemoveAll(query, opts, records) Lifecycle hook called by Collection#removeAll. If this method returns a value then Collection#removeAll will return that same value. Method parameters: Name Type Description query Object The query argument passed to Collection#removeAll. opts Object The opts argument passed to Collection#removeAll. records Object The result that will be returned by Collection#removeAll. Details Since Source 3.0.0 Collection.js, line 290 Inherited From: Collection#afterRemoveAll beforeAdd(records, opts) Lifecycle hook called by Collection#add. If this method returns a value then the records argument in Collection#add will be re-assigned to the returned value. Method parameters: Name Type Description records Object | Array.&lt;Object&gt; | Record | Array.&lt;Record&gt; The records argument passed to Collection#add. opts Object The opts argument passed to Collection#add. Details Since Source 3.0.0 Collection.js, line 303 Inherited From: Collection#beforeAdd beforeRemove(id, opts) Lifecycle hook called by Collection#remove. Method parameters: Name Type Description id String | Number The id argument passed to Collection#remove. opts Object The opts argument passed to Collection#remove. Details Since Source 3.0.0 Collection.js, line 315 Inherited From: Collection#beforeRemove beforeRemoveAll(query, opts) Lifecycle hook called by Collection#removeAll. Method parameters: Name Type Description query Object The query argument passed to Collection#removeAll. opts Object The opts argument passed to Collection#removeAll. Details Since Source 3.0.0 Collection.js, line 325 Inherited From: Collection#beforeRemoveAll between(leftKeys, rightKeys, opts) Find all records between two boundaries. Shortcut for collection.query().between(18, 30, { index: 'age' }).run() Method parameters: Name Type Argument Description leftKeys Array Keys defining the left boundary. rightKeys Array Keys defining the right boundary. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description index String &lt;optional&gt; Name of the secondary index to use in the query. If no index is specified, the main index is used. leftInclusive Boolean &lt;optional&gt; true Whether to include records on the left boundary. rightInclusive Boolean &lt;optional&gt; false Whether to include records on the left boundary. limit Boolean &lt;optional&gt; Limit the result to a certain number. offset Boolean &lt;optional&gt; The number of resulting records to skip. Return value: Type Description Array The result. Details Since Source 3.0.0 Collection.js, line 335 Inherited From: Collection#between Examples Get all users ages 18 to 30 const users = collection.between(18, 30, { index: 'age' }) Same as above const users = collection.between([18], [30], { index: 'age' }) createIndex(name, fieldList) Create a new secondary index on the contents of the collection. Method parameters: Name Type Argument Description name String The name of the new secondary index. fieldList Array.&lt;String&gt; &lt;optional&gt; Array of field names to use as the key or compound key of the new secondary index. If no fieldList is provided, then the name will also be the field that is used to index the collection. Return value: Type Description Collection A reference to itself for chaining. Details Since Source 3.0.0 Collection.js, line 365 Inherited From: Collection#createIndex Examples Index users by age collection.createIndex('age') Index users by status and role collection.createIndex('statusAndRole', ['status', 'role']) dbg(args) Log the provided values at the &quot;debug&quot; level. Method parameters: Name Type Argument Description args * &lt;optional&gt; &lt;repeatable&gt; Values to log. Details Since Source 3.0.0 Component.js, line 32 Inherited From: Component#dbg emit(event, args) Trigger an event on this Component. Method parameters: Name Type Argument Description event String Name of event to emit. args * &lt;optional&gt; &lt;repeatable&gt; Arguments to pass to any listeners. Details Since Source 3.0.0 Component.js, line 98 Inherited From: Component#emit Examples collection.on('foo', (msg) =&gt; { console.log(msg) // &quot;bar&quot; }) collection.emit('foo', 'bar') store.on('foo', (msg, val1, val2) =&gt; { console.log(msg, val1, val2) // &quot;bar&quot; &quot;beep&quot; &quot;boop&quot; }) store.emit('foo', 'bar', 'beep', 'boop') filter(queryOrFn, thisArg) Find the record or records that match the provided query or pass the provided filter function. Shortcut for collection.query().filter(queryOrFn[, thisArg]).run() Method parameters: Name Type Argument Default Description queryOrFn Object | Function &lt;optional&gt; {} Selection query or filter function. thisArg Object &lt;optional&gt; Context to which to bind queryOrFn if queryOrFn is a function. Return value: Type Description Array The result. Details Since Source 3.0.0 Collection.js, line 396 Inherited From: Collection#filter Examples Get the draft posts created less than three months const posts = collection.filter({ where: { status: { '==': 'draft' }, created_at_timestamp: { '&gt;=': (new Date().getTime() - (1000 * 60 * 60 * 24 * 30 * 3)) // 3 months ago } } }) Use a custom filter function const posts = collection.filter(function (post) { return post.isReady() }) forEach(forEachFn, thisArg) Iterate over all records. Method parameters: Name Type Argument Description forEachFn Function Iteration function. thisArg * &lt;optional&gt; Context to which to bind forEachFn. Return value: Type Description Array The result. Details Since Source 3.0.0 Collection.js, line 431 Inherited From: Collection#forEach Example collection.forEach(function (record) { // do something }) get(id) Get the record with the given id. Method parameters: Name Type Description id String | Number The primary key of the record to get. Return value: Type Description Object | Record The record with the given id. Details Since Source 3.0.0 Collection.js, line 449 Inherited From: Collection#get getAll(keyList, opts) Find the record or records that match the provided keyLists. Shortcut for collection.query().getAll(keyList1, keyList2, ...).run() Method parameters: Name Type Argument Description keyList Array &lt;optional&gt; &lt;repeatable&gt; Provide one or more keyLists, and all records matching each keyList will be retrieved. If no keyLists are provided, all records will be returned. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Description index String &lt;optional&gt; Name of the secondary index to use in the query. If no index is specified, the main index is used. Return value: Type Description Array The result. Details Since Source 3.0.0 Collection.js, line 462 Inherited From: Collection#getAll Examples Get the posts where &quot;status&quot; is &quot;draft&quot; or &quot;inReview&quot; const posts = collection.getAll('draft', 'inReview', { index: 'status' }) Same as above const posts = collection.getAll(['draft'], ['inReview'], { index: 'status' }) getIndex(name) Return the index with the given name. If no name is provided, return the main index. Throws an error if the specified index does not exist. Method parameters: Name Type Argument Description name String &lt;optional&gt; The name of the index to retrieve. Details Since Source 3.0.0 Collection.js, line 487 Inherited From: Collection#getIndex limit(num) Limit the result. Shortcut for collection.query().limit(maximumNumber).run() Method parameters: Name Type Description num Number The maximum number of records to keep in the result. Return value: Type Description Array The result. Details Since Source 3.0.0 Collection.js, line 503 Inherited From: Collection#limit Example const posts = collection.limit(10) log(level, args) Log the provided values. By default sends values to console[level]. Method parameters: Name Type Argument Description level String Log level args * &lt;optional&gt; &lt;repeatable&gt; Values to log. Details Since Source 3.0.0 Component.js, line 39 Inherited From: Component#log map(mapFn, thisArg) Apply a mapping function to all records. Method parameters: Name Type Argument Description mapFn Function Mapping function. thisArg * &lt;optional&gt; Context to which to bind mapFn. Return value: Type Description Array The result of the mapping. Details Since Source 3.0.0 Collection.js, line 520 Inherited From: Collection#map Example const names = collection.map(function (user) { return user.name }) mapCall(funcName) Return the result of calling the specified function on each record in this collection's main index. Method parameters: Name Type Description funcName String Name of function to call Return value: Type Description Array The result. Details Since Source 3.0.0 Collection.js, line 542 Inherited From: Collection#mapCall method(result, opts) Lifecycle hook called by Collection#add. If this method returns a value then Collection#add will return that same value. Method parameters: Name Type Description result Object | Array.&lt;Object&gt; | Record | Array.&lt;Record&gt; The record or records that were added to this Collection by Collection#add. opts Object The opts argument passed to Collection#add. Details Since Source 3.0.0 Collection.js, line 266 Inherited From: Collection#method off(event, listener) Remove an event listener from this Component. If no listener is provided, then all listeners for the specified event will be removed. If no event is specified then all listeners for all events will be removed. Method parameters: Name Type Argument Description event String &lt;optional&gt; Name of event to unsubsribe to. listener Function &lt;optional&gt; Listener to remove. Details Since Source 3.0.0 Component.js, line 79 Inherited From: Component#off Examples Remove a listener to a single event collection.off('add', handler) Remove all listeners to a single event record.off('change') Remove all listeners to all events store.off() on(event, listener, ctx) Register a new event listener on this Component. Method parameters: Name Type Argument Description event String Name of event to subsribe to. listener Function Listener function to handle the event. ctx * &lt;optional&gt; Optional content in which to invoke the listener. Details Since Source 3.0.0 Component.js, line 49 Inherited From: Component#on Examples Listen for all &quot;afterCreate&quot; events in a DataStore store.on('afterCreate', (mapperName, props, opts, result) =&gt; { console.log(mapperName) // &quot;post&quot; console.log(props.id) // undefined console.log(result.id) // 1234 }) store.create('post', { title: 'Modeling your data' }).then((post) =&gt; { console.log(post.id) // 1234 }) Listen for the &quot;add&quot; event on a collection collection.on('add', (records) =&gt; { console.log(records) // [...] }) Listen for &quot;change&quot; events on a record post.on('change', (record, changes) =&gt; { console.log(changes) // { changed: { title: 'Modeling your data' } } }) post.title = 'Modeling your data' query() Create a new query to be executed against the contents of the collection. The result will be all or a subset of the contents of the collection. Return value: Type Description Query New query object. Details Since Source 3.0.0 Collection.js, line 579 Inherited From: Collection#query Example Grab page 2 of users between ages 18 and 30 collection.query() .between(18, 30, { index: 'age' }) // between ages 18 and 30 .skip(10) // second page .limit(10) // page size .run() recordId(record) Return the primary key of the given, or if no record is provided, return the name of the field that holds the primary key of records in this Collection. Method parameters: Name Type Argument Description record Object | Record &lt;optional&gt; The record whose primary key is to be returned. Return value: Type Description String | Number Primary key or name of field that holds primary key. Details Since Source 3.0.0 Collection.js, line 560 Inherited From: Collection#recordId reduce(cb, initialValue) Reduce the data in the collection to a single value and return the result. Method parameters: Name Type Description cb Function Reduction callback. initialValue * Initial value of the reduction. Return value: Type Description * The result. Details Since Source 3.0.0 Collection.js, line 599 Inherited From: Collection#reduce Example const totalVotes = collection.reduce(function (prev, record) { return prev + record.upVotes + record.downVotes }, 0) remove(id, opts) Remove the record with the given id from this Collection. Method parameters: Name Type Argument Description id String | Number The primary key of the record to be removed. opts Object &lt;optional&gt; Configuration options. Return value: Type Description Object | Record The removed record, if any. Details Since Source 3.0.0 Collection.js, line 618 Inherited From: Collection#remove removeAll(query, opts) Remove the record selected by &quot;query&quot; from this collection. Method parameters: Name Type Argument Default Description query Object &lt;optional&gt; {} Selection query. Properties Name Type Argument Description where Object &lt;optional&gt; Filtering criteria. skip Number &lt;optional&gt; Number to skip. limit Number &lt;optional&gt; Number to limit to. orderBy Array &lt;optional&gt; Sorting criteria. opts Object &lt;optional&gt; Configuration options. Return value: Type Description Array.&lt;Object&gt; | Array.&lt;Record&gt; The removed records, if any. Details Since Source 3.0.0 Collection.js, line 649 Inherited From: Collection#removeAll skip(num) Skip a number of results. Shortcut for collection.query().skip(numberToSkip).run() Method parameters: Name Type Description num Number The number of records to skip. Return value: Type Description Array The result. Details Since Source 3.0.0 Collection.js, line 676 Inherited From: Collection#skip Example const posts = collection.skip(10) toJSON(opts) Return the plain JSON representation of all items in this collection. Assumes records in this collection have a toJSON method. Method parameters: Name Type Argument Description opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Description with Array.&lt;String&gt; &lt;optional&gt; Array of relation names or relation fields to include in the representation. Return value: Type Description Array The records. Details Since Source 3.0.0 Collection.js, line 693 Inherited From: Collection#toJSON updateIndex(record, opts) Update a record's position in a single index of this collection. See Collection#updateIndexes to update a record's position in all indexes at once. Method parameters: Name Type Argument Description record Object The record to update. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Description index String &lt;optional&gt; The index in which to update the record's position. If you don't specify an index then the record will be updated in the main index. Details Since Source 3.0.0 Collection.js, line 708 Inherited From: Collection#updateIndex updateIndexes(record, opts) TODO Method parameters: Name Type Argument Description record Object TODO opts Object &lt;optional&gt; Configuration options. Details Since Source 3.0.0 Collection.js, line 726 Inherited From: Collection#updateIndexes × Search results Close api.js-data.io • js-data.io "},"Mapper.html":{"id":"Mapper.html","title":"Class: Mapper","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentContainerDataStoreLinkedCollectionMapperQueryRecordSchema Class: Mapper Mapper new Mapper(opts) The core of JSData's ORM/ODM implementation. Given a minimum amout of meta information about a resource, a Mapper can perform generic CRUD operations against that resource. Apart from its configuration, a Mapper is stateless. The particulars of various persistence layers have been abstracted into adapters, which a Mapper uses to perform its operations. The term &quot;Mapper&quot; comes from the Data Mapper Pattern described in Martin Fowler's Patterns of Enterprise Application Architecture. A Data Mapper moves data between in-memory object instances and a relational or document-based database. JSData's Mapper can work with any persistence layer you can write an adapter for. (&quot;Model&quot; is a heavily overloaded term and is avoided in this documentation to prevent confusion.) Method parameters: Name Type Description opts Object Configuration options. Properties Name Type Argument Default Description applySchema Boolean &lt;optional&gt; true See Mapper#applySchema. debug Boolean &lt;optional&gt; false See Mapper#debug. defaultAdapter String &lt;optional&gt; http See Mapper#defaultAdapter. idAttribute String &lt;optional&gt; id See Mapper#idAttribute. name String See Mapper#name. notify Boolean &lt;optional&gt; See Mapper#notify. raw Boolean &lt;optional&gt; false See Mapper#raw. recordClass Function | Boolean &lt;optional&gt; See Mapper#recordClass. Return value: Type Description Mapper A new Mapper instance. Details Since Source Tutorials See 3.0.0 Mapper.js, line 178 Components of JSData: Mapper Modeling your data http://www.js-data.io/v3.0/docs/components-of-jsdata#mapper Examples Import and instantiate import {Mapper} from 'js-data' const UserService = new Mapper({ name: 'user' }) Define a Mapper using the Container component import {Container} from 'js-data' const store = new Container() store.defineMapper('user') Extends This class extends the Component class. Members _adapters Hash of registered adapters. Don't modify directly. Use Mapper#registerAdapter instead. Details Since Default value Source Tutorials 3.0.0 {} Mapper.js, line 93 Connecting to a data source _listeners Event listeners attached to this Component. Do not modify. Use Component#on and Component#off instead. Details Type Since Source Object 3.0.0 Component.js, line 7 Inherited From: Component#_listeners applySchema Whether to augment Mapper#recordClass with getter/setter property accessors according to the properties defined in Mapper#schema. This makes possible validation and change tracking on individual properties when using the dot (e.g. user.name = &quot;Bob&quot;) operator to modify a property. Details Type Since Default value Source Boolean 3.0.0 true Mapper.js, line 104 debug Whether to enable debug-level logs. Details Type Since Default value Source Boolean 3.0.0 false Mapper.js, line 118 defaultAdapter The name of the registered adapter that this Mapper should used by default. Details Type Since Default value Source Tutorials String 3.0.0 &quot;http&quot; Mapper.js, line 128 Connecting to a data source idAttribute The field used as the unique identifier on records handled by this Mapper. Details Type Since Default value Source String 3.0.0 id Mapper.js, line 139 lifecycleMethods The meta information describing this Mapper's available lifecycle methods. Do not modify. TODO: Improve documentation. Details Type Since Source Object 3.0.0 Mapper.js, line 294 name The name for this Mapper. This is the minimum amount of meta information required for a Mapper to be able to execute CRUD operations for a Resource. Details Type Since Source String 3.0.0 Mapper.js, line 327 notify Whether this Mapper should emit operational events. Details Type Since Default value Source Boolean 3.0.0 true Mapper.js, line 149 raw Whether Mapper#create, Mapper#createMany, Mapper#update, Mapper#updateAll, Mapper#updateMany, Mapper#find, Mapper#findAll, Mapper#destroy, Mapper#destroyAll, Mapper#count, and Mapper#sum should return a raw result object that contains both the instance data returned by the adapter and metadata about the operation. The default is to NOT return the result object, and instead return just the instance data. Details Type Since Default value Source Boolean 3.0.0 false Mapper.js, line 159 recordClass Set to false to force the Mapper to work with POJO objects only. Details Since Default value Source See 3.0.0 Record Mapper.js, line 241 Record Examples Use POJOs only. import {Mapper, Record} from 'js-data' const UserMapper = new Mapper({ recordClass: false }) UserMapper.recordClass // false const user = UserMapper#createRecord() user instanceof Record // false Set to a custom class to have records wrapped in your custom class. import {Mapper, Record} from 'js-data' // Custom class class User { constructor (props = {}) { for (var key in props) { if (props.hasOwnProperty(key)) { this[key] = props[key] } } } } const UserMapper = new Mapper({ recordClass: User }) UserMapper.recordClass // function User() {} const user = UserMapper#createRecord() user instanceof Record // false user instanceof User // true Extend the Record class. import {Mapper, Record} from 'js-data' // Custom class class User extends Record { constructor () { super(props) } } const UserMapper = new Mapper({ recordClass: User }) UserMapper.recordClass // function User() {} const user = UserMapper#createRecord() user instanceof Record // true user instanceof User // true schema This Mapper's Schema. Details Type Since Source See Schema 3.0.0 Mapper.js, line 308 Schema Methods &lt;static&gt; extend(props, classProps) Create a subclass of this Mapper. Method parameters: Name Type Argument Default Description props Object &lt;optional&gt; {} Properties to add to the prototype of the subclass. classProps Object &lt;optional&gt; {} Static properties to add to the subclass. Return value: Type Description Constructor Subclass of this Mapper. Details Since Source 3.0.0 Mapper.js, line 1805 Examples Extend the class in a cross-browser manner. import {Mapper} from 'js-data' const CustomMapperClass = Mapper.extend({ foo () { return 'bar' } }) const customMapper = new CustomMapperClass({ name: 'test' }) console.log(customMapper.foo()) // &quot;bar&quot; Extend the class using ES2015 class syntax. class CustomMapperClass extends Mapper { foo () { return 'bar' } } const customMapper = new CustomMapperClass({ name: 'test' }) console.log(customMapper.foo()) // &quot;bar&quot; afterCount(query, opts, result) Mapper lifecycle hook called by Mapper#count. If this method returns a promise then Mapper#count will wait for the promise to resolve before continuing. Method parameters: Name Type Description query Object The query argument passed to Mapper#count. opts Object The opts argument passed to Mapper#count. result * The result, if any. Details Since Source 3.0.0 Mapper.js, line 370 afterCreate(props, opts, result) Mapper lifecycle hook called by Mapper#create. If this method returns a promise then Mapper#create will wait for the promise to resolve before continuing. Method parameters: Name Type Description props Object The props argument passed to Mapper#create. opts Object The opts argument passed to Mapper#create. result * The result, if any. Details Since Source 3.0.0 Mapper.js, line 383 afterCreateMany(records, opts, result) Mapper lifecycle hook called by Mapper#createMany. If this method returns a promise then Mapper#createMany will wait for the promise to resolve before continuing. Method parameters: Name Type Description records Array The records argument passed to Mapper#createMany. opts Object The opts argument passed to Mapper#createMany. result * The result, if any. Details Since Source 3.0.0 Mapper.js, line 396 afterDestroy(id, opts, result) Mapper lifecycle hook called by Mapper#destroy. If this method returns a promise then Mapper#destroy will wait for the promise to resolve before continuing. Method parameters: Name Type Description id String | Number The id argument passed to Mapper#destroy. opts Object The opts argument passed to Mapper#destroy. result * The result, if any. Details Since Source 3.0.0 Mapper.js, line 409 afterDestroyAll(data, query, opts, result) Mapper lifecycle hook called by Mapper#destroyAll. If this method returns a promise then Mapper#destroyAll will wait for the promise to resolve before continuing. Method parameters: Name Type Description data * The data returned by the adapter. query query The query argument passed to Mapper#destroyAll. opts Object The opts argument passed to Mapper#destroyAll. result * The result, if any. Details Since Source 3.0.0 Mapper.js, line 422 afterFind(id, opts, result) Mapper lifecycle hook called by Mapper#find. If this method returns a promise then Mapper#find will wait for the promise to resolve before continuing. Method parameters: Name Type Description id String | Number The id argument passed to Mapper#find. opts Object The opts argument passed to Mapper#find. result * The result, if any. Details Since Source 3.0.0 Mapper.js, line 436 afterFindAll(query, opts, result) Mapper lifecycle hook called by Mapper#findAll. If this method returns a promise then Mapper#findAll will wait for the promise to resolve before continuing. Method parameters: Name Type Description query Object The query argument passed to Mapper#findAll. opts Object The opts argument passed to Mapper#findAll. result * The result, if any. Details Since Source 3.0.0 Mapper.js, line 449 afterSum(query, opts, result) Mapper lifecycle hook called by Mapper#sum. If this method returns a promise then Mapper#sum will wait for the promise to resolve before continuing. Method parameters: Name Type Description query Object The query argument passed to Mapper#sum. opts Object The opts argument passed to Mapper#sum. result * The result, if any. Details Since Source 3.0.0 Mapper.js, line 462 afterUpdate(id, props, opts, result) Mapper lifecycle hook called by Mapper#update. If this method returns a promise then Mapper#update will wait for the promise to resolve before continuing. Method parameters: Name Type Description id String | Number The id argument passed to Mapper#update. props props The props argument passed to Mapper#update. opts Object The opts argument passed to Mapper#update. result * The result, if any. Details Since Source 3.0.0 Mapper.js, line 475 afterUpdateAll(props, query, opts, result) Mapper lifecycle hook called by Mapper#updateAll. If this method returns a promise then Mapper#updateAll will wait for the promise to resolve before continuing. Method parameters: Name Type Description props Object The props argument passed to Mapper#updateAll. query Object The query argument passed to Mapper#updateAll. opts Object The opts argument passed to Mapper#updateAll. result * The result, if any. Details Since Source 3.0.0 Mapper.js, line 489 afterUpdateMany(records, opts, result) Mapper lifecycle hook called by Mapper#updateMany. If this method returns a promise then Mapper#updateMany will wait for the promise to resolve before continuing. Method parameters: Name Type Description records Array The records argument passed to Mapper#updateMany. opts Object The opts argument passed to Mapper#updateMany. result * The result, if any. Details Since Source 3.0.0 Mapper.js, line 503 beforeCount(query, opts) Mapper lifecycle hook called by Mapper#count. If this method returns a promise then Mapper#count will wait for the promise to resolve before continuing. Method parameters: Name Type Description query Object The query argument passed to Mapper#count. opts Object The opts argument passed to Mapper#count. Details Since Source 3.0.0 Mapper.js, line 540 beforeCreate(props, opts) Mapper lifecycle hook called by Mapper#create. If this method returns a promise then Mapper#create will wait for the promise to resolve before continuing. Method parameters: Name Type Description props Object The props argument passed to Mapper#create. opts Object The opts argument passed to Mapper#create. Details Since Source 3.0.0 Mapper.js, line 516 beforeCreateMany(records, opts) Mapper lifecycle hook called by Mapper#createMany. If this method returns a promise then Mapper#createMany will wait for the promise to resolve before continuing. Method parameters: Name Type Description records Array The records argument passed to Mapper#createMany. opts Object The opts argument passed to Mapper#createMany. Details Since Source 3.0.0 Mapper.js, line 528 beforeDestroy(id, opts) Mapper lifecycle hook called by Mapper#destroy. If this method returns a promise then Mapper#destroy will wait for the promise to resolve before continuing. Method parameters: Name Type Description id String | Number The id argument passed to Mapper#destroy. opts Object The opts argument passed to Mapper#destroy. Details Since Source 3.0.0 Mapper.js, line 552 beforeDestroyAll(query, opts) Mapper lifecycle hook called by Mapper#destroyAll. If this method returns a promise then Mapper#destroyAll will wait for the promise to resolve before continuing. Method parameters: Name Type Description query query The query argument passed to Mapper#destroyAll. opts Object The opts argument passed to Mapper#destroyAll. Details Since Source 3.0.0 Mapper.js, line 564 beforeFind(id, opts) Mappers lifecycle hook called by Mapper#find. If this method returns a promise then Mapper#find will wait for the promise to resolve before continuing. Method parameters: Name Type Description id String | Number The id argument passed to Mapper#find. opts Object The opts argument passed to Mapper#find. Details Since Source 3.0.0 Mapper.js, line 576 beforeFindAll(query, opts) Mapper lifecycle hook called by Mapper#findAll. If this method returns a promise then Mapper#findAll will wait for the promise to resolve before continuing. Method parameters: Name Type Description query Object The query argument passed to Mapper#findAll. opts Object The opts argument passed to Mapper#findAll. Details Since Source 3.0.0 Mapper.js, line 588 beforeSum(field, query, opts) Mapper lifecycle hook called by Mapper#sum. If this method returns a promise then Mapper#sum will wait for the promise to resolve before continuing. Method parameters: Name Type Description field String The field argument passed to Mapper#sum. query Object The query argument passed to Mapper#sum. opts Object The opts argument passed to Mapper#sum. Details Since Source 3.0.0 Mapper.js, line 600 beforeUpdate(id, props, opts) Mapper lifecycle hook called by Mapper#update. If this method returns a promise then Mapper#update will wait for the promise to resolve before continuing. Method parameters: Name Type Description id String | Number The id argument passed to Mapper#update. props props The props argument passed to Mapper#update. opts Object The opts argument passed to Mapper#update. Details Since Source 3.0.0 Mapper.js, line 613 beforeUpdateAll(props, query, opts) Mapper lifecycle hook called by Mapper#updateAll. If this method returns a promise then Mapper#updateAll will wait for the promise to resolve before continuing. Method parameters: Name Type Description props Object The props argument passed to Mapper#updateAll. query Object The query argument passed to Mapper#updateAll. opts Object The opts argument passed to Mapper#updateAll. Details Since Source 3.0.0 Mapper.js, line 626 beforeUpdateMany(records, opts) Mapper lifecycle hook called by Mapper#updateMany. If this method returns a promise then Mapper#updateMany will wait for the promise to resolve before continuing. Method parameters: Name Type Description records Array The records argument passed to Mapper#updateMany. opts Object The opts argument passed to Mapper#updateMany. Details Since Source 3.0.0 Mapper.js, line 639 belongsTo() Define a belongsTo relationship. Only useful if you're managing your Mappers manually and not using a Container or DataStore component. Details Since Source See 3.0.0 Mapper.js, line 684 http://www.js-data.io/v3.0/docs/relations Example PostService.belongsTo(UserService, { // post.user_id points to user.id foreignKey: 'user_id' // user records will be attached to post records at &quot;post.user&quot; localField: 'user' }) CommentService.belongsTo(UserService, { // comment.user_id points to user.id foreignKey: 'user_id' // user records will be attached to comment records at &quot;comment.user&quot; localField: 'user' }) CommentService.belongsTo(PostService, { // comment.post_id points to post.id foreignKey: 'post_id' // post records will be attached to comment records at &quot;comment.post&quot; localField: 'post' }) count(query, opts) Select records according to the query argument and return the count. Mapper#beforeCount will be called before calling the adapter. Mapper#afterCount will be called after calling the adapter. Method parameters: Name Type Argument Default Description query Object &lt;optional&gt; {} Selection query. See query. Properties Name Type Argument Description where Object &lt;optional&gt; See query.where. offset Number &lt;optional&gt; See query.offset. limit Number &lt;optional&gt; See query.limit. orderBy String | Array.&lt;Array&gt; &lt;optional&gt; See query.orderBy. opts Object &lt;optional&gt; Configuration options. Refer to the count method of whatever adapter you're using for more configuration options. Properties Name Type Argument Default Description adapter Boolean &lt;optional&gt; Mapper#defaultAdapter Name of the adapter to use. notify Boolean &lt;optional&gt; Mapper#notify See Mapper#notify. raw Boolean &lt;optional&gt; Mapper#raw See Mapper#raw. Return value: Type Description Promise Resolves with the count of the selected records. Details Since Source 3.0.0 Mapper.js, line 717 Example Get the number of published blog posts PostService.count({ status: 'published' }).then((numPublished) =&gt; { console.log(numPublished) // e.g. 45 }) create(props, opts) Create and save a new the record using the provided props. Mapper#beforeCreate will be called before calling the adapter. Mapper#afterCreate will be called after calling the adapter. Method parameters: Name Type Argument Description props Object The properties for the new record. opts Object &lt;optional&gt; Configuration options. Refer to the create method of whatever adapter you're using for more configuration options. Properties Name Type Argument Default Description adapter Boolean &lt;optional&gt; Mapper#defaultAdapter Name of the adapter to use. notify Boolean &lt;optional&gt; Mapper#notify See Mapper#notify. raw Boolean &lt;optional&gt; Mapper#raw See Mapper#raw. with Array.&lt;String&gt; &lt;optional&gt; [] Relations to create in a cascading create if props contains nested relations. NOT performed in a transaction. Each nested create will result in another Mapper#create or Mapper#createMany call. pass Array.&lt;String&gt; &lt;optional&gt; [] Relations to send to the adapter as part of the payload. Normally relations are not sent. Return value: Type Description Promise Resolves with the created record. Details Since Source 3.0.0 Mapper.js, line 747 Example Create and save a new blog post PostService.create({ title: 'Modeling your data', status: 'draft' }).then((post) =&gt; { console.log(post) // { id: 1234, status: 'draft', ... } }) createInstance(props, opts) Use Mapper#createRecord instead. Method parameters: Name Type Argument Description props Object | Array See Mapper#createRecord. opts Object &lt;optional&gt; See Mapper#createRecord. Return value: Type Description Object | Array See Mapper#createRecord. Details Since Source See 3.0.0 Mapper.js, line 877 Mapper#createRecord Deprecated: Yes createMany(records, opts) Given an array of records, batch create them via an adapter. Mapper#beforeCreateMany will be called before calling the adapter. Mapper#afterCreateMany will be called after calling the adapter. Method parameters: Name Type Argument Description records Array.&lt;Record&gt; Array of records to be created in one batch. opts Object &lt;optional&gt; Configuration options. Refer to the createMany method of whatever adapter you're using for more configuration options. Properties Name Type Argument Default Description adapter Boolean &lt;optional&gt; Mapper#defaultAdapter Name of the adapter to use. notify Boolean &lt;optional&gt; Mapper#notify See Mapper#notify. raw Boolean &lt;optional&gt; Mapper#raw See Mapper#raw. with Array.&lt;String&gt; &lt;optional&gt; [] Relations to create in a cascading create if records contains nested relations. NOT performed in a transaction. Each nested create will result in another Mapper#createMany call. pass Array.&lt;String&gt; &lt;optional&gt; [] Relations to send to the adapter as part of the payload. Normally relations are not sent. Return value: Type Description Promise Resolves with the created records. Details Since Source Tutorials 3.0.0 Mapper.js, line 891 Saving data Example Create and save several new blog posts PostService.createMany([{ title: 'Modeling your data', status: 'draft' }, { title: 'Reading data', status: 'draft' }]).then((posts) =&gt; { console.log(posts[0]) // { id: 1234, status: 'draft', ... } console.log(posts[1]) // { id: 1235, status: 'draft', ... } }) createRecord(props, opts) Create an unsaved, uncached instance of this Mapper's Mapper#recordClass. Returns props if props is already an instance of Mapper#recordClass. Note: This method does not interact with any adapter, and does not save any data. It only creates new objects in memory. Method parameters: Name Type Argument Description props Object | Array.&lt;Object&gt; The properties for the Record instance or an array of property objects for the Record instances. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description noValidate Boolean &lt;optional&gt; false Whether to skip validation when the Record instances are created. Return value: Type Description Record | Array.&lt;Record&gt; The Record instance or Record instances. Details Since Source 3.0.0 Mapper.js, line 1030 Examples Create empty unsaved record instance const post = PostService.createRecord() Create an unsaved record instance with inital properties const post = PostService.createRecord({ title: 'Modeling your data', status: 'draft' }) Create a record instance that corresponds to a saved record const post = PostService.createRecord({ // JSData thinks this record has been saved if it has a primary key id: 1234, title: 'Modeling your data', status: 'draft' }) Create record instances from an array const posts = PostService.createRecord([{ title: 'Modeling your data', status: 'draft' }, { title: 'Reading data', status: 'draft' }]) Records are validated by default import {Mapper} from 'js-data' const PostService = new Mapper({ name: 'post', schema: { properties: { title: { type: 'string' } } } }) try { const post = PostService.createRecord({ title: 1234, }) } catch (err) { console.log(err.errors) // [{ expected: 'one of (string)', actual: 'number', path: 'title' }] } Skip validation import {Mapper} from 'js-data' const PostService = new Mapper({ name: 'post', schema: { properties: { title: { type: 'string' } } } }) const post = PostService.createRecord({ title: 1234, }, { noValidate: true }) console.log(post.isValid()) // false crud(method, args) Lifecycle invocation method. TODO: Improve documentation for this method. Method parameters: Name Type Argument Description method String Name of the lifecycle method to invoke. args * &lt;repeatable&gt; Arguments to pass to the lifecycle method. Return value: Type Description Promise Unspecified Details Since Source 3.0.0 Mapper.js, line 1127 dbg(args) Log the provided values at the &quot;debug&quot; level. Method parameters: Name Type Argument Description args * &lt;optional&gt; &lt;repeatable&gt; Values to log. Details Since Source 3.0.0 Component.js, line 32 Inherited From: Component#dbg destroy(id, opts) Using an adapter, destroy the record with the given primary key. Mapper#beforeDestroy will be called before destroying the record. Mapper#afterDestroy will be called after destroying the record. Method parameters: Name Type Argument Description id String | Number The primary key of the record to destroy. opts Object &lt;optional&gt; Configuration options. Refer to the destroy method of whatever adapter you're using for more configuration options. Properties Name Type Argument Default Description adapter Boolean &lt;optional&gt; Mapper#defaultAdapter Name of the adapter to use. notify Boolean &lt;optional&gt; Mapper#notify See Mapper#notify. raw Boolean &lt;optional&gt; Mapper#raw See Mapper#raw. Return value: Type Description Promise Resolves when the record has been destroyed. Resolves even if no record was found to be destroyed. Details Since Source Tutorials 3.0.0 Mapper.js, line 1188 Saving data Examples Destroy a specific blog post PostService.destroy(1234).then(() =&gt; { // Blog post #1234 has been destroyed }) Get full response PostService.destroy(1234, { raw: true }).then((result) =&gt; { console.log(result.deleted) e.g. 1 console.log(...) // etc., more metadata can be found on the result }) destroyAll(query, opts) Destroy the records selected by query via an adapter. If no query is provided then all records will be destroyed. Mapper#beforeDestroyAll will be called before destroying the records. Mapper#afterDestroyAll will be called after destroying the records. Method parameters: Name Type Argument Default Description query Object &lt;optional&gt; {} Selection query. See query. Properties Name Type Argument Description where Object &lt;optional&gt; See query.where. offset Number &lt;optional&gt; See query.offset. limit Number &lt;optional&gt; See query.limit. orderBy String | Array.&lt;Array&gt; &lt;optional&gt; See query.orderBy. opts Object &lt;optional&gt; Configuration options. Refer to the destroyAll method of whatever adapter you're using for more configuration options. Properties Name Type Argument Default Description adapter Boolean &lt;optional&gt; Mapper#defaultAdapter Name of the adapter to use. notify Boolean &lt;optional&gt; Mapper#notify See Mapper#notify. raw Boolean &lt;optional&gt; Mapper#raw See Mapper#raw. Return value: Type Description Promise Resolves when the records have been destroyed. Resolves even if no records were found to be destroyed. Details Since Source Tutorials See 3.0.0 Mapper.js, line 1222 Saving data query Examples Destroy all blog posts PostService.destroyAll().then(() =&gt; { // All blog posts have been destroyed }) Destroy all &quot;draft&quot; blog posts PostService.destroyAll({ status: 'draft' }).then(() =&gt; { // All &quot;draft&quot; blog posts have been destroyed }) Get full response const query = null const options = { raw: true } PostService.destroyAll(query, options).then((result) =&gt; { console.log(result.deleted) e.g. 14 console.log(...) // etc., more metadata can be found on the result }) emit(event, args) Trigger an event on this Component. Method parameters: Name Type Argument Description event String Name of event to emit. args * &lt;optional&gt; &lt;repeatable&gt; Arguments to pass to any listeners. Details Since Source 3.0.0 Component.js, line 98 Inherited From: Component#emit Examples collection.on('foo', (msg) =&gt; { console.log(msg) // &quot;bar&quot; }) collection.emit('foo', 'bar') store.on('foo', (msg, val1, val2) =&gt; { console.log(msg, val1, val2) // &quot;bar&quot; &quot;beep&quot; &quot;boop&quot; }) store.emit('foo', 'bar', 'beep', 'boop') find(id, opts) Retrieve via an adapter the record with the given primary key. Mapper#beforeFind will be called before calling the adapter. Mapper#afterFind will be called after calling the adapter. Method parameters: Name Type Argument Description id String | Number The primary key of the record to retrieve. opts Object &lt;optional&gt; Configuration options. Refer to the find method of whatever adapter you're using for more configuration options. Properties Name Type Argument Default Description adapter Boolean &lt;optional&gt; Mapper#defaultAdapter Name of the adapter to use. notify Boolean &lt;optional&gt; Mapper#notify See Mapper#notify. raw Boolean &lt;optional&gt; Mapper#raw See Mapper#raw. with Array.&lt;String&gt; &lt;optional&gt; [] Relations to eager load in the request. Return value: Type Description Promise Resolves with the found record. Resolves with undefined if no record was found. Details Since Source Tutorials See 3.0.0 Mapper.js, line 1269 Reading data http://www.js-data.io/v3.0/docs/reading-data Examples PostService.find(1).then((post) =&gt; { console.log(post) // { id: 1, ...} }) Get full response PostService.find(1, { raw: true }).then((result) =&gt; { console.log(result.data) // { id: 1, ...} console.log(result.found) // 1 console.log(...) // etc., more metadata can be found on the result }) findAll(query, opts) Using the query argument, select records to retrieve via an adapter. Mapper#beforeFindAll will be called before calling the adapter. Mapper#afterFindAll will be called after calling the adapter. Method parameters: Name Type Argument Default Description query Object &lt;optional&gt; {} Selection query. See query. Properties Name Type Argument Description where Object &lt;optional&gt; See query.where. offset Number &lt;optional&gt; See query.offset. limit Number &lt;optional&gt; See query.limit. orderBy String | Array.&lt;Array&gt; &lt;optional&gt; See query.orderBy. opts Object &lt;optional&gt; Configuration options. Refer to the findAll method of whatever adapter you're using for more configuration options. Properties Name Type Argument Default Description adapter Boolean &lt;optional&gt; Mapper#defaultAdapter Name of the adapter to use. notify Boolean &lt;optional&gt; Mapper#notify See Mapper#notify. raw Boolean &lt;optional&gt; Mapper#raw See Mapper#raw. with Array.&lt;String&gt; &lt;optional&gt; [] Relations to eager load in the request. Return value: Type Description Promise Resolves with the found records, if any. Details Since Source Tutorials See 3.0.0 Mapper.js, line 1306 Reading data query Examples Find all &quot;published&quot; blog posts PostService.findAll({ status: 'published' }).then((posts) =&gt; { console.log(posts) // [{ id: 1, status: 'published', ...}, ...] }) Get full response PostService.findAll({ status: 'published' }, { raw: true }).then((result) =&gt; { console.log(result.data) // [{ id: 1, status: 'published', ...}, ...] console.log(result.found) // e.g. 13 console.log(...) // etc., more metadata can be found on the result }) getAdapter(name) Return the registered adapter with the given name or the default adapter if no name is provided. Method parameters: Name Type Argument Description name String &lt;optional&gt; The name of the adapter to retrieve. Return value: Type Description Adapter The adapter. Details Since Source Tutorials 3.0.0 Mapper.js, line 1346 Connecting to a data source getAdapterName(opts) Return the name of a registered adapter based on the given name or options, or the name of the default adapter if no name provided. Method parameters: Name Type Argument Description opts Object | String &lt;optional&gt; The name of an adapter or options, if any. Return value: Type Description String The name of the adapter. Details Since Source Tutorials 3.0.0 Mapper.js, line 1366 Connecting to a data source getAdapters() Get the object of registered adapters for this Mapper. Return value: Type Description Object Mapper#_adapters Details Since Source Tutorials 3.0.0 Mapper.js, line 1384 Connecting to a data source getSchema() Returns this Mapper's Schema. Return value: Type Description Schema This Mapper's Schema. Details Since Source See 3.0.0 Mapper.js, line 1396 Mapper#schema hasMany() Defines a hasMany relationship. Only useful if you're managing your Mappers manually and not using a Container or DataStore component. Details Since Source See 3.0.0 Mapper.js, line 1408 http://www.js-data.io/v3.0/docs/relations Example UserService.hasMany(PostService, { // post.user_id points to user.id foreignKey: 'user_id' // post records will be attached to user records at &quot;user.posts&quot; localField: 'posts' }) hasOne() Defines a hasOne relationship. Only useful if you're managing your Mappers manually and not using a Container or DataStore component. Details Since Source See 3.0.0 Mapper.js, line 1428 http://www.js-data.io/v3.0/docs/relations Example UserService.hasOne(ProfileService, { // profile.user_id points to user.id foreignKey: 'user_id' // profile records will be attached to user records at &quot;user.profile&quot; localField: 'profile' }) is(record) Return whether record is an instance of this Mapper's recordClass. Method parameters: Name Type Description record Object | Record The record to check. Return value: Type Description Boolean Whether record is an instance of this Mapper's Mapper#recordClass. Details Since Source 3.0.0 Mapper.js, line 1448 Example const post = PostService.createRecord() console.log(PostService.is(post)) // true // Equivalent to what's above console.log(post instanceof PostService.recordClass) // true log(level, args) Log the provided values. By default sends values to console[level]. Method parameters: Name Type Argument Description level String Log level args * &lt;optional&gt; &lt;repeatable&gt; Values to log. Details Since Source 3.0.0 Component.js, line 39 Inherited From: Component#log off(event, listener) Remove an event listener from this Component. If no listener is provided, then all listeners for the specified event will be removed. If no event is specified then all listeners for all events will be removed. Method parameters: Name Type Argument Description event String &lt;optional&gt; Name of event to unsubsribe to. listener Function &lt;optional&gt; Listener to remove. Details Since Source 3.0.0 Component.js, line 79 Inherited From: Component#off Examples Remove a listener to a single event collection.off('add', handler) Remove all listeners to a single event record.off('change') Remove all listeners to all events store.off() on(event, listener, ctx) Register a new event listener on this Component. Method parameters: Name Type Argument Description event String Name of event to subsribe to. listener Function Listener function to handle the event. ctx * &lt;optional&gt; Optional content in which to invoke the listener. Details Since Source 3.0.0 Component.js, line 49 Inherited From: Component#on Examples Listen for all &quot;afterCreate&quot; events in a DataStore store.on('afterCreate', (mapperName, props, opts, result) =&gt; { console.log(mapperName) // &quot;post&quot; console.log(props.id) // undefined console.log(result.id) // 1234 }) store.create('post', { title: 'Modeling your data' }).then((post) =&gt; { console.log(post.id) // 1234 }) Listen for the &quot;add&quot; event on a collection collection.on('add', (records) =&gt; { console.log(records) // [...] }) Listen for &quot;change&quot; events on a record post.on('change', (record, changes) =&gt; { console.log(changes) // { changed: { title: 'Modeling your data' } } }) post.title = 'Modeling your data' registerAdapter(name, adapter, opts) Register an adapter on this Mapper under the given name. Method parameters: Name Type Argument Description name String The name of the adapter to register. adapter Adapter The adapter to register. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description default Boolean &lt;optional&gt; false Whether to make the adapter the default adapter for this Mapper. Details Since Source Tutorials 3.0.0 Mapper.js, line 1469 Connecting to a data source sum(field, query, opts) Select records according to the query argument, and aggregate the sum value of the property specified by field. Mapper#beforeSum will be called before calling the adapter. Mapper#afterSum will be called after calling the adapter. Method parameters: Name Type Argument Default Description field String The field to sum. query Object &lt;optional&gt; {} Selection query. See query. Properties Name Type Argument Description where Object &lt;optional&gt; See query.where. offset Number &lt;optional&gt; See query.offset. limit Number &lt;optional&gt; See query.limit. orderBy String | Array.&lt;Array&gt; &lt;optional&gt; See query.orderBy. opts Object &lt;optional&gt; Configuration options. Refer to the sum method of whatever adapter you're using for more configuration options. Properties Name Type Argument Default Description adapter Boolean &lt;optional&gt; Mapper#defaultAdapter Name of the adapter to use. notify Boolean &lt;optional&gt; Mapper#notify See Mapper#notify. raw Boolean &lt;optional&gt; Mapper#raw See Mapper#raw. Return value: Type Description Promise Resolves with the aggregated sum. Details Since Source 3.0.0 Mapper.js, line 1491 Example PurchaseOrderService.sum('amount', { status: 'paid' }).then((amountPaid) =&gt; { console.log(amountPaid) // e.g. 451125.34 }) toJSON(records, opts) Return a plain object representation of the given record. Relations can be optionally be included. Non-schema properties can be excluded. Method parameters: Name Type Argument Description records Record | Array.&lt;Record&gt; Record or records from which to create a POJO representation. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Description strict Boolean &lt;optional&gt; Whether to include properties that are not defined in Mapper#schema. with Array.&lt;String&gt; &lt;optional&gt; Array of relation names or relation fields to include in the POJO representation. withAll Boolean &lt;optional&gt; Whether to simply include all relations in the representation. Overrides opts.with. Return value: Type Description Object | Array.&lt;Object&gt; POJO representation of the record or records. Details Since Source 3.0.0 Mapper.js, line 1523 Example import {Mapper, Schema} from 'js-data' const PersonService = new Mapper({ name: 'person', schema: { properties: { name: { type: 'string' }, id: { type: 'string' } } } }) const person = PersonService.createRecord({ id: 1, name: 'John', foo: 'bar' }) console.log(PersonService.toJSON(person)) // {&quot;id&quot;:1,&quot;name&quot;:&quot;John&quot;,&quot;foo&quot;:&quot;bar&quot;} console.log(PersonService.toJSON(person), { strict: true }) // {&quot;id&quot;:1,&quot;name&quot;:&quot;John&quot;} update(id, props, opts) Using an adapter, update the record with the primary key specified by the id argument. Mapper#beforeUpdate will be called before updating the record. Mapper#afterUpdate will be called after updating the record. Method parameters: Name Type Argument Description id String | Number The primary key of the record to update. props Object The update to apply to the record. opts Object &lt;optional&gt; Configuration options. Refer to the update method of whatever adapter you're using for more configuration options. Properties Name Type Argument Default Description adapter Boolean &lt;optional&gt; Mapper#defaultAdapter Name of the adapter to use. notify Boolean &lt;optional&gt; Mapper#notify See Mapper#notify. raw Boolean &lt;optional&gt; Mapper#raw See Mapper#raw. transaction. Return value: Type Description Promise Resolves with the updated record. Rejects if the record could not be found. Details Since Source Tutorials 3.0.0 Mapper.js, line 1610 Saving data Example Update a specific post PostService.update(1234, { status: 'published', published_at: new Date() }).then((post) =&gt; { console.log(post) // { id: 1234, status: 'published', ... } }) updateAll(props, query, opts) Using the query argument, perform the a single updated to the selected records. Mapper#beforeUpdateAll will be called before making the update. Mapper#afterUpdateAll will be called after making the update. Method parameters: Name Type Argument Default Description props Object Update to apply to selected records. query Object &lt;optional&gt; {} Selection query. See query. Properties Name Type Argument Description where Object &lt;optional&gt; See query.where. offset Number &lt;optional&gt; See query.offset. limit Number &lt;optional&gt; See query.limit. orderBy String | Array.&lt;Array&gt; &lt;optional&gt; See query.orderBy. opts Object &lt;optional&gt; Configuration options. Refer to the updateAll method of whatever adapter you're using for more configuration options. Properties Name Type Argument Default Description adapter Boolean &lt;optional&gt; Mapper#defaultAdapter Name of the adapter to use. notify Boolean &lt;optional&gt; Mapper#notify See Mapper#notify. raw Boolean &lt;optional&gt; Mapper#raw See Mapper#raw. Return value: Type Description Promise Resolves with the update records, if any. Details Since Source Tutorials See 3.0.0 Mapper.js, line 1644 Saving data query Example Turn all of John's blog posts into drafts. const update = { status: draft: published_at: null } const query = { userId: 1234 } PostService.updateAll(update, query).then((posts) =&gt; { console.log(posts) // [...] }) updateMany(records, opts) Given an array of updates, perform each of the updates via an adapter. Each &quot;update&quot; is a hash of properties with which to update an record. Each update must contain the primary key of the record to be updated. Mapper#beforeUpdateMany will be called before making the update. Mapper#afterUpdateMany will be called after making the update. Method parameters: Name Type Argument Description records Array.&lt;Record&gt; Array up record updates. opts Object &lt;optional&gt; Configuration options. Refer to the updateMany method of whatever adapter you're using for more configuration options. Properties Name Type Argument Default Description adapter Boolean &lt;optional&gt; Mapper#defaultAdapter Name of the adapter to use. notify Boolean &lt;optional&gt; Mapper#notify See Mapper#notify. raw Boolean &lt;optional&gt; Mapper#raw See Mapper#raw. Return value: Type Description Promise Resolves with the updated records. Rejects if any of the records could be found. Details Since Source Tutorials 3.0.0 Mapper.js, line 1680 Saving data Example PostService.updateMany([ { id: 1234, status: 'draft' }, { id: 2468, status: 'published', published_at: new Date() } ]).then((posts) =&gt; { console.log(posts) // [...] }) validate(record, opts) Validate the given record or records according to this Mapper's Schema. If there are no validation errors then the return value will be undefined. Method parameters: Name Type Argument Description record Object | Array.&lt;Object&gt; The record or records to validate. opts Object &lt;optional&gt; Configuration options. Passed to Schema#validate. Return value: Type Description Array.&lt;Object&gt; Array of errors or undefined if no errors. Details Since Source 3.0.0 Mapper.js, line 1713 Example import {Mapper, Schema} from 'js-data' const PersonSchema = new Schema({ properties: { name: { type: 'string' }, id: { type: 'string' } } }) const PersonService = new Mapper({ name: 'person', schema: PersonSchema }) let errors = PersonService.validate({ name: 'John' }) console.log(errors) // undefined errors = PersonService.validate({ name: 123 }) console.log(errors) // [{ expected: 'one of (string)', actual: 'number', path: 'name' }] wrap(data, opts) Method used to wrap data returned by an adapter with this Mapper's Mapper#recordClass. This method is used by all of a Mapper's CRUD methods. The provided implementation of this method assumes that the data passed to it is a record or records that need to be wrapped with Mapper#createRecord. Override with care. Provided implementation of Mapper#wrap: function (data, opts) { return this.createRecord(data, opts) } Method parameters: Name Type Argument Description data Object | Array.&lt;Object&gt; The record or records to be wrapped. opts Object &lt;optional&gt; Configuration options. Passed to Mapper#createRecord. Return value: Type Description Record | Array.&lt;Record&gt; The wrapped record or records. Details Since Source 3.0.0 Mapper.js, line 1763 Example Override to customize behavior const PostMapper = new Mapper({ name: 'post', wrap (data, opts) { const originalWrap = this.constructor.prototype.wrap // Let's say &quot;GET /post&quot; doesn't return JSON quite like JSData expects, // but the actual post records are nested under a &quot;posts&quot; field. So, // we override Mapper#wrap to handle this special case. if (opts.op === 'findAll') { return originalWrap.call(this, data.posts, opts) } // Otherwise perform original behavior return originalWrap.call(this, data, opts) } }) × Search results Close api.js-data.io • js-data.io "},"module-js-data.html":{"id":"module-js-data.html","title":"Module: js-data","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentContainerDataStoreLinkedCollectionMapperQueryRecordSchema Module: js-data Registered as js-data in NPM and Bower. Also available from CDN.JS and JSDelivr. Details Source index.js, line 1 Examples Install from NPM npm i --save js-data@beta Install from Bower bower i --save js-data@3.0.0-beta.1 Install from CDN.JS &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/js-data/3.0.0-beta.1/js-data.min.js&quot;&gt;&lt;/script&gt; Install from JSDelivr &lt;script src=&quot;https://cdn.jsdelivr.net/js-data/3.0.0-beta.1/js-data.min.js&quot;&gt;&lt;/script&gt; Load into your app via script tag &lt;script src=&quot;/path/to/js-data.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; console.log(JSData.version.full); // &quot;3.0.0-beta.1&quot; &lt;/script&gt; Load into your app via CommonJS var JSData = require('js-data'); Load into your app via ES2015 Modules import * as JSData from 'js-data'; Load into your app via AMD define('myApp', ['js-data'], function (JSData) { ... }) Members &lt;static&gt; Collection JSData's Collection class. Details Type Since Source Tutorials See Constructor 3.0.0 index.js, line 65 Components of JSData: Collection Collection Example import {Collection} from 'js-data' const collection = new Collection() &lt;static&gt; Component JSData's Component class. Most components in JSData extend this class. Details Type Since Source See Constructor 3.0.0 index.js, line 80 Component Example import {Component} from 'js-data' // Make a custom component. const MyComponent = Component.extend({ myMethod (someArg) { ... } }) &lt;static&gt; Container JSData's Container class. Defines and manages Mappers. Used in Node.js and in the browser, though in the browser you may want to use DataStore instead. Details Type Since Source Tutorials See Constructor 3.0.0 index.js, line 98 Components of JSData: Container Container Example import {Container} from 'js-data' const store = new Container() &lt;static&gt; DataStore JSData's DataStore class. Primarily for use in the browser. In Node.js you probably want to use Container instead. Details Type Since Source Tutorials See Constructor 3.0.0 index.js, line 115 Components of JSData: DataStore DataStore Example import {DataStore} from 'js-data' const store = new DataStore() &lt;static&gt; Index JSData's Index class, based on mindex. Details Type Since Source See Constructor 3.0.0 index.js, line 131 Index &lt;static&gt; LinkedCollection JSData's LinkedCollection class. Used by the DataStore component. If you need to create a collection manually, you should probably use the Collection class. Details Type Since Source See Constructor 3.0.0 index.js, line 141 DataStore LinkedCollection &lt;static&gt; Mapper JSData's Mapper class. The core of the ORM. Details Type Since Source Tutorials See Constructor 3.0.0 index.js, line 154 Modeling your data Components of JSData: Mapper Container Mapper Examples Recommended use import {Container} from 'js-data' const store = new Container() const UserService = store.defineMapper('user') Create Mapper manually import {Mapper} from 'js-data' const UserService = new Mapper({ name: 'user' }) &lt;static&gt; Query JSData's Query class. Used by the Collection component. Details Type Since Source See Constructor 3.0.0 index.js, line 176 Query &lt;static&gt; Record JSData's Record class. Details Type Since Source Tutorials See Constructor 3.0.0 index.js, line 186 Components of JSData: Record Record Example import {Container} from 'js-data' const store = new Container() const UserService = store.defineMapper('user') const user = UserService.createRecord() &lt;static&gt; Schema JSData's Schema class. Implements http://json-schema.org/draft-04. Details Type Since Source Tutorials See Constructor 3.0.0 index.js, line 203 Components of JSData: schema JSData's Schema Syntax Schema http://json-schema.org/ Example import {Container, Schema} from 'js-data' const userSchema = new Schema({ properties: { id: { type: 'string' }, name: { type: 'string' } } }) const store = new Container() const UserService = store.defineMapper('user', { schema: userSchema }) &lt;static&gt; utils JSData's utility methods. Details Type Since Source See Object 3.0.0 index.js, line 50 utils Properties: Name Type Description Promise Function See utils.Promise. Example import {utils} from 'js-data' console.log(utils.isString('foo')) // true &lt;static&gt; version Describes the version of this JSData object. Details Type Since Source Object 2.0.0 index.js, line 29 Properties: Name Type Description full String The full semver value. major Number The major version number. minor Number The minor version number. patch Number The patch version number. alpha String | Boolean The alpha version value, otherwise false if the current version is not alpha. beta String | Boolean The beta version value, otherwise false if the current version is not beta. Example console.log(JSData.version.full) // &quot;3.0.0-beta.1&quot; Methods &lt;static&gt; belongsTo(related, opts) TODO Method parameters: Name Type Description related Mapper The relation the target belongs to. opts Object Configuration options. Properties Name Type Description foreignKey String The field that holds the primary key of the related record. localField String The field that holds a reference to the related record object. Return value: Type Description Function Invocation function, which accepts the target as the only parameter. Details Source decorators.js, line 117 &lt;static&gt; hasMany(related, opts) TODO Method parameters: Name Type Description related Mapper The relation of which the target has many. opts Object Configuration options. Properties Name Type Argument Description foreignKey String &lt;optional&gt; The field that holds the primary key of the related record. localField String The field that holds a reference to the related record object. Return value: Type Description Function Invocation function, which accepts the target as the only parameter. Details Source decorators.js, line 139 &lt;static&gt; hasOne(related, opts) TODO Method parameters: Name Type Description related Mapper The relation of which the target has one. opts Object Configuration options. Properties Name Type Argument Description foreignKey String &lt;optional&gt; The field that holds the primary key of the related record. localField String The field that holds a reference to the related record object. Return value: Type Description Function Invocation function, which accepts the target as the only parameter. Details Source decorators.js, line 161 × Search results Close api.js-data.io • js-data.io "},"query.html":{"id":"query.html","title":"Namespace: query","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentContainerDataStoreLinkedCollectionMapperQueryRecordSchema Namespace: query query Selection query as defined by JSData's Query Syntax. Details Since Source Tutorials 3.0.0 Query.js, line 201 JSData's Query Syntax Properties: Name Type Argument Description limit Number &lt;optional&gt; See query.limit. offset Number &lt;optional&gt; See query.offset. orderBy String | Array.&lt;Array&gt; &lt;optional&gt; See query.orderBy. skip Number &lt;optional&gt; Alias for query.offset. sort String | Array.&lt;Array&gt; &lt;optional&gt; Alias for query.orderBy. where Object &lt;optional&gt; See query.where. Examples Empty &quot;findAll&quot; query store.findAll('post').then((posts) =&gt; { console.log(posts) // [...] }) Empty &quot;filter&quot; query const posts = store.filter('post') console.log(posts) // [...] Complex &quot;findAll&quot; query const PAGE_SIZE = 10 let currentPage = 3 // Retrieve a filtered page of blog posts store.findAll('post', { where: { status: { // WHERE status = 'published' '==': 'published' }, author: { // AND author IN ('bob', 'alice') 'in': ['bob', 'alice'], // OR author IN ('karen') '|in': ['karen'] } }, orderBy: [ // ORDER BY date_published DESC, ['date_published', 'DESC'], // ORDER BY title ASC ['title', 'ASC'] ], // LIMIT 10 limit: PAGE_SIZE, // SKIP 20 offset: PAGE_SIZE * (currentPage 1) }).then((posts) =&gt; { console.log(posts) // [...] }) Members &lt;static&gt; limit Maximum number of records to retrieve. Details Type Since Source See Number 3.0.0 Query.js, line 378 http://www.js-data.io/v3.0/docs/query-syntax Example Retrieve the first &quot;page&quot; of blog posts const PAGE_SIZE = 10 let currentPage = 1 PostService.findAll({ offset: PAGE_SIZE * (currentPage 1) limit: PAGE_SIZE }) &lt;static&gt; offset Number of records to skip. Details Type Since Source See Number 3.0.0 Query.js, line 356 http://www.js-data.io/v3.0/docs/query-syntax Example Retrieve the first &quot;page&quot; of blog posts const PAGE_SIZE = 10 let currentPage = 1 PostService.findAll({ offset: PAGE_SIZE * (currentPage 1) limit: PAGE_SIZE }) &lt;static&gt; orderBy Determines how records should be ordered in the result. Details Type Since Source See String | Array.&lt;Array&gt; 3.0.0 Query.js, line 333 http://www.js-data.io/v3.0/docs/query-syntax Example TODO &lt;static&gt; where Filtering criteria. Records that do not meet this criteria will be exluded from the result. Details Type Since Source See Object 3.0.0 Query.js, line 262 http://www.js-data.io/v3.0/docs/query-syntax Example TODO × Search results Close api.js-data.io • js-data.io "},"Query_.html":{"id":"Query_.html","title":"Class: Query","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentContainerDataStoreLinkedCollectionMapperQueryRecordSchema Class: Query Query new Query(collection) A class used by the Collection class to build queries to be executed against the collection's data. An instance of Query is returned by Collection#query. Query instances are typically short-lived, and you shouldn't have to create them yourself. Just use Collection#query. import {Query} from 'js-data' Method parameters: Name Type Description collection Collection The collection on which this query operates. Details Since Source 3.0.0 Query.js, line 25 Example const posts = store.query('post').filter({ status: 'draft' }).limit(2).run() Extends This class extends the Component class. Members &lt;static&gt; ops The filtering operators supported by Query#filter, and which are implemented by adapters (for the most part). Details Type Since Source Object 3.0.0 Query.js, line 630 Properties: Name Type Description == Function Equality operator. != Function Inequality operator. &gt; Function Greater than operator. &gt;= Function Greater than (inclusive) operator. &lt; Function Less than operator. Function Less than (inclusive) operator. isectEmpty Function Operator that asserts that the intersection between two arrays is empty. isectNotEmpty Function Operator that asserts that the intersection between two arrays is not empty. in Function Operator that asserts whether a value is in an array. notIn Function Operator that asserts whether a value is not in an array. contains Function Operator that asserts whether an array contains a value. notContains Function Operator that asserts whether an array does not contain a value. Examples Variant 1 const publishedPosts = store.filter('post', { status: 'published', limit: 2 }) Variant 2 const publishedPosts = store.filter('post', { where: { status: { '==': 'published' } }, limit: 2 }) Variant 3 const publishedPosts = store.query('post').filter({ status: 'published' }).limit(2).run() Variant 4 const publishedPosts = store.query('post').filter({ where: { status: { '==': 'published' } } }).limit(2).run() Multiple operators const myPublishedPosts = store.filter('post', { where: { status: { '==': 'published' }, user_id: { '==': currentUser.id } } }) _listeners Event listeners attached to this Component. Do not modify. Use Component#on and Component#off instead. Details Type Since Source Object 3.0.0 Component.js, line 7 Inherited From: Component#_listeners collection The Collection on which this query operates. Details Type Since Source Collection 3.0.0 Query.js, line 48 data The current data result of this query. Details Type Since Source Array 3.0.0 Query.js, line 57 Methods &lt;static&gt; extend(props, classProps) Create a subclass of this Query. Method parameters: Name Type Argument Default Description props Object &lt;optional&gt; {} Properties to add to the prototype of the subclass. classProps Object &lt;optional&gt; {} Static properties to add to the subclass. Return value: Type Description Constructor Subclass of this Query. Details Since Source 3.0.0 Query.js, line 744 Examples Extend the class in a cross-browser manner. import {Query} from 'js-data' const CustomQueryClass = Query.extend({ foo () { return 'bar' } }) const customQuery = new CustomQueryClass({ name: 'test' }) console.log(customQuery.foo()) // &quot;bar&quot; Extend the class using ES2015 class syntax. class CustomQueryClass extends Query { foo () { return 'bar' } } const customQuery = new CustomQueryClass({ name: 'test' }) console.log(customQuery.foo()) // &quot;bar&quot; between(leftKeys, rightKeys, opts) Find all entities between two boundaries. Method parameters: Name Type Argument Description leftKeys Array Keys defining the left boundary. rightKeys Array Keys defining the right boundary. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description index String &lt;optional&gt; Name of the secondary index to use in the query. If no index is specified, the main index is used. leftInclusive Boolean &lt;optional&gt; true Whether to include entities on the left boundary. rightInclusive Boolean &lt;optional&gt; false Whether to include entities on the left boundary. limit Boolean &lt;optional&gt; Limit the result to a certain number. offset Boolean &lt;optional&gt; The number of resulting entities to skip. Return value: Type Description Query A reference to itself for chaining. Details Since Source 3.0.0 Query.js, line 67 Examples Get the users ages 18 to 30. const users = query.between(18, 30, { index: 'age' }).run() Same as above. const users = query.between([18], [30], { index: 'age' }).run() compare(orderBy, index, a, b) The comparison function used by the Query class. Method parameters: Name Type Description orderBy Array An orderBy clause used for sorting and sub-sorting. index Number The index of the current orderBy clause being used. a * The first item in the comparison. b * The second item in the comparison. Return value: Type Description Number -1 if b should preceed a. 0 if a and b are equal. 1 if a should preceed b. Details Since Source 3.0.0 Query.js, line 101 dbg(args) Log the provided values at the &quot;debug&quot; level. Method parameters: Name Type Argument Description args * &lt;optional&gt; &lt;repeatable&gt; Values to log. Details Since Source 3.0.0 Component.js, line 32 Inherited From: Component#dbg emit(event, args) Trigger an event on this Component. Method parameters: Name Type Argument Description event String Name of event to emit. args * &lt;optional&gt; &lt;repeatable&gt; Arguments to pass to any listeners. Details Since Source 3.0.0 Component.js, line 98 Inherited From: Component#emit Examples collection.on('foo', (msg) =&gt; { console.log(msg) // &quot;bar&quot; }) collection.emit('foo', 'bar') store.on('foo', (msg, val1, val2) =&gt; { console.log(msg, val1, val2) // &quot;bar&quot; &quot;beep&quot; &quot;boop&quot; }) store.emit('foo', 'bar', 'beep', 'boop') evaluate(value, op, predicate) Predicate evaluation function used by the Query class. Method parameters: Name Type Description value * The value to evaluate. op String The operator to use in this evaluation. predicate * The predicate to use in this evaluation. Return value: Type Description Boolean Whether the value passed the evaluation or not. Details Since Source 3.0.0 Query.js, line 147 filter(queryOrFn, thisArg) Find the record or records that match the provided query or are accepted by the provided filter function. Method parameters: Name Type Argument Default Description queryOrFn Object | Function &lt;optional&gt; {} Selection query or filter function. thisArg Function &lt;optional&gt; Context to which to bind queryOrFn if queryOrFn is a function. Return value: Type Description Query A reference to itself for chaining. Details Since Source 3.0.0 Query.js, line 169 Examples Get the draft posts created less than three months const posts = query.filter({ where: { status: { '==': 'draft' }, created_at_timestamp: { '&gt;=': (new Date().getTime() (1000 * 60 * 60 * 24 * 30 * 3)) // 3 months ago } } }).run() Use a custom filter function const posts = query.filter(function (post) { return post.isReady() }).run() forEach(forEachFn, thisArg) Iterate over all entities. Method parameters: Name Type Argument Description forEachFn Function Iteration function. thisArg * &lt;optional&gt; Context to which to bind forEachFn. Return value: Type Description Query A reference to itself for chaining. Details Since Source 3.0.0 Query.js, line 403 get(keyList, opts) Find the entity or entities that match the provided key. Method parameters: Name Type Argument Description keyList Array Key(s) defining the entity to retrieve. If keyList is not an array (i.e. for a single-value key), it will be wrapped in an array. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Description string String &lt;optional&gt; Name of the secondary index to use in the query. If no index is specified, the main index is used. Return value: Type Description Query A reference to itself for chaining. Details Since Source 3.0.0 Query.js, line 417 Examples Get the entity whose primary key is 25. const entities = query.get(25).run() Same as above. const entities = query.get([25]).run() Get all users who are active and have the &quot;admin&quot; role. const activeAdmins = query.get(['active', 'admin'], { index: 'activityAndRoles' }).run() Get all entities that match a certain weather condition. const niceDays = query.get(['sunny', 'humid', 'calm'], { index: 'weatherConditions' }).run() getAll(keyList, opts) Find the entity or entities that match the provided keyLists. Method parameters: Name Type Argument Description keyList Array &lt;optional&gt; &lt;repeatable&gt; Provide one or more keyLists, and all entities matching each keyList will be retrieved. If no keyLists are provided, all entities will be returned. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Description index String &lt;optional&gt; Name of the secondary index to use in the query. If no index is specified, the main index is used. Return value: Type Description Query A reference to itself for chaining. Details Since Source 3.0.0 Query.js, line 464 Examples Get the posts where &quot;status&quot; is &quot;draft&quot; or &quot;inReview&quot;. const posts = query.getAll('draft', 'inReview', { index: 'status' }).run() Same as above. const posts = query.getAll(['draft'], ['inReview'], { index: 'status' }).run() getData() Return the current data result of this query. Return value: Type Description Array The data in this query. Details Since Source 3.0.0 Query.js, line 505 like(pattern, flags) Implementation used by the like operator. Takes a pattern and flags and returns a RegExp instance that can test strings. Method parameters: Name Type Description pattern String Testing pattern. flags String Flags for the regular expression. Return value: Type Description RegExp Regular expression for testing strings. Details Since Source 3.0.0 Query.js, line 520 limit(num) Limit the result. Method parameters: Name Type Description num Number The maximum number of entities to keep in the result. Return value: Type Description Query A reference to itself for chaining. Details Since Source 3.0.0 Query.js, line 534 Example Get only the first 10 draft posts. const posts = query.get('draft', { index: 'status' }).limit(10).run() log(level, args) Log the provided values. By default sends values to console[level]. Method parameters: Name Type Argument Description level String Log level args * &lt;optional&gt; &lt;repeatable&gt; Values to log. Details Since Source 3.0.0 Component.js, line 39 Inherited From: Component#log map(mapFn, thisArg) Apply a mapping function to the result data. Method parameters: Name Type Argument Description mapFn Function Mapping function. thisArg * &lt;optional&gt; Context to which to bind mapFn. Return value: Type Description Query A reference to itself for chaining. Details Since Source 3.0.0 Query.js, line 554 Example const ages = UserCollection.query().map((user) =&gt; { return user.age }).run() mapCall(funcName) Return the result of calling the specified function on each item in this collection's main index. Method parameters: Name Type Description funcName String Name of function to call Return value: Type Description Query A reference to itself for chaining. Details Since Source 3.0.0 Query.js, line 573 Example const stringAges = UserCollection.query().mapCall('toString').run() off(event, listener) Remove an event listener from this Component. If no listener is provided, then all listeners for the specified event will be removed. If no event is specified then all listeners for all events will be removed. Method parameters: Name Type Argument Description event String &lt;optional&gt; Name of event to unsubsribe to. listener Function &lt;optional&gt; Listener to remove. Details Since Source 3.0.0 Component.js, line 79 Inherited From: Component#off Examples Remove a listener to a single event collection.off('add', handler) Remove all listeners to a single event record.off('change') Remove all listeners to all events store.off() on(event, listener, ctx) Register a new event listener on this Component. Method parameters: Name Type Argument Description event String Name of event to subsribe to. listener Function Listener function to handle the event. ctx * &lt;optional&gt; Optional content in which to invoke the listener. Details Since Source 3.0.0 Component.js, line 49 Inherited From: Component#on Examples Listen for all &quot;afterCreate&quot; events in a DataStore store.on('afterCreate', (mapperName, props, opts, result) =&gt; { console.log(mapperName) // &quot;post&quot; console.log(props.id) // undefined console.log(result.id) // 1234 }) store.create('post', { title: 'Modeling your data' }).then((post) =&gt; { console.log(post.id) // 1234 }) Listen for the &quot;add&quot; event on a collection collection.on('add', (records) =&gt; { console.log(records) // [...] }) Listen for &quot;change&quot; events on a record post.on('change', (record, changes) =&gt; { console.log(changes) // { changed: { title: 'Modeling your data' } } }) post.title = 'Modeling your data' run() Complete the execution of the query and return the resulting data. Return value: Type Description Array The result of executing this query. Details Since Source 3.0.0 Query.js, line 593 skip(num) Skip a number of results. Method parameters: Name Type Description num Number The number of entities to skip. Return value: Type Description Query A reference to itself for chaining. Details Since Source 3.0.0 Query.js, line 606 Example Get all but the first 10 draft posts. const posts = query.get('draft', { index: 'status' }).skip(10).run() × Search results Close api.js-data.io • js-data.io "},"Record.html":{"id":"Record.html","title":"Class: Record","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentContainerDataStoreLinkedCollectionMapperQueryRecordSchema Class: Record Record new Record(props, opts) js-data's Record class. import {Record} from 'js-data' Method parameters: Name Type Argument Description props Object &lt;optional&gt; The initial properties of the new Record instance. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description noValidate Boolean &lt;optional&gt; false Whether to skip validation on the initial properties. Details Source Record.js, line 16 Extends This class extends the Component class. Members _listeners Event listeners attached to this Component. Do not modify. Use Component#on and Component#off instead. Details Type Since Source Object 3.0.0 Component.js, line 7 Inherited From: Component#_listeners Methods afterLoadRelations(relations, opts) TODO Method parameters: Name Type Description relations Array.&lt;String&gt; TODO opts Object TODO Details Source Record.js, line 71 beforeLoadRelations(relations, opts) TODO Method parameters: Name Type Description relations Array.&lt;String&gt; TODO opts Object TODO Details Source Record.js, line 81 changes(opts) Return changes to this record since it was instantiated or Record#commit was called. Method parameters: Name Type Argument Description opts &lt;optional&gt; Configuration options. Properties Name Type Argument Description equalsFn Function &lt;optional&gt; Equality function. Default uses ===. ignore Array &lt;optional&gt; Array of strings or RegExp of fields to ignore. Details Source Record.js, line 91 commit() TODO Details Source Record.js, line 107 dbg(args) Log the provided values at the &quot;debug&quot; level. Method parameters: Name Type Argument Description args * &lt;optional&gt; &lt;repeatable&gt; Values to log. Details Since Source 3.0.0 Component.js, line 32 Inherited From: Component#dbg destroy(opts) Call Mapper#destroy using this record's primary key. Method parameters: Name Type Argument Description opts Object &lt;optional&gt; Configuration options passed to Mapper#destroy. Return value: Type Description Promise The result of calling Mapper#destroy. Details Source Record.js, line 120 emit(event, args) Trigger an event on this Component. Method parameters: Name Type Argument Description event String Name of event to emit. args * &lt;optional&gt; &lt;repeatable&gt; Arguments to pass to any listeners. Details Since Source 3.0.0 Component.js, line 98 Inherited From: Component#emit Examples collection.on('foo', (msg) =&gt; { console.log(msg) // &quot;bar&quot; }) collection.emit('foo', 'bar') store.on('foo', (msg, val1, val2) =&gt; { console.log(msg, val1, val2) // &quot;bar&quot; &quot;beep&quot; &quot;boop&quot; }) store.emit('foo', 'bar', 'beep', 'boop') get(key) Return the value at the given path for this instance. Method parameters: Name Type Description key String Path of value to retrieve. Return value: Type Description * Value at path. Details Source Record.js, line 135 hasChanges(opts) Return whether this record has changed since it was instantiated or Record#commit was called. Method parameters: Name Type Argument Description opts &lt;optional&gt; Configuration options. Properties Name Type Argument Description equalsFn Function &lt;optional&gt; Equality function. Default uses ===. ignore Array &lt;optional&gt; Array of strings or RegExp of fields to ignore. Details Source Record.js, line 147 hashCode() TODO Details Source Record.js, line 163 loadRelations(relations, opts) TODO Method parameters: Name Type Argument Description relations Array.&lt;String&gt; &lt;optional&gt; TODO opts Object &lt;optional&gt; TODO Details Source Record.js, line 179 log(level, args) Log the provided values. By default sends values to console[level]. Method parameters: Name Type Argument Description level String Log level args * &lt;optional&gt; &lt;repeatable&gt; Values to log. Details Since Source 3.0.0 Component.js, line 39 Inherited From: Component#log off(event, listener) Remove an event listener from this Component. If no listener is provided, then all listeners for the specified event will be removed. If no event is specified then all listeners for all events will be removed. Method parameters: Name Type Argument Description event String &lt;optional&gt; Name of event to unsubsribe to. listener Function &lt;optional&gt; Listener to remove. Details Since Source 3.0.0 Component.js, line 79 Inherited From: Component#off Examples Remove a listener to a single event collection.off('add', handler) Remove all listeners to a single event record.off('change') Remove all listeners to all events store.off() on(event, listener, ctx) Register a new event listener on this Component. Method parameters: Name Type Argument Description event String Name of event to subsribe to. listener Function Listener function to handle the event. ctx * &lt;optional&gt; Optional content in which to invoke the listener. Details Since Source 3.0.0 Component.js, line 49 Inherited From: Component#on Examples Listen for all &quot;afterCreate&quot; events in a DataStore store.on('afterCreate', (mapperName, props, opts, result) =&gt; { console.log(mapperName) // &quot;post&quot; console.log(props.id) // undefined console.log(result.id) // 1234 }) store.create('post', { title: 'Modeling your data' }).then((post) =&gt; { console.log(post.id) // 1234 }) Listen for the &quot;add&quot; event on a collection collection.on('add', (records) =&gt; { console.log(records) // [...] }) Listen for &quot;change&quot; events on a record post.on('change', (record, changes) =&gt; { console.log(changes) // { changed: { title: 'Modeling your data' } } }) post.title = 'Modeling your data' previous(key) TODO Method parameters: Name Type Argument Description key String &lt;optional&gt; TODO Details Source Record.js, line 267 revert(opts) TODO Method parameters: Name Type Argument Description opts Object &lt;optional&gt; Configuration options. Details Source Record.js, line 282 save(opts, opts) Delegates to Mapper#create or Mapper#update. Method parameters: Name Type Argument Description opts Object &lt;optional&gt; Configuration options. See Mapper#create. opts &lt;optional&gt; Configuration options. Properties Name Type Argument Description changesOnly Boolean &lt;optional&gt; Equality function. Default uses ===. equalsFn Function &lt;optional&gt; Passed to Record#changes when changesOnly is true. ignore Array &lt;optional&gt; Passed to Record#changes when changesOnly is true. Return value: Type Description Promise The result of calling Mapper#create or Mapper#update. Details Source Record.js, line 308 set(key, value, opts) Set the value for a given key, or the values for the given keys if &quot;key&quot; is an object. Method parameters: Name Type Argument Description key String | Object Key to set or hash of key-value pairs to set. value * &lt;optional&gt; Value to set for the given key. opts Object &lt;optional&gt; Optional configuration. Properties Name Type Argument Default Description silent Boolean &lt;optional&gt; false Whether to trigger change events. Details Source Record.js, line 341 toJSON(opts) Return a plain object representation of this record. If the class from which this record was created has a mapper, then Mapper#toJSON will be called instead. Method parameters: Name Type Argument Description opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Description with Array.&lt;String&gt; &lt;optional&gt; Array of relation names or relation fields to include in the representation. Only available as an option if the class from which this record was created has a mapper. Return value: Type Description Object Plain object representation of this record. Details Source Record.js, line 369 unset(key, opts) Unset the value for a given key. Method parameters: Name Type Argument Description key String Key to unset. opts Object &lt;optional&gt; Optional configuration. Properties Name Type Argument Default Description silent Boolean &lt;optional&gt; false Whether to trigger change events. Details Source Record.js, line 395 × Search results Close api.js-data.io • js-data.io "},"Schema.html":{"id":"Schema.html","title":"Class: Schema","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentContainerDataStoreLinkedCollectionMapperQueryRecordSchema Class: Schema Schema new Schema(definition) js-data's Schema class. import {Schema} from 'js-data' Method parameters: Name Type Description definition Object Schema definition according to json-schema.org Details Source Schema.js, line 860 Extends This class extends the Component class. Members &lt;static&gt; typeGroupValidators TODO Details Type Source Object Schema.js, line 766 &lt;static&gt; types TODO Details Type Source Object Schema.js, line 6 &lt;static&gt; validationKeywords TODO Details Type Source Object Schema.js, line 91 _listeners Event listeners attached to this Component. Do not modify. Use Component#on and Component#off instead. Details Type Since Source Object 3.0.0 Component.js, line 7 Inherited From: Component#_listeners Methods &lt;static&gt; validate(value, schema, opts) TODO Method parameters: Name Type Argument Description value * TODO schema Object &lt;optional&gt; TODO opts Object &lt;optional&gt; Configuration options. Details Source Schema.js, line 584 dbg(args) Log the provided values at the &quot;debug&quot; level. Method parameters: Name Type Argument Description args * &lt;optional&gt; &lt;repeatable&gt; Values to log. Details Since Source 3.0.0 Component.js, line 32 Inherited From: Component#dbg emit(event, args) Trigger an event on this Component. Method parameters: Name Type Argument Description event String Name of event to emit. args * &lt;optional&gt; &lt;repeatable&gt; Arguments to pass to any listeners. Details Since Source 3.0.0 Component.js, line 98 Inherited From: Component#emit Examples collection.on('foo', (msg) =&gt; { console.log(msg) // &quot;bar&quot; }) collection.emit('foo', 'bar') store.on('foo', (msg, val1, val2) =&gt; { console.log(msg, val1, val2) // &quot;bar&quot; &quot;beep&quot; &quot;boop&quot; }) store.emit('foo', 'bar', 'beep', 'boop') log(level, args) Log the provided values. By default sends values to console[level]. Method parameters: Name Type Argument Description level String Log level args * &lt;optional&gt; &lt;repeatable&gt; Values to log. Details Since Source 3.0.0 Component.js, line 39 Inherited From: Component#log off(event, listener) Remove an event listener from this Component. If no listener is provided, then all listeners for the specified event will be removed. If no event is specified then all listeners for all events will be removed. Method parameters: Name Type Argument Description event String &lt;optional&gt; Name of event to unsubsribe to. listener Function &lt;optional&gt; Listener to remove. Details Since Source 3.0.0 Component.js, line 79 Inherited From: Component#off Examples Remove a listener to a single event collection.off('add', handler) Remove all listeners to a single event record.off('change') Remove all listeners to all events store.off() on(event, listener, ctx) Register a new event listener on this Component. Method parameters: Name Type Argument Description event String Name of event to subsribe to. listener Function Listener function to handle the event. ctx * &lt;optional&gt; Optional content in which to invoke the listener. Details Since Source 3.0.0 Component.js, line 49 Inherited From: Component#on Examples Listen for all &quot;afterCreate&quot; events in a DataStore store.on('afterCreate', (mapperName, props, opts, result) =&gt; { console.log(mapperName) // &quot;post&quot; console.log(props.id) // undefined console.log(result.id) // 1234 }) store.create('post', { title: 'Modeling your data' }).then((post) =&gt; { console.log(post.id) // 1234 }) Listen for the &quot;add&quot; event on a collection collection.on('add', (records) =&gt; { console.log(records) // [...] }) Listen for &quot;change&quot; events on a record post.on('change', (record, changes) =&gt; { console.log(changes) // { changed: { title: 'Modeling your data' } } }) post.title = 'Modeling your data' validate(value, opts) Validate the provided value against this schema. Method parameters: Name Type Argument Description value * Value to validate. opts Object &lt;optional&gt; Configuration options. Return value: Type Description Array | undefined Array of errors or undefined if valid. Details Source Schema.js, line 912 validate(target) This adds ES5 getters/setters to the target based on the &quot;properties&quot; in this Schema, which makes possible change tracking and validation on property assignment. Method parameters: Name Type Description target Object The prototype to which to apply this schema. Details Source Schema.js, line 888 × Search results Close api.js-data.io • js-data.io "},"utils.html":{"id":"utils.html","title":"Namespace: utils","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentContainerDataStoreLinkedCollectionMapperQueryRecordSchema Namespace: utils utils Utility methods used by JSData. Details Type Source Object utils.js, line 1 Example import {utils} from 'js-data' console.log(utils.isString('foo')) // true Members &lt;static&gt; addHiddenPropsToTarget Define hidden (non-enumerable), writable properties on target from the provided props. Details Source utils.js, line 167 &lt;static&gt; Promise Reference to the Promise constructor used by JSData. Defaults to window.Promise or global.Promise. Details Type Since Source Function 3.0.0 utils.js, line 68 Example Make JSData use a different `Promise` constructor import Promise from 'bluebird' import {utils} from 'js-data' utils.Promise = Promise Methods &lt;static&gt; diffObjects(a, b) Method parameters: Name Type Description a Object Base object. b Object Comparison object. Return value: Type Description Object Diff. Details Source utils.js, line 340 &lt;static&gt; equal() TODO Details Source utils.js, line 380 &lt;static&gt; err() TODO Details Source utils.js, line 387 × Search results Close api.js-data.io • js-data.io "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
