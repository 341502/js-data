<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"Collection.js.html":{"id":"Collection.js.html","title":"Source: Collection.js","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentDataStoreLinkedCollectionMapperQueryRecordSchema Source: Collection.js import utils from './utils' import Component from './Component' import Query from './Query' import Index from '../lib/mindex/index' const DOMAIN = 'Collection' const COLLECTION_DEFAULTS = { /** * Whether to call {@link Record#commit} on records that are added to the * collection and already exist in the collection. * * @name Collection#commitOnMerge * @type {boolean} * @default true */ commitOnMerge: true, /** * Field to be used as the unique identifier for records in this collection. * Defaults to `&quot;id&quot;` unless {@link Collection#mapper} is set, in which case * this will default to {@link Mapper#idAttribute}. * * @name Collection#idAttribute * @type {string} * @default &quot;id&quot; */ idAttribute: 'id', /** * What to do when inserting a record into this Collection that shares a * primary key with a record already in this Collection. * * Possible values: * merge * replace * * Merge: * * Recursively shallow copy properties from the new record onto the existing * record. * * Replace: * * Shallow copy top-level properties from the new record onto the existing * record. Any top-level own properties of the existing record that are _not_ * on the new record will be removed. * * @name Collection#onConflict * @type {string} * @default &quot;merge&quot; */ onConflict: 'merge' } /** * An ordered set of {@link Record} instances. * * @example * import {Collection, Record} from 'js-data' * const user1 = new Record({ id: 1 }) * const user2 = new Record({ id: 2 }) * const UserCollection = new Collection([user1, user2]) * UserCollection.get(1) === user1 // true * * @class Collection * @extends Component * @type {Function} * @param {Array} [records] Initial set of records to insert into the * collection. * @param {Object} [opts] Configuration options. * @param {string} [opts.commitOnMerge] See {@link Collection#commitOnMerge}. * @param {string} [opts.idAttribute] See {@link Collection#idAttribute}. * @param {string} [opts.onConflict=&quot;merge&quot;] See {@link Collection#onConflict}. * @param {string} [opts.mapper] See {@link Collection#mapper}. * @since 3.0.0 */ function Collection (records, opts) { utils.classCallCheck(this, Collection) Collection.__super__.call(this) if (records &amp;&amp; !utils.isArray(records)) { opts = records records = [] } if (utils.isString(opts)) { opts = { idAttribute: opts } } // Default values for arguments records || (records = []) opts || (opts = {}) /** * Default Mapper for this collection. Optional. If a Mapper is provided, then * the collection will use the {@link Mapper#idAttribute} setting, and will * wrap records in {@link Mapper#recordClass}. * * @example * import {Collection, Mapper} from 'js-data' * * class MyMapperClass extends Mapper { * foo () { return 'bar' } * } * const myMapper = new MyMapperClass() * const collection = new Collection(null, { mapper: myMapper }) * * @name Collection#mapper * @type {Mapper} * @default null * @since 3.0.0 */ Object.defineProperties(this, { mapper: { value: undefined, writable: true }, // Query class used by this collection queryClass: { value: undefined, writable: true } }) // Apply user-provided configuration utils.fillIn(this, opts) // Fill in any missing options with the defaults utils.fillIn(this, utils.copy(COLLECTION_DEFAULTS)) if (!this.queryClass) { this.queryClass = Query } const idAttribute = this.recordId() Object.defineProperties(this, { /** * The main index, which uses @{link Collection#recordId} as the key. * * @name Collection#index * @type {Index} */ index: { value: new Index([idAttribute], { hashCode (obj) { return utils.get(obj, idAttribute) } }) }, /** * Object that holds the secondary indexes of this collection. * * @name Collection#indexes * @type {Object.&lt;string, Index&gt;} */ indexes: { value: {} } }) // Insert initial data into the collection if (records) { this.add(records) } } export default Component.extend({ constructor: Collection, /** * Used to bind to events emitted by records in this Collection. * * @method Collection#_onRecordEvent * @since 3.0.0 * @private * @param {...*} [arg] Args passed to {@link Collection#emit}. */ _onRecordEvent (...args) { this.emit(...args) }, /** * Insert the provided record or records. * * If a record is already in the collection then the provided record will * either merge with or replace the existing record based on the value of the * `onConflict` option. * * The collection's secondary indexes will be updated as each record is * visited. * * @method Collection#add * @since 3.0.0 * @param {(Object|Object[]|Record|Record[])} data The record or records to insert. * @param {Object} [opts] Configuration options. * @param {boolean} [opts.commitOnMerge=true] See {@link Collection#commitOnMerge}. * @param {string} [opts.onConflict] See {@link Collection#onConflict}. * @returns {(Object|Object[]|Record|Record[])} The added record or records. */ add (records, opts) { // Default values for arguments opts || (opts = {}) // Fill in &quot;opts&quot; with the Collection's configuration utils._(opts, this) records = this.beforeAdd(records, opts) || records // Track whether just one record or an array of records is being inserted let singular = false const idAttribute = this.recordId() if (!utils.isArray(records)) { if (utils.isObject(records)) { records = [records] singular = true } else { throw utils.err(`${DOMAIN}#add`, 'records')(400, 'object or array', records) } } // Map the provided records to existing records. // New records will be inserted. If any records map to existing records, // they will be merged into the existing records according to the onConflict // option. records = records.map((record) =&gt; { let id = this.recordId(record) if (!utils.isSorN(id)) { throw utils.err(`${DOMAIN}#add`, `record.${idAttribute}`)(400, 'string or number', id) } // Grab existing record if there is one const existing = this.get(id) // If the currently visited record is just a reference to an existing // record, then there is nothing to be done. Exit early. if (record === existing) { return existing } if (existing) { // Here, the currently visited record corresponds to a record already // in the collection, so we need to merge them const onConflict = opts.onConflict || this.onConflict if (onConflict === 'merge') { utils.deepMixIn(existing, record) } else if (onConflict === 'replace') { utils.forOwn(existing, (value, key) =&gt; { if (key !== idAttribute &amp;&amp; !record.hasOwnProperty(key)) { delete existing[key] } }) existing.set(record) } else { throw utils.err(`${DOMAIN}#add`, 'opts.onConflict')(400, 'one of (merge, replace)', onConflict, true) } record = existing if (opts.commitOnMerge &amp;&amp; utils.isFunction(record.commit)) { record.commit() } // Update all indexes in the collection this.updateIndexes(record) } else { // Here, the currently visted record does not correspond to any record // in the collection, so (optionally) instantiate this record and insert // it into the collection record = this.mapper ? this.mapper.createRecord(record, opts) : record this.index.insertRecord(record) utils.forOwn(this.indexes, function (index, name) { index.insertRecord(record) }) if (record &amp;&amp; utils.isFunction(record.on)) { record.on('all', this._onRecordEvent, this) } } return record }) // Finally, return the inserted data const result = singular ? records[0] : records // TODO: Make this more performant (batch events?) this.emit('add', result) return this.afterAdd(records, opts, result) || result }, /** * Lifecycle hook called by {@link Collection#add}. If this method returns a * value then {@link Collection#add} will return that same value. * * @method Collection#method * @since 3.0.0 * @param {(Object|Object[]|Record|Record[])} result The record or records * that were added to this Collection by {@link Collection#add}. * @param {Object} opts The `opts` argument passed to {@link Collection#add}. */ afterAdd () {}, /** * Lifecycle hook called by {@link Collection#remove}. If this method returns * a value then {@link Collection#remove} will return that same value. * * @method Collection#afterRemove * @since 3.0.0 * @param {(string|number)} id The `id` argument passed to {@link Collection#remove}. * @param {Object} opts The `opts` argument passed to {@link Collection#remove}. * @param {Object} record The result that will be returned by {@link Collection#remove}. */ afterRemove () {}, /** * Lifecycle hook called by {@link Collection#removeAll}. If this method * returns a value then {@link Collection#removeAll} will return that same * value. * * @method Collection#afterRemoveAll * @since 3.0.0 * @param {Object} query The `query` argument passed to {@link Collection#removeAll}. * @param {Object} opts The `opts` argument passed to {@link Collection#removeAll}. * @param {Object} records The result that will be returned by {@link Collection#removeAll}. */ afterRemoveAll () {}, /** * Lifecycle hook called by {@link Collection#add}. If this method returns a * value then the `records` argument in {@link Collection#add} will be * re-assigned to the returned value. * * @method Collection#beforeAdd * @since 3.0.0 * @param {(Object|Object[]|Record|Record[])} records The `records` argument passed to {@link Collection#add}. * @param {Object} opts The `opts` argument passed to {@link Collection#add}. */ beforeAdd () {}, /** * Lifecycle hook called by {@link Collection#remove}. * * @method Collection#beforeRemove * @since 3.0.0 * @param {(string|number)} id The `id` argument passed to {@link Collection#remove}. * @param {Object} opts The `opts` argument passed to {@link Collection#remove}. */ beforeRemove () {}, /** * Lifecycle hook called by {@link Collection#removeAll}. * * @method Collection#beforeRemoveAll * @since 3.0.0 * @param {Object} query The `query` argument passed to {@link Collection#removeAll}. * @param {Object} opts The `opts` argument passed to {@link Collection#removeAll}. */ beforeRemoveAll () {}, /** * Find all records between two boundaries. * * Shortcut for `collection.query().between(18, 30, { index: 'age' }).run()` * * @example &lt;caption&gt;Get all users ages 18 to 30&lt;/caption&gt; * const users = collection.between(18, 30, { index: 'age' }) * * @example &lt;caption&gt;Same as above&lt;/caption&gt; * const users = collection.between([18], [30], { index: 'age' }) * * @method Collection#between * @since 3.0.0 * @param {Array} leftKeys Keys defining the left boundary. * @param {Array} rightKeys Keys defining the right boundary. * @param {Object} [opts] Configuration options. * @param {string} [opts.index] Name of the secondary index to use in the * query. If no index is specified, the main index is used. * @param {boolean} [opts.leftInclusive=true] Whether to include records * on the left boundary. * @param {boolean} [opts.rightInclusive=false] Whether to include records * on the left boundary. * @param {boolean} [opts.limit] Limit the result to a certain number. * @param {boolean} [opts.offset] The number of resulting records to skip. * @returns {Array} The result. */ between (leftKeys, rightKeys, opts) { return this.query().between(leftKeys, rightKeys, opts).run() }, /** * Create a new secondary index on the contents of the collection. * * @example &lt;caption&gt;Index users by age&lt;/caption&gt; * collection.createIndex('age') * * @example &lt;caption&gt;Index users by status and role&lt;/caption&gt; * collection.createIndex('statusAndRole', ['status', 'role']) * * @method Collection#createIndex * @since 3.0.0 * @param {string} name The name of the new secondary index. * @param {string[]} [fieldList] Array of field names to use as the key or * compound key of the new secondary index. If no fieldList is provided, then * the name will also be the field that is used to index the collection. * @returns {Collection} A reference to itself for chaining. */ createIndex (name, fieldList, opts) { if (utils.isString(name) &amp;&amp; fieldList === undefined) { fieldList = [name] } opts || (opts = {}) opts.hashCode || (opts.hashCode = (obj) =&gt; this.recordId(obj)) const index = this.indexes[name] = new Index(fieldList, opts) this.index.visitAll(index.insertRecord, index) return this }, /** * Find the record or records that match the provided query or pass the * provided filter function. * * Shortcut for `collection.query().filter(queryOrFn[, thisArg]).run()` * * @example &lt;caption&gt;Get the draft posts created less than three months&lt;/caption&gt; * const posts = collection.filter({ * where: { * status: { * '==': 'draft' * }, * created_at_timestamp: { * '&gt;=': (new Date().getTime() - (1000 * 60 * 60 * 24 * 30 * 3)) // 3 months ago * } * } * }) * * @example &lt;caption&gt;Use a custom filter function&lt;/caption&gt; * const posts = collection.filter(function (post) { * return post.isReady() * }) * * @method Collection#filter * @since 3.0.0 * @param {(Object|Function)} [queryOrFn={}] Selection query or filter * function. * @param {Object} [thisArg] Context to which to bind `queryOrFn` if * `queryOrFn` is a function. * @returns {Array} The result. */ filter (query, thisArg) { return this.query().filter(query, thisArg).run() }, /** * Iterate over all records. * * @example * collection.forEach(function (record) { * // do something * }) * * @method Collection#forEach * @since 3.0.0 * @param {Function} forEachFn Iteration function. * @param {*} [thisArg] Context to which to bind `forEachFn`. * @returns {Array} The result. */ forEach (cb, thisArg) { this.index.visitAll(cb, thisArg) }, /** * Get the record with the given id. * * @method Collection#get * @since 3.0.0 * @param {(string|number)} id The primary key of the record to get. * @returns {(Object|Record)} The record with the given id. */ get (id) { const instances = this.query().get(id).run() return instances.length ? instances[0] : undefined }, /** * Find the record or records that match the provided keyLists. * * Shortcut for `collection.query().getAll(keyList1, keyList2, ...).run()` * * @example &lt;caption&gt;Get the posts where &quot;status&quot; is &quot;draft&quot; or &quot;inReview&quot;&lt;/caption&gt; * const posts = collection.getAll('draft', 'inReview', { index: 'status' }) * * @example &lt;caption&gt;Same as above&lt;/caption&gt; * const posts = collection.getAll(['draft'], ['inReview'], { index: 'status' }) * * @method Collection#getAll * @since 3.0.0 * @param {...Array} [keyList] Provide one or more keyLists, and all * records matching each keyList will be retrieved. If no keyLists are * provided, all records will be returned. * @param {Object} [opts] Configuration options. * @param {string} [opts.index] Name of the secondary index to use in the * query. If no index is specified, the main index is used. * @returns {Array} The result. */ getAll (...args) { return this.query().getAll(...args).run() }, /** * Return the index with the given name. If no name is provided, return the * main index. Throws an error if the specified index does not exist. * * @method Collection#getIndex * @since 3.0.0 * @param {string} [name] The name of the index to retrieve. */ getIndex (name) { const index = name ? this.indexes[name] : this.index if (!index) { throw utils.err(`${DOMAIN}#getIndex`, name)(404, 'index') } return index }, /** * Limit the result. * * Shortcut for `collection.query().limit(maximumNumber).run()` * * @example * const posts = collection.limit(10) * * @method Collection#limit * @since 3.0.0 * @param {number} num The maximum number of records to keep in the result. * @returns {Array} The result. */ limit (num) { return this.query().limit(num).run() }, /** * Apply a mapping function to all records. * * @example * const names = collection.map(function (user) { * return user.name * }) * * @method Collection#map * @since 3.0.0 * @param {Function} mapFn Mapping function. * @param {*} [thisArg] Context to which to bind `mapFn`. * @returns {Array} The result of the mapping. */ map (cb, thisArg) { const data = [] this.index.visitAll(function (value) { data.push(cb.call(thisArg, value)) }) return data }, /** * Return the result of calling the specified function on each record in this * collection's main index. * * @method Collection#mapCall * @since 3.0.0 * @param {string} funcName Name of function to call * @parama {...*} [args] Remaining arguments to be passed to the function. * @returns {Array} The result. */ mapCall (funcName, ...args) { const data = [] this.index.visitAll(function (record) { data.push(record[funcName](...args)) }) return data }, /** * Return the primary key of the given, or if no record is provided, return the * name of the field that holds the primary key of records in this Collection. * * @method Collection#recordId * @since 3.0.0 * @param {(Object|Record)} [record] The record whose primary key is to be * returned. * @returns {(string|number)} Primary key or name of field that holds primary * key. */ recordId (record) { if (record) { return utils.get(record, this.recordId()) } return this.mapper ? this.mapper.idAttribute : this.idAttribute }, /** * Create a new query to be executed against the contents of the collection. * The result will be all or a subset of the contents of the collection. * * @example &lt;caption&gt;Grab page 2 of users between ages 18 and 30&lt;/caption&gt; * collection.query() * .between(18, 30, { index: 'age' }) // between ages 18 and 30 * .skip(10) // second page * .limit(10) // page size * .run() * * @method Collection#query * @since 3.0.0 * @returns {Query} New query object. */ query () { const Ctor = this.queryClass return new Ctor(this) }, /** * Reduce the data in the collection to a single value and return the result. * * @example * const totalVotes = collection.reduce(function (prev, record) { * return prev + record.upVotes + record.downVotes * }, 0) * * @method Collection#reduce * @since 3.0.0 * @param {Function} cb Reduction callback. * @param {*} initialValue Initial value of the reduction. * @returns {*} The result. */ reduce (cb, initialValue) { const data = this.getAll() return data.reduce(cb, initialValue) }, /** * Remove the record with the given id from this Collection. * * @method Collection#remove * @since 3.0.0 * @param {(string|number)} id The primary key of the record to be removed. * @param {Object} [opts] Configuration options. * @returns {Object|Record} The removed record, if any. */ remove (id, opts) { // Default values for arguments opts || (opts = {}) this.beforeRemove(id, opts) const record = this.get(id) // The record is in the collection, remove it if (record) { this.index.removeRecord(record) utils.forOwn(this.indexes, function (index, name) { index.removeRecord(record) }) if (record &amp;&amp; utils.isFunction(record.off)) { record.off('all', this._onRecordEvent, this) this.emit('remove', record) } } return this.afterRemove(id, opts, record) || record }, /** * Remove the record selected by &quot;query&quot; from this collection. * * @method Collection#removeAll * @since 3.0.0 * @param {Object} [query={}] Selection query. See {@link query}. * @param {Object} [query.where] See {@link query.where}. * @param {number} [query.offset] See {@link query.offset}. * @param {number} [query.limit] See {@link query.limit}. * @param {string|Array[]} [query.orderBy] See {@link query.orderBy}. * @param {Object} [opts] Configuration options. * @returns {(Object[]|Record[])} The removed records, if any. */ removeAll (query, opts) { // Default values for arguments opts || (opts = {}) this.beforeRemoveAll(query, opts) const records = this.filter(query) // Remove each selected record from the collection records.forEach((item) =&gt; { this.remove(this.recordId(item), opts) }) return this.afterRemoveAll(query, opts, records) || records }, /** * Skip a number of results. * * Shortcut for `collection.query().skip(numberToSkip).run()` * * @example * const posts = collection.skip(10) * * @method Collection#skip * @since 3.0.0 * @param {number} num The number of records to skip. * @returns {Array} The result. */ skip (num) { return this.query().skip(num).run() }, /** * Return the plain JSON representation of all items in this collection. * Assumes records in this collection have a toJSON method. * * @method Collection#toJSON * @since 3.0.0 * @param {Object} [opts] Configuration options. * @param {string[]} [opts.with] Array of relation names or relation fields * to include in the representation. * @returns {Array} The records. */ toJSON (opts) { return this.mapCall('toJSON', opts) }, /** * Update a record's position in a single index of this collection. See * {@link Collection#updateIndexes} to update a record's position in all * indexes at once. * * @method Collection#updateIndex * @since 3.0.0 * @param {Object} record The record to update. * @param {Object} [opts] Configuration options. * @param {string} [opts.index] The index in which to update the record's * position. If you don't specify an index then the record will be updated * in the main index. */ updateIndex (record, opts) { opts || (opts = {}) this.getIndex(opts.index).updateRecord(record) }, /** * TODO * * @method Collection#updateIndexes * @since 3.0.0 * @param {Object} record TODO * @param {Object} [opts] Configuration options. */ updateIndexes (record) { this.index.updateRecord(record) utils.forOwn(this.indexes, function (index, name) { index.updateRecord(record) }) } }) /** * Create a subclass of this Collection. * * @example &lt;caption&gt;Extend the class in a cross-browser manner.&lt;/caption&gt; * import {Collection} from 'js-data' * const CustomCollectionClass = Collection.extend({ * foo () { return 'bar' } * }) * const customCollection = new CustomCollectionClass() * console.log(customCollection.foo()) // &quot;bar&quot; * * @example &lt;caption&gt;Extend the class using ES2015 class syntax.&lt;/caption&gt; * class CustomCollectionClass extends Collection { * foo () { return 'bar' } * } * const customCollection = new CustomCollectionClass() * console.log(customCollection.foo()) // &quot;bar&quot; * * @method Collection.extend * @param {Object} [props={}] Properties to add to the prototype of the * subclass. * @param {Object} [classProps={}] Static properties to add to the subclass. * @returns {Constructor} Subclass of this Collection class. * @since 3.0.0 */ × Search results Close api.js-data.io • js-data.io "},"Component.js.html":{"id":"Component.js.html","title":"Source: Component.js","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentDataStoreLinkedCollectionMapperQueryRecordSchema Source: Component.js import utils from './utils' /** * @class Component */ export default function Component () { /** * Event listeners attached to this Component. __Do not modify.__ Use * {@link Component#on} and {@link Component#off} instead. * * @name Component#_listeners * @instance * @since 3.0.0 * @type {Object} */ Object.defineProperty(this, '_listeners', { value: {} }) } /** * Create a subclass of this component. * * @method Component.extend * @static * @param {Object} [props={}] Properties to add to the prototype of the * subclass. * @param {Object} [classProps={}] Static properties to add to the subclass. * @returns {Constructor} Subclass of this component. * @since 3.0.0 */ Component.extend = utils.extend /** * Log the provided values at the &quot;debug&quot; level. * * @method Component#dbg * @param {...*} [args] Values to log. * @since 3.0.0 */ /** * Log the provided values. By default sends values to `console[level]`. * * @method Component#log * @param {string} level Log level * @param {...*} [args] Values to log. * @since 3.0.0 */ utils.logify(Component.prototype) /** * Register a new event listener on this Component. * * @example &lt;caption&gt;Listen for all &quot;afterCreate&quot; events in a DataStore&lt;/caption&gt; * store.on('afterCreate', (mapperName, props, opts, result) =&gt; { * console.log(mapperName) // &quot;post&quot; * console.log(props.id) // undefined * console.log(result.id) // 1234 * }) * store.create('post', { title: 'Modeling your data' }).then((post) =&gt; { * console.log(post.id) // 1234 * }) * * @example &lt;caption&gt;Listen for the &quot;add&quot; event on a collection&lt;/caption&gt; * collection.on('add', (records) =&gt; { * console.log(records) // [...] * }) * * @example &lt;caption&gt;Listen for &quot;change&quot; events on a record&lt;/caption&gt; * post.on('change', (record, changes) =&gt; { * console.log(changes) // { changed: { title: 'Modeling your data' } } * }) * post.title = 'Modeling your data' * * @method Component#on * @param {string} event Name of event to subsribe to. * @param {Function} listener Listener function to handle the event. * @param {*} [ctx] Optional content in which to invoke the listener. * @since 3.0.0 */ /** * Remove an event listener from this Component. If no listener is provided, * then all listeners for the specified event will be removed. If no event is * specified then all listeners for all events will be removed. * * @example &lt;caption&gt;Remove a listener to a single event&lt;/caption&gt; * collection.off('add', handler) * * @example &lt;caption&gt;Remove all listeners to a single event&lt;/caption&gt; * record.off('change') * * @example &lt;caption&gt;Remove all listeners to all events&lt;/caption&gt; * store.off() * * @method Component#off * @param {string} [event] Name of event to unsubsribe to. * @param {Function} [listener] Listener to remove. * @since 3.0.0 */ /** * Trigger an event on this Component. * * @example * collection.on('foo', (msg) =&gt; { * console.log(msg) // &quot;bar&quot; * }) * collection.emit('foo', 'bar') * * @example * store.on('foo', (msg, val1, val2) =&gt; { * console.log(msg, val1, val2) // &quot;bar&quot; &quot;beep&quot; &quot;boop&quot; * }) * store.emit('foo', 'bar', 'beep', 'boop') * * @method Component#emit * @param {string} event Name of event to emit. * @param {...*} [args] Arguments to pass to any listeners. * @since 3.0.0 */ utils.eventify( Component.prototype, function () { return this._listeners }, function (value) { this._listeners = value } ) × Search results Close api.js-data.io • js-data.io "},"Container.js.html":{"id":"Container.js.html","title":"Source: Container.js","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentDataStoreLinkedCollectionMapperQueryRecordSchema Source: Container.js import utils from './utils' import Component from './Component' import Mapper from './Mapper' const DOMAIN = 'Container' export const proxiedMapperMethods = [ /** * Wrapper for {@link Mapper#count}. * * @example &lt;caption&gt;Get the number of published blog posts&lt;/caption&gt; * import {Container} from 'js-data' * import RethinkDBAdapter from 'js-data-rethinkdb' * const store = new Container() * store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }) * store.defineMapper('post') * * store.count('post', { status: 'published' }).then((numPublished) =&gt; { * console.log(numPublished) // e.g. 45 * }) * * @method Container#count * @param {string} name Name of the {@link Mapper} to target. * @param {Object} [query] See {@link Mapper#count}. * @param {Object} [opts] See {@link Mapper#count}. * @returns {Promise} See {@link Mapper#count}. * @see Mapper#count * @since 3.0.0 */ 'count', /** * Wrapper for {@link Mapper#create}. * * @example &lt;caption&gt;Create and save a new blog post&lt;/caption&gt; * import {Container} from 'js-data' * import RethinkDBAdapter from 'js-data-rethinkdb' * const store = new Container() * store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }) * store.defineMapper('post') * * store.create('post', { * title: 'Modeling your data', * status: 'draft' * }).then((post) =&gt; { * console.log(post) // { id: 1234, status: 'draft', ... } * }) * * @method Container#create * @param {string} name Name of the {@link Mapper} to target. * @param {Object} props See {@link Mapper#create}. * @param {Object} [opts] See {@link Mapper#create}. * @returns {Promise} See {@link Mapper#create}. * @see Mapper#create * @since 3.0.0 */ 'create', /** * Wrapper for {@link Mapper#createMany}. * * @example &lt;caption&gt;Create and save several new blog posts&lt;/caption&gt; * import {Container} from 'js-data' * import RethinkDBAdapter from 'js-data-rethinkdb' * const store = new Container() * store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }) * store.defineMapper('post') * * store.createMany('post', [{ * title: 'Modeling your data', * status: 'draft' * }, { * title: 'Reading data', * status: 'draft' * }]).then((posts) =&gt; { * console.log(posts[0]) // { id: 1234, status: 'draft', ... } * console.log(posts[1]) // { id: 1235, status: 'draft', ... } * }) * * @method Container#createMany * @param {string} name Name of the {@link Mapper} to target. * @param {Record[]} records See {@link Mapper#createMany}. * @param {Object} [opts] See {@link Mapper#createMany}. * @returns {Promise} See {@link Mapper#createMany}. * @see Mapper#createMany * @since 3.0.0 */ 'createMany', /** * Wrapper for {@link Mapper#createRecord}. * * __Note:__ This method does __not__ interact with any adapter, and does * __not__ save any data. It only creates new objects in memory. * * @example &lt;caption&gt;Create empty unsaved record instance&lt;/caption&gt; * import {Container} from 'js-data' * const store = new Container() * store.defineMapper('post') * const post = PostService.createRecord() * * @method Container#createRecord * @param {string} name Name of the {@link Mapper} to target. * @param {Object|Object[]} props See {@link Mapper#createRecord}. * @param {Object} [opts] See {@link Mapper#createRecord}. * @returns {Promise} See {@link Mapper#createRecord}. * @see Mapper#createRecord * @since 3.0.0 */ 'createRecord', /** * Wrapper for {@link Mapper#dbg}. * * @method Container#dbg * @param {string} name Name of the {@link Mapper} to target. * @param {...*} args See {@link Mapper#dbg}. * @see Mapper#dbg * @since 3.0.0 */ 'dbg', /** * Wrapper for {@link Mapper#destroy}. * * @example &lt;caption&gt;Destroy a specific blog post&lt;/caption&gt; * import {Container} from 'js-data' * import RethinkDBAdapter from 'js-data-rethinkdb' * const store = new Container() * store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }) * store.defineMapper('post') * * store.destroy('post', 1234).then(() =&gt; { * // Blog post #1234 has been destroyed * }) * * @method Container#destroy * @param {string} name Name of the {@link Mapper} to target. * @param {(string|number)} id See {@link Mapper#destroy}. * @param {Object} [opts] See {@link Mapper#destroy}. * @returns {Promise} See {@link Mapper#destroy}. * @see Mapper#destroy * @since 3.0.0 */ 'destroy', /** * Wrapper for {@link Mapper#destroyAll}. * * @example &lt;caption&gt;Destroy all &quot;draft&quot; blog posts&lt;/caption&gt; * import {Container} from 'js-data' * import RethinkDBAdapter from 'js-data-rethinkdb' * const store = new Container() * store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }) * store.defineMapper('post') * * store.destroyAll('post', { status: 'draft' }).then(() =&gt; { * // All &quot;draft&quot; blog posts have been destroyed * }) * * @method Container#destroyAll * @param {string} name Name of the {@link Mapper} to target. * @param {Object} [query] See {@link Mapper#destroyAll}. * @param {Object} [opts] See {@link Mapper#destroyAll}. * @returns {Promise} See {@link Mapper#destroyAll}. * @see Mapper#destroyAll * @since 3.0.0 */ 'destroyAll', /** * Wrapper for {@link Mapper#find}. * * @example * import {Container} from 'js-data' * import RethinkDBAdapter from 'js-data-rethinkdb' * const store = new Container() * store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }) * store.defineMapper('post') * * store.find('post', 1).then((post) =&gt; { * console.log(post) // { id: 1, ...} * }) * * @method Container#find * @param {string} name Name of the {@link Mapper} to target. * @param {(string|number)} id See {@link Mapper#find}. * @param {Object} [opts] See {@link Mapper#find}. * @returns {Promise} See {@link Mapper#find}. * @see Mapper#find * @since 3.0.0 */ 'find', /** * Wrapper for {@link Mapper#createRecord}. * * @example &lt;caption&gt;Find all &quot;published&quot; blog posts&lt;/caption&gt; * import {Container} from 'js-data' * import RethinkDBAdapter from 'js-data-rethinkdb' * const store = new Container() * store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }) * store.defineMapper('post') * * store.findAll('post', { status: 'published' }).then((posts) =&gt; { * console.log(posts) // [{ id: 1, ...}, ...] * }) * * @method Container#findAll * @param {string} name Name of the {@link Mapper} to target. * @param {Object} [query] See {@link Mapper#findAll}. * @param {Object} [opts] See {@link Mapper#findAll}. * @returns {Promise} See {@link Mapper#findAll}. * @see Mapper#findAll * @since 3.0.0 */ 'findAll', /** * Wrapper for {@link Mapper#getSchema}. * * @method Container#getSchema * @param {string} name Name of the {@link Mapper} to target. * @returns {Schema} See {@link Mapper#getSchema}. * @see Mapper#getSchema * @since 3.0.0 */ 'getSchema', /** * Wrapper for {@link Mapper#is}. * * @example * import {Container} from 'js-data' * const store = new Container() * store.defineMapper('post') * const post = store.createRecord() * * console.log(store.is('post', post)) // true * // Equivalent to what's above * console.log(post instanceof store.getMapper('post').recordClass) // true * * @method Container#is * @param {string} name Name of the {@link Mapper} to target. * @param {Object|Record} record See {@link Mapper#is}. * @returns {boolean} See {@link Mapper#is}. * @see Mapper#is * @since 3.0.0 */ 'is', /** * Wrapper for {@link Mapper#log}. * * @method Container#log * @param {string} name Name of the {@link Mapper} to target. * @param {...*} args See {@link Mapper#log}. * @see Mapper#log * @since 3.0.0 */ 'log', /** * Wrapper for {@link Mapper#sum}. * * @example * import {Container} from 'js-data' * import RethinkDBAdapter from 'js-data-rethinkdb' * const store = new Container() * store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }) * store.defineMapper('purchase_order') * * store.sum('purchase_order', 'amount', { status: 'paid' }).then((amountPaid) =&gt; { * console.log(amountPaid) // e.g. 451125.34 * }) * * @method Container#sum * @param {string} name Name of the {@link Mapper} to target. * @param {string} field See {@link Mapper#sum}. * @param {Object} [query] See {@link Mapper#sum}. * @param {Object} [opts] See {@link Mapper#sum}. * @returns {Promise} See {@link Mapper#sum}. * @see Mapper#sum * @since 3.0.0 */ 'sum', /** * Wrapper for {@link Mapper#toJSON}. * * @example * import {Container} from 'js-data' * import RethinkDBAdapter from 'js-data-rethinkdb' * const store = new Container() * store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }) * store.defineMapper('person', { * schema: { * properties: { * name: { type: 'string' }, * id: { type: 'string' } * } * } * }) * const person = store.createRecord('person', { id: 1, name: 'John', foo: 'bar' }) * console.log(store.toJSON('person', person)) // {&quot;id&quot;:1,&quot;name&quot;:&quot;John&quot;,&quot;foo&quot;:&quot;bar&quot;} * console.log(store.toJSON('person', person), { strict: true }) // {&quot;id&quot;:1,&quot;name&quot;:&quot;John&quot;} * * @method Container#toJSON * @param {string} name Name of the {@link Mapper} to target. * @param {Record|Record[]} records See {@link Mapper#toJSON}. * @param {Object} [opts] See {@link Mapper#toJSON}. * @returns {Object|Object[]} See {@link Mapper#toJSON}. * @see Mapper#toJSON * @since 3.0.0 */ 'toJSON', /** * Wrapper for {@link Mapper#update}. * * @example * import {Container} from 'js-data' * import RethinkDBAdapter from 'js-data-rethinkdb' * const store = new Container() * store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }) * store.defineMapper('post') * * store.update('post', 1234, { * status: 'published', * published_at: new Date() * }).then((post) =&gt; { * console.log(post) // { id: 1234, status: 'published', ... } * }) * * @method Container#update * @param {string} name Name of the {@link Mapper} to target. * @param {(string|number)} id See {@link Mapper#update}. * @param {Object} record See {@link Mapper#update}. * @param {Object} [opts] See {@link Mapper#update}. * @returns {Promise} See {@link Mapper#update}. * @see Mapper#update * @since 3.0.0 * @tutorial [&quot;http://www.js-data.io/v3.0/docs/saving-data&quot;,&quot;Saving data&quot;] */ 'update', /** * Wrapper for {@link Mapper#updateAll}. * * @example &lt;caption&gt;Turn all of John's blog posts into drafts.&lt;/caption&gt; * import {Container} from 'js-data' * import RethinkDBAdapter from 'js-data-rethinkdb' * const store = new Container() * store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }) * store.defineMapper('post') * * const update = { status: draft: published_at: null } * const query = { userId: 1234 } * store.updateAll('post', update, query).then((posts) =&gt; { * console.log(posts) // [...] * }) * * @method Container#updateAll * @param {string} name Name of the {@link Mapper} to target. * @param {Object} update See {@link Mapper#updateAll}. * @param {Object} [query] See {@link Mapper#updateAll}. * @param {Object} [opts] See {@link Mapper#updateAll}. * @returns {Promise} See {@link Mapper#updateAll}. * @see Mapper#updateAll * @since 3.0.0 */ 'updateAll', /** * Wrapper for {@link Mapper#updateMany}. * * @example * import {Container} from 'js-data' * import RethinkDBAdapter from 'js-data-rethinkdb' * const store = new Container() * store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }) * store.defineMapper('post') * * store.updateMany('post', [ * { id: 1234, status: 'draft' }, * { id: 2468, status: 'published', published_at: new Date() } * ]).then((posts) =&gt; { * console.log(posts) // [...] * }) * * @method Container#updateMany * @param {string} name Name of the {@link Mapper} to target. * @param {(Object[]|Record[])} records See {@link Mapper#updateMany}. * @param {Object} [opts] See {@link Mapper#updateMany}. * @returns {Promise} See {@link Mapper#updateMany}. * @see Mapper#updateMany * @since 3.0.0 */ 'updateMany', /** * Wrapper for {@link Mapper#validate}. * * @example * import {Container} from 'js-data' * const store = new Container() * store.defineMapper('post', { * schema: { * properties: { * name: { type: 'string' }, * id: { type: 'string' } * } * } * }) * let errors = store.validate('post', { name: 'John' }) * console.log(errors) // undefined * errors = store.validate('post', { name: 123 }) * console.log(errors) // [{ expected: 'one of (string)', actual: 'number', path: 'name' }] * * @method Container#validate * @param {string} name Name of the {@link Mapper} to target. * @param {(Object[]|Record[])} records See {@link Mapper#validate}. * @param {Object} [opts] See {@link Mapper#validate}. * @returns {Promise} See {@link Mapper#validate}. * @see Mapper#validate * @since 3.0.0 */ 'validate' ] export function Container (opts) { utils.classCallCheck(this, Container) Container.__super__.call(this) opts || (opts = {}) Object.defineProperties(this, { // Holds the adapters, shared by all mappers in this container _adapters: { value: {} }, // The the mappers in this container _mappers: { value: {} } }) // Apply options provided by the user utils.fillIn(this, opts) /** * Defaults options to pass to {@link Container#mapperClass} when creating a * new {@link Mapper}. * * @default {} * @name Container#mapperDefaults * @since 3.0.0 * @type {Object} */ this.mapperDefaults = this.mapperDefaults || {} /** * Constructor function to use in {@link Container#defineMapper} to create a * new mapper. * * {@link Mapper} * @name Container#mapperClass * @since 3.0.0 * @type {Constructor} */ this.mapperClass = this.mapperClass || Mapper } const props = { constructor: Container, /** * Register a new event listener on this Container. * * Proxy for {@link Component#on}. If an event was emitted by a Mapper in the * Container, then the name of the Mapper will be prepended to the arugments * passed to the listener. * * @method Container#on * @param {string} event Name of event to subsribe to. * @param {Function} listener Listener function to handle the event. * @param {*} [ctx] Optional content in which to invoke the listener. * @since 3.0.0 */ /** * Used to bind to events emitted by mappers in this container. * * @method Container#_onMapperEvent * @param {string} name Name of the mapper that emitted the event. * @param {...*} [args] Args See {@link Mapper#emit}. * @private * @since 3.0.0 */ _onMapperEvent (name, ...args) { const type = args.shift() this.emit(type, name, ...args) }, /** * Return a container scoped to a particular mapper. * * @example * import {Container} from 'js-data' * const store = new Container() * const UserMapper = store.defineMapper('user') * const UserStore = store.as('user') * * const user1 = store.createRecord('user', { name: 'John' }) * const user2 = UserStore.createRecord({ name: 'John' }) * const user3 = UserMapper.createRecord({ name: 'John' }) * assert.deepEqual(user1, user2) * assert.deepEqual(user2, user3) * assert.deepEqual(user1, user3) * * @method Container#as * @param {string} name Name of the {@link Mapper}. * @returns {Object} A container scoped to a particular mapper. * @since 3.0.0 */ as (name) { const props = {} proxiedMapperMethods.forEach(function (method) { props[method] = { writable: true, value: function (...args) { return this.getMapper(name)[method](...args) } } }) props.getMapper = { writable: true, value: () =&gt; this.getMapper(name) } return Object.create(this, props) }, /** * Create a new mapper and register it in this container. * * @example * import {Container} from 'js-data' * const store = new Container({ * mapperDefaults: { foo: 'bar' } * }) * // Container#defineMapper returns a direct reference to the newly created * // Mapper. * const UserMapper = store.defineMapper('user') * UserMapper === store.getMapper('user') // true * UserMapper === store.as('user').getMapper() // true * UserMapper.foo // &quot;bar&quot; * * @method Container#defineMapper * @param {string} name Name under which to register the new {@link Mapper}. * {@link Mapper#name} will be set to this value. * @param {Object} [opts] Configuration options. Passed to * {@link Container#mapperClass} when creating the new {@link Mapper}. * @returns {Mapper} The newly created instance of {@link Mapper}. * @see Container#as * @since 3.0.0 */ defineMapper (name, opts) { // For backwards compatibility with defineResource if (utils.isObject(name)) { opts = name name = opts.name } if (!utils.isString(name)) { throw utils.err(`${DOMAIN}#defineMapper`, 'name')(400, 'string', name) } // Default values for arguments opts || (opts = {}) // Set Mapper#name opts.name = name opts.relations || (opts.relations = {}) // Check if the user is overriding the datastore's default mapperClass const mapperClass = opts.mapperClass || this.mapperClass delete opts.mapperClass // Apply the datastore's defaults to the options going into the mapper utils.fillIn(opts, this.mapperDefaults) // Instantiate a mapper const mapper = this._mappers[name] = new mapperClass(opts) // eslint-disable-line mapper.relations || (mapper.relations = {}) // Make sure the mapper's name is set mapper.name = name // All mappers in this datastore will share adapters mapper._adapters = this.getAdapters() mapper.datastore = this mapper.on('all', (...args) =&gt; this._onMapperEvent(name, ...args)) mapper.defineRelations() return mapper }, defineResource (name, opts) { console.warn('DEPRECATED: defineResource is deprecated, use defineMapper instead') return this.defineMapper(name, opts) }, /** * Return the registered adapter with the given name or the default adapter if * no name is provided. * * @method Container#getAdapter * @param {string} [name] The name of the adapter to retrieve. * @returns {Adapter} The adapter. * @since 3.0.0 */ getAdapter (name) { const adapter = this.getAdapterName(name) if (!adapter) { throw utils.err(`${DOMAIN}#getAdapter`, 'name')(400, 'string', name) } return this.getAdapters()[adapter] }, /** * Return the name of a registered adapter based on the given name or options, * or the name of the default adapter if no name provided. * * @method Container#getAdapterName * @param {(Object|string)} [opts] The name of an adapter or options, if any. * @returns {string} The name of the adapter. * @since 3.0.0 */ getAdapterName (opts) { opts || (opts = {}) if (utils.isString(opts)) { opts = { adapter: opts } } return opts.adapter || this.mapperDefaults.defaultAdapter }, /** * Return the registered adapters of this container. * * @method Container#getAdapters * @returns {Adapter} * @since 3.0.0 */ getAdapters () { return this._adapters }, /** * Return the mapper registered under the specified name. * * @example * import {Container} from 'js-data' * const container = new Container() * // Container#defineMapper returns a direct reference to the newly created * // Mapper. * const UserMapper = container.defineMapper('user') * UserMapper === container.getMapper('user') // true * UserMapper === container.as('user').getMapper() // true * container.getMapper('profile') // throws Error, there is no mapper with name &quot;profile&quot; * * @method Container#getMapper * @param {string} name {@link Mapper#name}. * @returns {Mapper} * @since 3.0.0 */ getMapper (name) { const mapper = this.getMapperByName(name) if (!mapper) { throw utils.err(`${DOMAIN}#getMapper`, name)(404, 'mapper') } return mapper }, /** * Return the mapper registered under the specified name. * Doesn't throw error if mapper doesn't exist. * * @example * import {Container} from 'js-data' * const container = new Container() * // Container#defineMapper returns a direct reference to the newly created * // Mapper. * const UserMapper = container.defineMapper('user') * UserMapper === container.getMapperByName('user') // true * container.getMapperByName('profile') // undefined * * @method Container#getMapperByName * @param {string} name {@link Mapper#name}. * @returns {Mapper} * @since 3.0.0 */ getMapperByName (name) { return this._mappers[name] }, /** * Register an adapter on this container under the given name. Adapters * registered on a container are shared by all mappers in the container. * * @example * import {Container} from 'js-data' * import HttpAdapter from 'js-data-http' * const container = new Container() * container.registerAdapter('http', new HttpAdapter, { default: true }) * * @method Container#registerAdapter * @param {string} name The name of the adapter to register. * @param {Adapter} adapter The adapter to register. * @param {Object} [opts] Configuration options. * @param {boolean} [opts.default=false] Whether to make the adapter the * default adapter for all Mappers in this container. * @since 3.0.0 * @tutorial [&quot;http://www.js-data.io/v3.0/docs/connecting-to-a-data-source&quot;,&quot;Connecting to a data source&quot;] */ registerAdapter (name, adapter, opts) { opts || (opts = {}) this.getAdapters()[name] = adapter // Optionally make it the default adapter for the target. if (opts === true || opts.default) { this.mapperDefaults.defaultAdapter = name utils.forOwn(this._mappers, function (mapper) { mapper.defaultAdapter = name }) } } } proxiedMapperMethods.forEach(function (method) { props[method] = function (name, ...args) { return this.getMapper(name)[method](...args) } }) Component.extend(props) /** * Create a subclass of this Container. * * @example &lt;caption&gt;Extend the class in a cross-browser manner.&lt;/caption&gt; * import {Container} from 'js-data' * const CustomContainerClass = Container.extend({ * foo () { return 'bar' } * }) * const customContainer = new CustomContainerClass() * console.log(customContainer.foo()) // &quot;bar&quot; * * @example &lt;caption&gt;Extend the class using ES2015 class syntax.&lt;/caption&gt; * class CustomContainerClass extends Container { * foo () { return 'bar' } * } * const customContainer = new CustomContainerClass() * console.log(customContainer.foo()) // &quot;bar&quot; * * @method Container.extend * @param {Object} [props={}] Properties to add to the prototype of the * subclass. * @param {Object} [classProps={}] Static properties to add to the subclass. * @returns {Constructor} Subclass of this Container. * @since 3.0.0 */ × Search results Close api.js-data.io • js-data.io "},"DataStore.js.html":{"id":"DataStore.js.html","title":"Source: DataStore.js","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentDataStoreLinkedCollectionMapperQueryRecordSchema Source: DataStore.js import utils from './utils' import { belongsToType, hasManyType, hasOneType } from './decorators' import {proxiedMapperMethods, Container} from './Container' import LinkedCollection from './LinkedCollection' const DOMAIN = 'DataStore' const proxiedCollectionMethods = [ 'add', 'between', 'createIndex', 'filter', 'get', 'getAll', 'query', 'toJson' ] const ownMethodsForScoping = [ 'addToCache', 'cachedFind', 'cachedFindAll', 'cacheFind', 'cacheFindAll', 'hashQuery' ] const safeSet = function (record, field, value) { if (record &amp;&amp; record._set) { record._set(`props.${field}`, value) } else { utils.set(record, field, value) } } const cachedFn = function (name, hashOrId, opts) { const cached = this._completedQueries[name][hashOrId] if (utils.isFunction(cached)) { return cached(name, hashOrId, opts) } return cached } function DataStore (opts) { utils.classCallCheck(this, DataStore) DataStore.__super__.call(this, opts) this.collectionClass = this.collectionClass || LinkedCollection this._collections = {} this._pendingQueries = {} this._completedQueries = {} return this } /** * The `DataStore` class is an extension of {@link Container}. Not only does * `DataStore` manage mappers, but also collections. `DataStore` implements the * asynchronous {@link Mapper} methods, such as {@link Mapper#find} and * {@link Mapper#create}. If you use the asynchronous `DataStore` methods * instead of calling them directly on the mappers, then the results of the * method calls will be inserted into the store's collections. You can think of * a `DataStore` as an [Identity Map](https://en.wikipedia.org/wiki/Identity_map_pattern) * for the [ORM](https://en.wikipedia.org/wiki/Object-relational_mapping) * (the Mappers). * * ```javascript * import {DataStore} from 'js-data' * ``` * * @example * import {DataStore} from 'js-data' * import HttpAdapter from 'js-data-http' * const store = new DataStore() * * // DataStore#defineMapper returns a direct reference to the newly created * // Mapper. * const UserMapper = store.defineMapper('user') * * // DataStore#as returns the store scoped to a particular Mapper. * const UserStore = store.as('user') * * // Call &quot;find&quot; on &quot;UserMapper&quot; (Stateless ORM) * UserMapper.find(1).then((user) =&gt; { * // retrieved a &quot;user&quot; record via the http adapter, but that's it * * // Call &quot;find&quot; on &quot;store&quot; targeting &quot;user&quot; (Stateful DataStore) * return store.find('user', 1) // same as &quot;UserStore.find(1)&quot; * }).then((user) =&gt; { * // not only was a &quot;user&quot; record retrieved, but it was added to the * // store's &quot;user&quot; collection * const cachedUser = store.getCollection('user').get(1) * console.log(user === cachedUser) // true * }) * * @class DataStore * @extends Container * @param {Object} [opts] Configuration options. See {@link Container}. * @returns {DataStore} * @see Container * @since 3.0.0 * @tutorial [&quot;http://www.js-data.io/v3.0/docs/components-of-jsdata#datastore&quot;,&quot;Components of JSData: DataStore&quot;] * @tutorial [&quot;http://www.js-data.io/v3.0/docs/working-with-the-datastore&quot;,&quot;Working with the DataStore&quot;] * @tutorial [&quot;http://www.js-data.io/v3.0/docs/jsdata-and-the-browser&quot;,&quot;Notes on using JSData in the Browser&quot;] */ const props = { constructor: DataStore, _callSuper (method, ...args) { return this.constructor.__super__.prototype[method].apply(this, args) }, /** * TODO * * @method DataStore#_end * @private * @param {string} name Name of the {@link LinkedCollection} to which to * add the data. * @param {Object} data TODO. * @param {Object} [opts] Configuration options. * @returns {(Object|Array)} Result. */ _end (name, result, opts) { let data = opts.raw ? result.data : result if (data &amp;&amp; utils.isFunction(this.addToCache)) { data = this.addToCache(name, data, opts) if (opts.raw) { result.data = data } else { result = data } } return result }, /** * Register a new event listener on this DataStore. * * Proxy for {@link Container#on}. If an event was emitted by a Mapper or * Collection in the DataStore, then the name of the Mapper or Collection will * be prepended to the arugments passed to the provided event handler. * * @method DataStore#on * @param {string} event Name of event to subsribe to. * @param {Function} listener Listener function to handle the event. * @param {*} [ctx] Optional content in which to invoke the listener. */ /** * Used to bind to events emitted by collections in this store. * * @method DataStore#_onCollectionEvent * @private * @param {string} name Name of the collection that emitted the event. * @param {...*} [args] Args passed to {@link Collection#emit}. */ _onCollectionEvent (name, ...args) { const type = args.shift() this.emit(type, name, ...args) }, /** * TODO * * @method DataStore#addToCache * @param {string} name Name of the {@link Mapper} to target. * @param {*} data Data from which data should be selected for add. * @param {Object} [opts] Configuration options. */ addToCache (name, data, opts) { return this.getCollection(name).add(data, opts) }, /** * Return a store scoped to a particular mapper/collection pair. * * @example * import {DataStore} from 'js-data' * const store = new DataStore() * const UserMapper = store.defineMapper('user') * const UserStore = store.as('user') * * const user1 = store.createRecord('user', { name: 'John' }) * const user2 = UserStore.createRecord({ name: 'John' }) * const user3 = UserMapper.createRecord({ name: 'John' }) * assert.deepEqual(user1, user2) * assert.deepEqual(user2, user3) * assert.deepEqual(user1, user3) * * @method DataStore#as * @param {string} name Name of the {@link Mapper}. * @returns {Object} A store scoped to a particular mapper/collection pair. * @since 3.0.0 */ as (name) { const props = {} ownMethodsForScoping.forEach(function (method) { props[method] = { writable: true, value: function (...args) { return this[method](name, ...args) } } }) proxiedMapperMethods.forEach(function (method) { props[method] = { writable: true, value: function (...args) { return this.getMapper(name)[method](...args) } } }) props.getMapper = { writable: true, value: () =&gt; this.getMapper(name) } proxiedCollectionMethods.forEach(function (method) { props[method] = { writable: true, value: function (...args) { return this.getCollection(name)[method](...args) } } }) props.getCollection = { writable: true, value: () =&gt; this.getCollection(name) } return Object.create(this, props) }, /** * Retrieve a cached `find` result, if any. * * @method DataStore#cachedFind * @param {string} name The `name` argument passed to {@link DataStore#find}. * @param {(string|number)} id The `id` argument passed to {@link DataStore#find}. * @param {Object} opts The `opts` argument passed to {@link DataStore#find}. * @since 3.0.0 */ cachedFind: cachedFn, /** * Retrieve a cached `findAll` result, if any. * * @method DataStore#cachedFindAll * @param {string} name The `name` argument passed to {@link DataStore#findAll}. * @param {string} hash The result of calling {@link DataStore#hashQuery} on * the `query` argument passed to {@link DataStore#findAll}. * @param {Object} opts The `opts` argument passed to {@link DataStore#findAll}. * @since 3.0.0 */ cachedFindAll: cachedFn, /** * Cache a `find` result. The default implementation does the following: * * ``` * // Find and return the record from the data store * return this.get(name, id) * ``` * * Override this method to customize. * * @method DataStore#cacheFind * @param {string} name The `name` argument passed to {@link DataStore#find}. * @param {*} data The result to cache. * @param {(string|number)} id The `id` argument passed to {@link DataStore#find}. * @param {Object} opts The `opts` argument passed to {@link DataStore#find}. * @since 3.0.0 */ cacheFind (name, data, id, opts) { this._completedQueries[name][id] = (name, id, opts) =&gt; this.get(name, id) }, /** * Cache a `findAll` result. The default implementation does the following: * * ``` * // Find and return the records from the data store * return this.filter(name, utils.fromJson(hash)) * ``` * * Override this method to customize. * * @method DataStore#cacheFindAll * @param {string} name The `name` argument passed to {@link DataStore#findAll}. * @param {*} data The result to cache. * @param {string} hash The result of calling {@link DataStore#hashQuery} on * the `query` argument passed to {@link DataStore#findAll}. * @param {Object} opts The `opts` argument passed to {@link DataStore#findAll}. * @since 3.0.0 */ cacheFindAll (name, data, hash, opts) { this._completedQueries[name][hash] = (name, hash, opts) =&gt; this.filter(name, utils.fromJson(hash)) }, clear () { const removed = {} utils.forOwn(this._collections, (collection, name) =&gt; { removed[name] = collection.removeAll() }) return removed }, /** * Wrapper for {@link Mapper#create}. Adds the created to the store. * * @method DataStore#create * @param {string} name Name of the {@link Mapper} to target. * @param {Object} record Passed to {@link Mapper#create}. * @param {Object} [opts] Passed to {@link Mapper#create}. See * {@link Mapper#create} for more configuration options. * @returns {Promise} Resolves with the result of the create. * @since 3.0.0 */ create (name, record, opts) { opts || (opts = {}) return this._callSuper('create', name, record, opts) .then((result) =&gt; this._end(name, result, opts)) }, /** * Wrapper for {@link Mapper#createMany}. Adds the created records to the * store. * * @method DataStore#createMany * @param {string} name Name of the {@link Mapper} to target. * @param {Array} records Passed to {@link Mapper#createMany}. * @param {Object} [opts] Passed to {@link Mapper#createMany}. See * {@link Mapper#createMany} for more configuration options. * @returns {Promise} Resolves with the result of the create. * @since 3.0.0 */ createMany (name, records, opts) { opts || (opts = {}) return this._callSuper('createMany', name, records, opts) .then((result) =&gt; this._end(name, result, opts)) }, defineMapper (name, opts) { // Complexity of this method is beyond simply using =&gt; functions to bind context const self = this const mapper = utils.getSuper(self).prototype.defineMapper.call(self, name, opts) self._pendingQueries[name] = {} self._completedQueries[name] = {} mapper.relationList || Object.defineProperty(mapper, 'relationList', { value: [] }) // The datastore uses a subclass of Collection that is &quot;datastore-aware&quot; const collection = self._collections[name] = new self.collectionClass(null, { // eslint-disable-line // Make sure the collection has somewhere to store &quot;added&quot; timestamps _added: {}, // Give the collection a reference to this datastore datastore: self, // The mapper tied to the collection mapper }) const schema = mapper.schema || {} const properties = schema.properties || {} // TODO: Make it possible index nested properties? utils.forOwn(properties, function (opts, prop) { if (opts.indexed) { collection.createIndex(prop) } }) // Create a secondary index on the &quot;added&quot; timestamps of records in the // collection collection.createIndex('addedTimestamps', ['$'], { fieldGetter (obj) { return collection._added[collection.recordId(obj)] } }) collection.on('all', function (...args) { self._onCollectionEvent(name, ...args) }) const idAttribute = mapper.idAttribute mapper.relationList.forEach(function (def) { const relation = def.relation const localField = def.localField const path = `links.${localField}` const foreignKey = def.foreignKey const type = def.type const updateOpts = { index: foreignKey } let descriptor const getter = function () { return this._get(path) } if (type === belongsToType) { if (!collection.indexes[foreignKey]) { collection.createIndex(foreignKey) } descriptor = { get: getter, set (record) { const _self = this const current = this._get(path) if (record === current) { return current } const id = utils.get(_self, idAttribute) const inverseDef = def.getInverse(mapper) if (record) { const relatedIdAttribute = def.getRelation().idAttribute const relatedId = utils.get(record, relatedIdAttribute) // Prefer store record if (!utils.isUndefined(relatedId)) { record = self.get(relation, relatedId) || record } // Set locals _self._set(path, record) safeSet(_self, foreignKey, relatedId) collection.updateIndex(_self, updateOpts) // Update (set) inverse relation if (inverseDef.type === hasOneType) { utils.set(record, inverseDef.localField, _self) } else if (inverseDef.type === hasManyType) { const children = utils.get(record, inverseDef.localField) utils.noDupeAdd(children, _self, function (_record) { return id === utils.get(_record, idAttribute) }) } } else { // Unset locals _self._set(path, undefined) safeSet(_self, foreignKey, undefined) collection.updateIndex(_self, updateOpts) } if (current) { if (inverseDef.type === hasOneType) { utils.set(current, inverseDef.localField, undefined) } else if (inverseDef.type === hasManyType) { const children = utils.get(current, inverseDef.localField) utils.remove(children, function (_record) { return id === utils.get(_record, idAttribute) }) } } return record } } let foreignKeyDescriptor = Object.getOwnPropertyDescriptor(mapper.recordClass.prototype, foreignKey) if (!foreignKeyDescriptor) { foreignKeyDescriptor = { enumerable: true } } const originalGet = foreignKeyDescriptor.get foreignKeyDescriptor.get = function () { if (originalGet) { return originalGet.call(this) } return this._get(`props.${foreignKey}`) } const originalSet = foreignKeyDescriptor.set foreignKeyDescriptor.set = function (value) { if (originalSet) { originalSet.call(this, value) } if (utils.isUndefined(value)) { // Unset locals utils.set(this, localField, undefined) } else { safeSet(this, foreignKey, value) let storeRecord = self.get(relation, value) if (storeRecord) { utils.set(this, localField, storeRecord) } } } Object.defineProperty(mapper.recordClass.prototype, foreignKey, foreignKeyDescriptor) } else if (type === hasManyType) { const localKeys = def.localKeys const foreignKeys = def.foreignKeys // TODO: Handle case when belongsTo relation isn't ever defined if (self._collections[relation] &amp;&amp; foreignKey &amp;&amp; !self.getCollection(relation).indexes[foreignKey]) { self.getCollection(relation).createIndex(foreignKey) } descriptor = { get () { const _self = this let current = getter.call(_self) if (!current) { _self._set(path, []) } return getter.call(_self) }, set (records) { const _self = this records || (records = []) if (records &amp;&amp; !utils.isArray(records)) { records = [records] } const id = utils.get(_self, idAttribute) const relatedIdAttribute = def.getRelation().idAttribute const inverseDef = def.getInverse(mapper) const inverseLocalField = inverseDef.localField let linked = _self._get(path) if (!linked) { linked = [] } const current = linked linked = [] const toLink = {} records.forEach(function (record) { const relatedId = utils.get(record, relatedIdAttribute) if (!utils.isUndefined(relatedId)) { // Prefer store record record = self.get(relation, relatedId) || record toLink[relatedId] = record } linked.push(record) }) if (foreignKey) { records.forEach(function (record) { // Update (set) inverse relation safeSet(record, foreignKey, id) self.getCollection(relation).updateIndex(record, updateOpts) utils.set(record, inverseLocalField, _self) }) current.forEach(function (record) { const relatedId = utils.get(record, relatedIdAttribute) if (!utils.isUndefined(relatedId) &amp;&amp; !toLink.hasOwnProperty(relatedId)) { // Update (unset) inverse relation safeSet(record, foreignKey, undefined) self.getCollection(relation).updateIndex(record, updateOpts) utils.set(record, inverseLocalField, undefined) } }) } else if (localKeys) { const _localKeys = [] records.forEach(function (record) { // Update (set) inverse relation utils.set(record, inverseLocalField, _self) _localKeys.push(utils.get(record, relatedIdAttribute)) }) // Update locals utils.set(_self, localKeys, _localKeys) // Update (unset) inverse relation current.forEach(function (record) { const relatedId = utils.get(record, relatedIdAttribute) if (!utils.isUndefined(relatedId) &amp;&amp; !toLink.hasOwnProperty(relatedId)) { // Update inverse relation utils.set(record, inverseLocalField, undefined) } }) } else if (foreignKeys) { // Update (unset) inverse relation current.forEach(function (record) { const _localKeys = utils.get(record, foreignKeys) || [] utils.remove(_localKeys, function (_key) { return id === _key }) const _localField = utils.get(record, inverseLocalField) || [] utils.remove(_localField, function (_record) { return id === utils.get(_record, idAttribute) }) }) // Update (set) inverse relation records.forEach(function (record) { const _localKeys = utils.get(record, foreignKeys) || [] utils.noDupeAdd(_localKeys, id, function (_key) { return id === _key }) const _localField = utils.get(record, inverseLocalField) || [] utils.noDupeAdd(_localField, _self, function (_record) { return id === utils.get(_record, idAttribute) }) }) } _self._set(path, linked) return linked } } } else if (type === hasOneType) { // TODO: Handle case when belongsTo relation isn't ever defined if (self._collections[relation] &amp;&amp; foreignKey &amp;&amp; !self.getCollection(relation).indexes[foreignKey]) { self.getCollection(relation).createIndex(foreignKey) } descriptor = { get: getter, set (record) { const _self = this const current = this._get(path) if (record === current) { return current } const relatedId = utils.get(record, def.getRelation().idAttribute) const inverseLocalField = def.getInverse(mapper).localField // Update (unset) inverse relation if (current) { safeSet(current, foreignKey, undefined) self.getCollection(relation).updateIndex(current, updateOpts) utils.set(current, inverseLocalField, undefined) } if (record) { // Prefer store record if (!utils.isUndefined(relatedId)) { record = self.get(relation, relatedId) || record } // Set locals _self._set(path, record) // Update (set) inverse relation safeSet(record, foreignKey, utils.get(_self, idAttribute)) self.getCollection(relation).updateIndex(record, updateOpts) utils.set(record, inverseLocalField, _self) } else { // Set locals _self._set(path, undefined) } return record } } } if (descriptor) { descriptor.enumerable = utils.isUndefined(def.enumerable) ? false : def.enumerable if (def.get) { let origGet = descriptor.get descriptor.get = function () { return def.get(def, this, (...args) =&gt; origGet.apply(this, args)) } } if (def.set) { let origSet = descriptor.set descriptor.set = function (related) { return def.set(def, this, related, (value) =&gt; origSet.call(this, value === undefined ? related : value)) } } Object.defineProperty(mapper.recordClass.prototype, localField, descriptor) } }) return mapper }, /** * Wrapper for {@link Mapper#destroy}. Removes any destroyed record from the * store. * * @method DataStore#destroy * @param {string} name Name of the {@link Mapper} to target. * @param {(string|number)} id Passed to {@link Mapper#destroy}. * @param {Object} [opts] Passed to {@link Mapper#destroy}. See * {@link Mapper#destroy} for more configuration options. * @returns {Promise} Resolves when the delete completes. * @since 3.0.0 */ destroy (name, id, opts) { opts || (opts = {}) return this._callSuper('destroy', name, id, opts).then((result) =&gt; { if (opts.raw) { result.data = this.getCollection(name).remove(id, opts) } else { result = this.getCollection(name).remove(id, opts) } delete this._pendingQueries[name][id] delete this._completedQueries[name][id] return result }) }, /** * Wrapper for {@link Mapper#destroyAll}. Removes any destroyed records from * the store. * * @method DataStore#destroyAll * @param {string} name Name of the {@link Mapper} to target. * @param {Object} [query] Passed to {@link Mapper#destroyAll}. * @param {Object} [opts] Passed to {@link Mapper#destroyAll}. See * {@link Mapper#destroyAll} for more configuration options. * @returns {Promise} Resolves when the delete completes. * @since 3.0.0 */ destroyAll (name, query, opts) { opts || (opts = {}) return this._callSuper('destroyAll', name, query, opts).then((result) =&gt; { if (opts.raw) { result.data = this.getCollection(name).removeAll(query, opts) } else { result = this.getCollection(name).removeAll(query, opts) } const hash = this.hashQuery(name, query, opts) delete this._pendingQueries[name][hash] delete this._completedQueries[name][hash] return result }) }, eject (name, id, opts) { console.warn('DEPRECATED: &quot;eject&quot; is deprecated, use &quot;remove&quot; instead') return this.remove(name, id, opts) }, ejectAll (name, query, opts) { console.warn('DEPRECATED: &quot;ejectAll&quot; is deprecated, use &quot;removeAll&quot; instead') return this.removeAll(name, query, opts) }, /** * Wrapper for {@link Mapper#find}. Adds any found record to the store. * * @method DataStore#find * @param {string} name Name of the {@link Mapper} to target. * @param {(string|number)} id Passed to {@link Mapper#find}. * @param {Object} [opts] Passed to {@link Mapper#find}. * @returns {Promise} Resolves with the result, if any. * @since 3.0.0 */ find (name, id, opts) { opts || (opts = {}) const pendingQuery = this._pendingQueries[name][id] utils.fillIn(opts, this.getMapper(name)) if (pendingQuery) { return pendingQuery } const item = this.cachedFind(name, id, opts) let promise if (opts.force || !item) { promise = this._pendingQueries[name][id] = this._callSuper('find', name, id, opts).then((result) =&gt; { delete this._pendingQueries[name][id] result = this._end(name, result, opts) this.cacheFind(name, result, id, opts) return result }, (err) =&gt; { delete this._pendingQueries[name][id] return utils.reject(err) }) } else { promise = utils.resolve(item) } return promise }, /** * Wrapper for {@link Mapper#findAll}. Adds any found records to the store. * * @method DataStore#findAll * @param {string} name Name of the {@link Mapper} to target. * @param {Object} [query] Passed to {@link Model.findAll}. * @param {Object} [opts] Passed to {@link Model.findAll}. * @returns {Promise} Resolves with the result, if any. * @since 3.0.0 */ findAll (name, query, opts) { opts || (opts = {}) const hash = this.hashQuery(name, query, opts) const pendingQuery = this._pendingQueries[name][hash] utils.fillIn(opts, this.getMapper(name)) if (pendingQuery) { return pendingQuery } const items = this.cachedFindAll(name, hash, opts) let promise if (opts.force || !items) { promise = this._pendingQueries[name][hash] = this._callSuper('findAll', name, query, opts).then((result) =&gt; { delete this._pendingQueries[name][hash] result = this._end(name, result, opts) this.cacheFindAll(name, result, hash, opts) return result }, (err) =&gt; { delete this._pendingQueries[name][hash] return utils.reject(err) }) } else { promise = utils.resolve(items) } return promise }, /** * Return the {@link LinkedCollection} with the given name. * * @method DataStore#getCollection * @param {string} name Name of the {@link LinkedCollection} to retrieve. * @returns {LinkedCollection} * @since 3.0.0 * @throws {Error} Thrown if the specified {@link LinkedCollection} does not * exist. */ getCollection (name) { const collection = this._collections[name] if (!collection) { throw utils.err(`${DOMAIN}#getCollection`, name)(404, 'collection') } return collection }, /** * Hashing function used to cache {@link DataStore#find} and * {@link DataStore#findAll} requests. This method simply JSONifies the * `query` argument passed to {@link DataStore#find} or * {@link DataStore#findAll}. * * Override this method for custom hashing behavior. * @method DataStore#hashQuery * @param {string} name The `name` argument passed to {@link DataStore#find} * or {@link DataStore#findAll}. * @param {Object} query The `query` argument passed to {@link DataStore#find} * or {@link DataStore#findAll}. * @returns {string} The JSONified `query`. * @since 3.0.0 */ hashQuery (name, query, opts) { return utils.toJson(query) }, inject (name, records, opts) { console.warn('DEPRECATED: &quot;inject&quot; is deprecated, use &quot;add&quot; instead') return this.add(name, records, opts) }, /** * Wrapper for {@link LinkedCollection#remove}. Removes the specified * {@link Record} from the store. * * @method DataStore#remove * @param {string} name The name of the {@link LinkedCollection} to target. * @param {string|number} id The primary key of the {@link Record} to remove. * @param {Object} [opts] Configuration options. * @param {string[]} [opts.with] Relations of the {@link Record} to also * remove from the store. * @returns {Record} The removed {@link Record}, if any. * @since 3.0.0 */ remove (name, id, opts) { const record = this.getCollection(name).remove(id, opts) if (record) { this.removeRelated(name, [record], opts) } return record }, /** * Wrapper for {@link LinkedCollection#removeAll}. Removes the selected * {@link Record}s from the store. * * @method DataStore#removeAll * @param {string} name The name of the {@link LinkedCollection} to target. * @param {Object} [query={}] Selection query. See {@link query}. * @param {Object} [query.where] See {@link query.where}. * @param {number} [query.offset] See {@link query.offset}. * @param {number} [query.limit] See {@link query.limit}. * @param {string|Array[]} [query.orderBy] See {@link query.orderBy}. * @param {Object} [opts] Configuration options. * @param {string[]} [opts.with] Relations of the {@link Record} to also * remove from the store. * @returns {Record} The removed {@link Record}s, if any. * @since 3.0.0 */ removeAll (name, query, opts) { const records = this.getCollection(name).removeAll(query, opts) if (records.length) { this.removeRelated(name, records, opts) } return records }, /** * Remove from the store {@link Record}s that are related to the provided * {@link Record}(s). * * @method DataStore#removeRelated * @param {string} name The name of the {@link LinkedCollection} to target. * @param {Record|Record[]} records {@link Record}s whose relations are to be * removed. * @param {Object} [opts] Configuration options. * @param {string[]} [opts.with] Relations of the {@link Record}(s) to remove * from the store. * @since 3.0.0 */ removeRelated (name, records, opts) { if (!utils.isArray(records)) { records = [records] } utils.forEachRelation(this.getMapper(name), opts, (def, optsCopy) =&gt; { records.forEach((record) =&gt; { let relatedData let query if (def.foreignKey &amp;&amp; (def.type === hasOneType || def.type === hasManyType)) { query = { [def.foreignKey]: def.getForeignKey(record) } } else if (def.type === hasManyType &amp;&amp; def.localKeys) { query = { where: { [def.getRelation().idAttribute]: { 'in': utils.get(record, def.localKeys) } } } } else if (def.type === hasManyType &amp;&amp; def.foreignKeys) { query = { where: { [def.foreignKeys]: { 'contains': def.getForeignKey(record) } } } } else if (def.type === belongsToType) { relatedData = this.remove(def.relation, def.getForeignKey(record), optsCopy) } if (query) { relatedData = this.removeAll(def.relation, query, optsCopy) } if (relatedData) { if (utils.isArray(relatedData) &amp;&amp; !relatedData.length) { return } if (def.type === hasOneType) { relatedData = relatedData[0] } def.setLocalField(record, relatedData) } }) }) }, /** * Wrapper for {@link Mapper#update}. Adds the updated {@link Record} to the * store. * * @method DataStore#update * @param {string} name Name of the {@link Mapper} to target. * @param {(string|number)} id Passed to {@link Mapper#update}. * @param {Object} record Passed to {@link Mapper#update}. * @param {Object} [opts] Passed to {@link Mapper#update}. See * {@link Mapper#update} for more configuration options. * @returns {Promise} Resolves with the result of the update. * @since 3.0.0 */ update (name, id, record, opts) { opts || (opts = {}) return this._callSuper('update', name, id, record, opts) .then((result) =&gt; this._end(name, result, opts)) }, /** * Wrapper for {@link Mapper#updateAll}. Adds the updated {@link Record}s to * the store. * * @method DataStore#updateAll * @param {string} name Name of the {@link Mapper} to target. * @param {Object} props Passed to {@link Mapper#updateAll}. * @param {Object} [query] Passed to {@link Mapper#updateAll}. * @param {Object} [opts] Passed to {@link Mapper#updateAll}. See * {@link Mapper#updateAll} for more configuration options. * @returns {Promise} Resolves with the result of the update. * @since 3.0.0 */ updateAll (name, props, query, opts) { opts || (opts = {}) return this._callSuper('updateAll', name, query, props, opts) .then((result) =&gt; this._end(name, result, opts)) }, /** * Wrapper for {@link Mapper#updateMany}. Adds the updated {@link Record}s to * the store. * * @method DataStore#updateMany * @param {string} name Name of the {@link Mapper} to target. * @param {(Object[]|Record[])} records Passed to {@link Mapper#updateMany}. * @param {Object} [opts] Passed to {@link Mapper#updateMany}. See * {@link Mapper#updateMany} for more configuration options. * @returns {Promise} Resolves with the result of the update. * @since 3.0.0 */ updateMany (name, records, opts) { opts || (opts = {}) return this._callSuper('updateMany', name, records, opts) .then((result) =&gt; this._end(name, result, opts)) } } proxiedCollectionMethods.forEach(function (method) { props[method] = function (name, ...args) { return this.getCollection(name)[method](...args) } }) export default Container.extend(props) /** * Create a subclass of this DataStore. * * @example &lt;caption&gt;Extend the class in a cross-browser manner.&lt;/caption&gt; * import {DataStore} from 'js-data' * const CustomDataStoreClass = DataStore.extend({ * foo () { return 'bar' } * }) * const customDataStore = new CustomDataStoreClass() * console.log(customDataStore.foo()) // &quot;bar&quot; * * @example &lt;caption&gt;Extend the class using ES2015 class syntax.&lt;/caption&gt; * class CustomDataStoreClass extends DataStore { * foo () { return 'bar' } * } * const customDataStore = new CustomDataStoreClass() * console.log(customDataStore.foo()) // &quot;bar&quot; * * @method DataStore.extend * @param {Object} [props={}] Properties to add to the prototype of the * subclass. * @param {Object} [classProps={}] Static properties to add to the subclass. * @returns {Constructor} Subclass of this DataStore. * @since 3.0.0 */ × Search results Close api.js-data.io • js-data.io "},"LinkedCollection.js.html":{"id":"LinkedCollection.js.html","title":"Source: LinkedCollection.js","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentDataStoreLinkedCollectionMapperQueryRecordSchema Source: LinkedCollection.js import utils from './utils' import './decorators' import Collection from './Collection' const DOMAIN = 'LinkedCollection' /** * TODO * * ```javascript * import {LinkedCollection} from 'js-data' * ``` * * @class LinkedCollection * @extends Collection * @param {Array} [records] Initial set of records to insert into the * collection. See {@link Collection}. * @param {Object} [opts] Configuration options. See {@link Collection}. * @returns {Mapper} */ function LinkedCollection (records, opts) { utils.classCallCheck(this, LinkedCollection) // Make sure this collection has somewhere to store &quot;added&quot; timestamps Object.defineProperties(this, { _added: { value: {} }, datastore: { writable: true, value: undefined } }) LinkedCollection.__super__.call(this, records, opts) // Make sure this collection has a reference to a datastore if (!this.datastore) { throw utils.err(`new ${DOMAIN}`, 'opts.datastore')(400, 'DataStore', this.datastore) } return this } export default Collection.extend({ constructor: LinkedCollection, _onRecordEvent (...args) { utils.getSuper(this).prototype._onRecordEvent.apply(this, args) const event = args[0] // This is a very brute force method // Lots of room for optimization if (utils.isString(event) &amp;&amp; event.indexOf('change') === 0) { this.updateIndexes(args[1]) } }, add (records, opts) { const mapper = this.mapper const timestamp = new Date().getTime() const singular = utils.isObject(records) &amp;&amp; !utils.isArray(records) if (singular) { records = [records] } records = utils.getSuper(this).prototype.add.call(this, records, opts) if (mapper.relationList.length &amp;&amp; records.length) { // Check the currently visited record for relations that need to be // inserted into their respective collections. mapper.relationList.forEach(function (def) { def.linkRecords(mapper, records) }) } records.forEach((record) =&gt; this._addMeta(record, timestamp)) return singular ? records[0] : records }, remove (id, opts) { const mapper = this.mapper const record = utils.getSuper(this).prototype.remove.call(this, id, opts) if (record) { this._clearMeta(record) } return record }, removeAll (query, opts) { const mapper = this.mapper const records = utils.getSuper(this).prototype.removeAll.call(this, query, opts) records.forEach(this._clearMeta, this) return records }, _clearMeta (record) { delete this._added[this.recordId(record)] if (this.mapper.recordClass) { record._set('$') // unset } }, _addMeta (record, timestamp) { // Track when this record was added this._added[this.recordId(record)] = timestamp if (this.mapper.recordClass) { record._set('$', timestamp) } } }) /** * Create a subclass of this LinkedCollection. * * @example &lt;caption&gt;Extend the class in a cross-browser manner.&lt;/caption&gt; * import {LinkedCollection} from 'js-data' * const CustomLinkedCollectionClass = LinkedCollection.extend({ * foo () { return 'bar' } * }) * const customLinkedCollection = new CustomLinkedCollectionClass() * console.log(customLinkedCollection.foo()) // &quot;bar&quot; * * @example &lt;caption&gt;Extend the class using ES2015 class syntax.&lt;/caption&gt; * class CustomLinkedCollectionClass extends LinkedCollection { * foo () { return 'bar' } * } * const customLinkedCollection = new CustomLinkedCollectionClass() * console.log(customLinkedCollection.foo()) // &quot;bar&quot; * * @method LinkedCollection.extend * @param {Object} [props={}] Properties to add to the prototype of the * subclass. * @param {Object} [classProps={}] Static properties to add to the subclass. * @returns {Constructor} Subclass of this LinkedCollection class. * @since 3.0.0 */ × Search results Close api.js-data.io • js-data.io "},"Mapper.js.html":{"id":"Mapper.js.html","title":"Source: Mapper.js","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentDataStoreLinkedCollectionMapperQueryRecordSchema Source: Mapper.js import utils from './utils' import Component from './Component' import Record from './Record' import Schema from './Schema' import { Relation } from './relations' import { belongsTo, belongsToType, hasMany, hasManyType, hasOne, hasOneType } from './decorators' const DOMAIN = 'Mapper' const validatingHooks = [ 'beforeCreate', 'beforeCreateMany', 'beforeUpdate', 'beforeUpdateAll', 'beforeUpdateMany' ] const makeNotify = function (num) { return function (...args) { const opts = args[args.length - num] const op = opts.op this.dbg(op, ...args) // Automatic validation if (validatingHooks.indexOf(op) !== -1 &amp;&amp; opts.validate !== false) { // Save current value of option const originalExistingOnly = opts.existingOnly // For updates, ignore required fields if they aren't present if (op.indexOf('beforeUpdate') === 0 &amp;&amp; utils.isUndefined(opts.existingOnly)) { opts.existingOnly = true } const errors = this.validate(args[op === 'beforeUpdate' ? 1 : 0], utils.pick(opts, ['existingOnly'])) // Restore option opts.existingOnly = originalExistingOnly // Abort lifecycle due to validation errors if (errors) { return utils.reject(errors) } } // Emit lifecycle event if (opts.notify || (opts.notify === undefined &amp;&amp; this.notify)) { setTimeout(() =&gt; { this.emit(op, ...args) }) } } } // These are the default implementations of all of the lifecycle hooks const notify = makeNotify(1) const notify2 = makeNotify(2) // This object provides meta information used by Mapper#crud to actually // execute each lifecycle method const LIFECYCLE_METHODS = { count: { defaults: [{}, {}], skip: true, types: [] }, destroy: { defaults: [{}, {}], skip: true, types: [] }, destroyAll: { defaults: [{}, {}], skip: true, types: [] }, find: { defaults: [undefined, {}], types: [] }, findAll: { defaults: [{}, {}], types: [] }, sum: { defaults: [undefined, {}, {}], skip: true, types: [] }, update: { adapterArgs (mapper, id, props, opts) { return [id, mapper.toJSON(props, opts), opts] }, beforeAssign: 1, defaults: [undefined, {}, {}], types: [] }, updateAll: { adapterArgs (mapper, props, query, opts) { return [mapper.toJSON(props, opts), query, opts] }, beforeAssign: 0, defaults: [{}, {}, {}], types: [] }, updateMany: { adapterArgs (mapper, records, opts) { return [records.map(function (record) { return mapper.toJSON(record, opts) }), opts] }, beforeAssign: 0, defaults: [[], {}], types: [] } } const MAPPER_DEFAULTS = { /** * Hash of registered adapters. Don't modify directly. Use * {@link Mapper#registerAdapter} instead. * * @default {} * @name Mapper#_adapters * @since 3.0.0 * @tutorial [&quot;http://www.js-data.io/v3.0/docs/connecting-to-a-data-source&quot;,&quot;Connecting to a data source&quot;] */ _adapters: {}, /** * Whether to augment {@link Mapper#recordClass} with getter/setter property * accessors according to the properties defined in {@link Mapper#schema}. * This makes possible validation and change tracking on individual properties * when using the dot (e.g. `user.name = &quot;Bob&quot;`) operator to modify a * property. * * @default true * @name Mapper#applySchema * @since 3.0.0 * @type {boolean} */ applySchema: true, /** * Whether to enable debug-level logs. * * @default false * @name Mapper#debug * @since 3.0.0 * @type {boolean} */ debug: false, /** * The name of the registered adapter that this Mapper should used by default. * * @default &quot;http&quot; * @name Mapper#defaultAdapter * @since 3.0.0 * @tutorial [&quot;http://www.js-data.io/v3.0/docs/connecting-to-a-data-source&quot;,&quot;Connecting to a data source&quot;] * @type {string} */ defaultAdapter: 'http', /** * The field used as the unique identifier on records handled by this Mapper. * * @default id * @name Mapper#idAttribute * @since 3.0.0 * @type {string} */ idAttribute: 'id', /** * Whether this Mapper should emit operational events. * * @default true * @name Mapper#notify * @since 3.0.0 * @type {boolean} */ notify: true, /** * Whether {@link Mapper#create}, {@link Mapper#createMany}, * {@link Mapper#update}, {@link Mapper#updateAll}, {@link Mapper#updateMany}, * {@link Mapper#find}, {@link Mapper#findAll}, {@link Mapper#destroy}, * {@link Mapper#destroyAll}, {@link Mapper#count}, and {@link Mapper#sum} * should return a raw result object that contains both the instance data * returned by the adapter _and_ metadata about the operation. * * The default is to NOT return the result object, and instead return just the * instance data. * * @default false * @name Mapper#raw * @since 3.0.0 * @type {boolean} */ raw: false } /** * The core of JSData's [ORM/ODM][orm] implementation. Given a minimum amout of * meta information about a resource, a Mapper can perform generic CRUD * operations against that resource. Apart from its configuration, a Mapper is * stateless. The particulars of various persistence layers have been abstracted * into adapters, which a Mapper uses to perform its operations. * * The term &quot;Mapper&quot; comes from the [Data Mapper Pattern][pattern] described in * Martin Fowler's [Patterns of Enterprise Application Architecture][book]. A * Data Mapper moves data between [in-memory object instances][record] and a * relational or document-based database. JSData's Mapper can work with any * persistence layer you can write an adapter for. * * _(&quot;Model&quot; is a heavily overloaded term and is avoided in this documentation * to prevent confusion.)_ * * [orm]: https://en.wikipedia.org/wiki/Object-relational_mapping * [pattern]: https://en.wikipedia.org/wiki/Data_mapper_pattern * [book]: http://martinfowler.com/books/eaa.html * [record]: Record.html * * @example &lt;caption&gt;Import and instantiate&lt;/caption&gt; * import {Mapper} from 'js-data' * * const UserService = new Mapper({ name: 'user' }) * * @example &lt;caption&gt;Define a Mapper using the Container component&lt;/caption&gt; * import {Container} from 'js-data' * * const store = new Container() * store.defineMapper('user') * * @class Mapper * @extends Component * @param {Object} opts Configuration options. * @param {boolean} [opts.applySchema=true] See {@link Mapper#applySchema}. * @param {boolean} [opts.debug=false] See {@link Mapper#debug}. * @param {string} [opts.defaultAdapter=http] See {@link Mapper#defaultAdapter}. * @param {string} [opts.idAttribute=id] See {@link Mapper#idAttribute}. * @param {string} opts.name See {@link Mapper#name}. * @param {boolean} [opts.notify] See {@link Mapper#notify}. * @param {boolean} [opts.raw=false] See {@link Mapper#raw}. * @param {Function|boolean} [opts.recordClass] See {@link Mapper#recordClass}. * @returns {Mapper} A new {@link Mapper} instance. * @see http://www.js-data.io/v3.0/docs/components-of-jsdata#mapper * @since 3.0.0 * @tutorial [&quot;http://www.js-data.io/v3.0/docs/components-of-jsdata#mapper&quot;,&quot;Components of JSData: Mapper&quot;] * @tutorial [&quot;http://www.js-data.io/v3.0/docs/modeling-your-data&quot;,&quot;Modeling your data&quot;] */ function Mapper (opts) { utils.classCallCheck(this, Mapper) Mapper.__super__.call(this) opts || (opts = {}) // Prepare certain properties to be non-enumerable Object.defineProperties(this, { _adapters: { value: undefined, writable: true }, /** * Set to `false` to force the Mapper to work with POJO objects only. * * @example &lt;caption&gt;Use POJOs only.&lt;/caption&gt; * import {Mapper, Record} from 'js-data' * const UserMapper = new Mapper({ recordClass: false }) * UserMapper.recordClass // false * const user = UserMapper#createRecord() * user instanceof Record // false * * @example &lt;caption&gt;Set to a custom class to have records wrapped in your custom class.&lt;/caption&gt; * import {Mapper, Record} from 'js-data' * // Custom class * class User { * constructor (props = {}) { * for (var key in props) { * if (props.hasOwnProperty(key)) { * this[key] = props[key] * } * } * } * } * const UserMapper = new Mapper({ recordClass: User }) * UserMapper.recordClass // function User() {} * const user = UserMapper#createRecord() * user instanceof Record // false * user instanceof User // true * * * @example &lt;caption&gt;Extend the {@link Record} class.&lt;/caption&gt; * import {Mapper, Record} from 'js-data' * // Custom class * class User extends Record { * constructor () { * super(props) * } * } * const UserMapper = new Mapper({ recordClass: User }) * UserMapper.recordClass // function User() {} * const user = UserMapper#createRecord() * user instanceof Record // true * user instanceof User // true * * @name Mapper#recordClass * @default {@link Record} * @see Record * @since 3.0.0 */ recordClass: { value: undefined, writable: true }, /** * The meta information describing this Mapper's available lifecycle * methods. __Do not modify.__ * * TODO: Improve documentation. * * @name Mapper#lifecycleMethods * @since 3.0.0 * @type {Object} */ lifecycleMethods: { value: LIFECYCLE_METHODS }, /** * This Mapper's {@link Schema}. * * @name Mapper#schema * @see Schema * @since 3.0.0 * @type {Schema} */ schema: { value: undefined, writable: true } }) // Apply user-provided configuration utils.fillIn(this, opts) // Fill in any missing options with the defaults utils.fillIn(this, utils.copy(MAPPER_DEFAULTS)) /** * The name for this Mapper. This is the minimum amount of meta information * required for a Mapper to be able to execute CRUD operations for a * Resource. * * @name Mapper#name * @since 3.0.0 * @type {string} */ if (!this.name) { throw utils.err(`new ${DOMAIN}`, 'opts.name')(400, 'string', this.name) } // Setup schema, with an empty default schema if necessary if (!(this.schema instanceof Schema)) { this.schema = new Schema(this.schema || {}) } if (this.schema instanceof Schema) { this.schema.type || (this.schema.type = 'object') } // Create a subclass of Record that's tied to this Mapper if (utils.isUndefined(this.recordClass)) { const superClass = Record this.recordClass = superClass.extend({ constructor: (function Record () { var subClass = function Record (props, opts) { utils.classCallCheck(this, subClass) superClass.call(this, props, opts) } return subClass })() }) } if (this.recordClass) { this.recordClass.mapper = this // We can only apply the schema to the prototype of this.recordClass if the // class extends Record if (utils.getSuper(this.recordClass, true) === Record &amp;&amp; this.schema &amp;&amp; this.schema.apply &amp;&amp; this.applySchema) { this.schema.apply(this.recordClass.prototype) } } } export default Component.extend({ constructor: Mapper, /** * Mapper lifecycle hook called by {@link Mapper#count}. If this method * returns a promise then {@link Mapper#count} will wait for the promise * to resolve before continuing. * * @method Mapper#afterCount * @param {Object} query The `query` argument passed to {@link Mapper#count}. * @param {Object} opts The `opts` argument passed to {@link Mapper#count}. * @param {*} result The result, if any. * @since 3.0.0 */ afterCount: notify2, /** * Mapper lifecycle hook called by {@link Mapper#create}. If this method * returns a promise then {@link Mapper#create} will wait for the promise * to resolve before continuing. * * @method Mapper#afterCreate * @param {Object} props The `props` argument passed to {@link Mapper#create}. * @param {Object} opts The `opts` argument passed to {@link Mapper#create}. * @param {*} result The result, if any. * @since 3.0.0 */ afterCreate: notify2, /** * Mapper lifecycle hook called by {@link Mapper#createMany}. If this method * returns a promise then {@link Mapper#createMany} will wait for the promise * to resolve before continuing. * * @method Mapper#afterCreateMany * @param {Array} records The `records` argument passed to {@link Mapper#createMany}. * @param {Object} opts The `opts` argument passed to {@link Mapper#createMany}. * @param {*} result The result, if any. * @since 3.0.0 */ afterCreateMany: notify2, /** * Mapper lifecycle hook called by {@link Mapper#destroy}. If this method * returns a promise then {@link Mapper#destroy} will wait for the promise * to resolve before continuing. * * @method Mapper#afterDestroy * @param {(string|number)} id The `id` argument passed to {@link Mapper#destroy}. * @param {Object} opts The `opts` argument passed to {@link Mapper#destroy}. * @param {*} result The result, if any. * @since 3.0.0 */ afterDestroy: notify2, /** * Mapper lifecycle hook called by {@link Mapper#destroyAll}. If this method * returns a promise then {@link Mapper#destroyAll} will wait for the promise * to resolve before continuing. * * @method Mapper#afterDestroyAll * @param {*} data The `data` returned by the adapter. * @param {query} query The `query` argument passed to {@link Mapper#destroyAll}. * @param {Object} opts The `opts` argument passed to {@link Mapper#destroyAll}. * @param {*} result The result, if any. * @since 3.0.0 */ afterDestroyAll: notify2, /** * Mapper lifecycle hook called by {@link Mapper#find}. If this method * returns a promise then {@link Mapper#find} will wait for the promise * to resolve before continuing. * * @method Mapper#afterFind * @param {(string|number)} id The `id` argument passed to {@link Mapper#find}. * @param {Object} opts The `opts` argument passed to {@link Mapper#find}. * @param {*} result The result, if any. * @since 3.0.0 */ afterFind: notify2, /** * Mapper lifecycle hook called by {@link Mapper#findAll}. If this method * returns a promise then {@link Mapper#findAll} will wait for the promise * to resolve before continuing. * * @method Mapper#afterFindAll * @param {Object} query The `query` argument passed to {@link Mapper#findAll}. * @param {Object} opts The `opts` argument passed to {@link Mapper#findAll}. * @param {*} result The result, if any. * @since 3.0.0 */ afterFindAll: notify2, /** * Mapper lifecycle hook called by {@link Mapper#sum}. If this method * returns a promise then {@link Mapper#sum} will wait for the promise * to resolve before continuing. * * @method Mapper#afterSum * @param {Object} query The `query` argument passed to {@link Mapper#sum}. * @param {Object} opts The `opts` argument passed to {@link Mapper#sum}. * @param {*} result The result, if any. * @since 3.0.0 */ afterSum: notify2, /** * Mapper lifecycle hook called by {@link Mapper#update}. If this method * returns a promise then {@link Mapper#update} will wait for the promise * to resolve before continuing. * * @method Mapper#afterUpdate * @param {(string|number)} id The `id` argument passed to {@link Mapper#update}. * @param {props} props The `props` argument passed to {@link Mapper#update}. * @param {Object} opts The `opts` argument passed to {@link Mapper#update}. * @param {*} result The result, if any. * @since 3.0.0 */ afterUpdate: notify2, /** * Mapper lifecycle hook called by {@link Mapper#updateAll}. If this method * returns a promise then {@link Mapper#updateAll} will wait for the promise * to resolve before continuing. * * @method Mapper#afterUpdateAll * @param {Object} props The `props` argument passed to {@link Mapper#updateAll}. * @param {Object} query The `query` argument passed to {@link Mapper#updateAll}. * @param {Object} opts The `opts` argument passed to {@link Mapper#updateAll}. * @param {*} result The result, if any. * @since 3.0.0 */ afterUpdateAll: notify2, /** * Mapper lifecycle hook called by {@link Mapper#updateMany}. If this method * returns a promise then {@link Mapper#updateMany} will wait for the promise * to resolve before continuing. * * @method Mapper#afterUpdateMany * @param {Array} records The `records` argument passed to {@link Mapper#updateMany}. * @param {Object} opts The `opts` argument passed to {@link Mapper#updateMany}. * @param {*} result The result, if any. * @since 3.0.0 */ afterUpdateMany: notify2, /** * Mapper lifecycle hook called by {@link Mapper#create}. If this method * returns a promise then {@link Mapper#create} will wait for the promise * to resolve before continuing. * * @method Mapper#beforeCreate * @param {Object} props The `props` argument passed to {@link Mapper#create}. * @param {Object} opts The `opts` argument passed to {@link Mapper#create}. * @since 3.0.0 */ beforeCreate: notify, /** * Mapper lifecycle hook called by {@link Mapper#createMany}. If this method * returns a promise then {@link Mapper#createMany} will wait for the promise * to resolve before continuing. * * @method Mapper#beforeCreateMany * @param {Array} records The `records` argument passed to {@link Mapper#createMany}. * @param {Object} opts The `opts` argument passed to {@link Mapper#createMany}. * @since 3.0.0 */ beforeCreateMany: notify, /** * Mapper lifecycle hook called by {@link Mapper#count}. If this method * returns a promise then {@link Mapper#count} will wait for the promise * to resolve before continuing. * * @method Mapper#beforeCount * @param {Object} query The `query` argument passed to {@link Mapper#count}. * @param {Object} opts The `opts` argument passed to {@link Mapper#count}. * @since 3.0.0 */ beforeCount: notify, /** * Mapper lifecycle hook called by {@link Mapper#destroy}. If this method * returns a promise then {@link Mapper#destroy} will wait for the promise * to resolve before continuing. * * @method Mapper#beforeDestroy * @param {(string|number)} id The `id` argument passed to {@link Mapper#destroy}. * @param {Object} opts The `opts` argument passed to {@link Mapper#destroy}. * @since 3.0.0 */ beforeDestroy: notify, /** * Mapper lifecycle hook called by {@link Mapper#destroyAll}. If this method * returns a promise then {@link Mapper#destroyAll} will wait for the promise * to resolve before continuing. * * @method Mapper#beforeDestroyAll * @param {query} query The `query` argument passed to {@link Mapper#destroyAll}. * @param {Object} opts The `opts` argument passed to {@link Mapper#destroyAll}. * @since 3.0.0 */ beforeDestroyAll: notify, /** * Mappers lifecycle hook called by {@link Mapper#find}. If this method * returns a promise then {@link Mapper#find} will wait for the promise * to resolve before continuing. * * @method Mapper#beforeFind * @param {(string|number)} id The `id` argument passed to {@link Mapper#find}. * @param {Object} opts The `opts` argument passed to {@link Mapper#find}. * @since 3.0.0 */ beforeFind: notify, /** * Mapper lifecycle hook called by {@link Mapper#findAll}. If this method * returns a promise then {@link Mapper#findAll} will wait for the promise * to resolve before continuing. * * @method Mapper#beforeFindAll * @param {Object} query The `query` argument passed to {@link Mapper#findAll}. * @param {Object} opts The `opts` argument passed to {@link Mapper#findAll}. * @since 3.0.0 */ beforeFindAll: notify, /** * Mapper lifecycle hook called by {@link Mapper#sum}. If this method * returns a promise then {@link Mapper#sum} will wait for the promise * to resolve before continuing. * * @method Mapper#beforeSum * @param {string} field The `field` argument passed to {@link Mapper#sum}. * @param {Object} query The `query` argument passed to {@link Mapper#sum}. * @param {Object} opts The `opts` argument passed to {@link Mapper#sum}. * @since 3.0.0 */ beforeSum: notify, /** * Mapper lifecycle hook called by {@link Mapper#update}. If this method * returns a promise then {@link Mapper#update} will wait for the promise * to resolve before continuing. * * @method Mapper#beforeUpdate * @param {(string|number)} id The `id` argument passed to {@link Mapper#update}. * @param {props} props The `props` argument passed to {@link Mapper#update}. * @param {Object} opts The `opts` argument passed to {@link Mapper#update}. * @since 3.0.0 */ beforeUpdate: notify, /** * Mapper lifecycle hook called by {@link Mapper#updateAll}. If this method * returns a promise then {@link Mapper#updateAll} will wait for the promise * to resolve before continuing. * * @method Mapper#beforeUpdateAll * @param {Object} props The `props` argument passed to {@link Mapper#updateAll}. * @param {Object} query The `query` argument passed to {@link Mapper#updateAll}. * @param {Object} opts The `opts` argument passed to {@link Mapper#updateAll}. * @since 3.0.0 */ beforeUpdateAll: notify, /** * Mapper lifecycle hook called by {@link Mapper#updateMany}. If this method * returns a promise then {@link Mapper#updateMany} will wait for the promise * to resolve before continuing. * * @method Mapper#beforeUpdateMany * @param {Array} records The `records` argument passed to {@link Mapper#updateMany}. * @param {Object} opts The `opts` argument passed to {@link Mapper#updateMany}. * @since 3.0.0 */ beforeUpdateMany: notify, /** * This method is called at the end of most lifecycle methods. It does the * following: * * 1. If `opts.raw` is `true`, add this Mapper's configuration to the `opts` * argument as metadata for the operation. * 2. Wrap the result data appropriately using {@link Mapper#wrap}, which * calls {@link Mapper#createRecord}. * * @method Mapper#_end * @private * @since 3.0.0 */ _end (result, opts, skip) { if (opts.raw) { utils._(result, opts) } if (skip) { return result } let _data = opts.raw ? result.data : result if (_data &amp;&amp; utils.isFunction(this.wrap)) { _data = this.wrap(_data, opts) if (opts.raw) { result.data = _data } else { result = _data } } return result }, /** * Define a belongsTo relationship. Only useful if you're managing your * Mappers manually and not using a Container or DataStore component. * * @example * PostService.belongsTo(UserService, { * // post.user_id points to user.id * foreignKey: 'user_id' * // user records will be attached to post records at &quot;post.user&quot; * localField: 'user' * }) * * CommentService.belongsTo(UserService, { * // comment.user_id points to user.id * foreignKey: 'user_id' * // user records will be attached to comment records at &quot;comment.user&quot; * localField: 'user' * }) * CommentService.belongsTo(PostService, { * // comment.post_id points to post.id * foreignKey: 'post_id' * // post records will be attached to comment records at &quot;comment.post&quot; * localField: 'post' * }) * * @method Mapper#belongsTo * @see http://www.js-data.io/v3.0/docs/relations * @since 3.0.0 */ belongsTo (relatedMapper, opts) { return belongsTo(relatedMapper, opts)(this) }, /** * Select records according to the `query` argument and return the count. * * {@link Mapper#beforeCount} will be called before calling the adapter. * {@link Mapper#afterCount} will be called after calling the adapter. * * @example &lt;caption&gt;Get the number of published blog posts&lt;/caption&gt; * PostService.count({ status: 'published' }).then((numPublished) =&gt; { * console.log(numPublished) // e.g. 45 * }) * * @method Mapper#count * @param {Object} [query={}] Selection query. See {@link query}. * @param {Object} [query.where] See {@link query.where}. * @param {number} [query.offset] See {@link query.offset}. * @param {number} [query.limit] See {@link query.limit}. * @param {string|Array[]} [query.orderBy] See {@link query.orderBy}. * @param {Object} [opts] Configuration options. Refer to the `count` method * of whatever adapter you're using for more configuration options. * @param {boolean} [opts.adapter={@link Mapper#defaultAdapter}] Name of the * adapter to use. * @param {boolean} [opts.notify={@link Mapper#notify}] See {@link Mapper#notify}. * @param {boolean} [opts.raw={@link Mapper#raw}] See {@link Mapper#raw}. * @returns {Promise} Resolves with the count of the selected records. * @since 3.0.0 */ count (query, opts) { return this.crud('count', query, opts) }, /** * Create and save a new the record using the provided `props`. * * {@link Mapper#beforeCreate} will be called before calling the adapter. * {@link Mapper#afterCreate} will be called after calling the adapter. * * @example &lt;caption&gt;Create and save a new blog post&lt;/caption&gt; * PostService.create({ * title: 'Modeling your data', * status: 'draft' * }).then((post) =&gt; { * console.log(post) // { id: 1234, status: 'draft', ... } * }) * * @method Mapper#create * @param {Object} props The properties for the new record. * @param {Object} [opts] Configuration options. Refer to the `create` method * of whatever adapter you're using for more configuration options. * @param {boolean} [opts.adapter={@link Mapper#defaultAdapter}] Name of the * adapter to use. * @param {boolean} [opts.notify={@link Mapper#notify}] See {@link Mapper#notify}. * @param {boolean} [opts.raw={@link Mapper#raw}] See {@link Mapper#raw}. * @param {string[]} [opts.with=[]] Relations to create in a cascading * create if `props` contains nested relations. NOT performed in a * transaction. Each nested create will result in another {@link Mapper#create} * or {@link Mapper#createMany} call. * @param {string[]} [opts.pass=[]] Relations to send to the adapter as part * of the payload. Normally relations are not sent. * @returns {Promise} Resolves with the created record. * @since 3.0.0 */ create (props, opts) { let op, adapter // Default values for arguments props || (props = {}) opts || (opts = {}) // Fill in &quot;opts&quot; with the Mapper's configuration utils._(opts, this) adapter = opts.adapter = this.getAdapterName(opts) // beforeCreate lifecycle hook op = opts.op = 'beforeCreate' return utils.resolve(this[op](props, opts)).then((_props) =&gt; { // Allow for re-assignment from lifecycle hook props = utils.isUndefined(_props) ? props : _props // Deep pre-create belongsTo relations const belongsToRelationData = {} opts.with || (opts.with = []) let tasks = [] utils.forEachRelation(this, opts, (def, optsCopy) =&gt; { const relationData = def.getLocalField(props) const relatedMapper = def.getRelation() const relatedIdAttribute = relatedMapper.idAttribute optsCopy.raw = false if (!relationData) { return } if (def.type === belongsToType) { // Create belongsTo relation first because we need a generated id to // attach to the child tasks.push(relatedMapper.create(relationData, optsCopy).then((data) =&gt; { def.setLocalField(belongsToRelationData, data) def.setForeignKey(props, data) })) } else if (def.type === hasManyType &amp;&amp; def.localKeys) { // Create his hasMany relation first because it uses localKeys tasks.push(relatedMapper.createMany(relationData, optsCopy).then((data) =&gt; { def.setLocalField(belongsToRelationData, data) utils.set(props, def.localKeys, data.map((record) =&gt; utils.get(record, relatedIdAttribute))) })) } }) return utils.Promise.all(tasks).then(() =&gt; { // Now delegate to the adapter for the main create op = opts.op = 'create' this.dbg(op, props, opts) return utils.resolve(this.getAdapter(adapter)[op](this, this.toJSON(props, { with: opts.pass || [] }), opts)) }).then((data) =&gt; { const createdRecord = opts.raw ? data.data : data // Deep post-create hasMany and hasOne relations tasks = [] utils.forEachRelation(this, opts, (def, optsCopy) =&gt; { const relationData = def.getLocalField(props) if (!relationData) { return } optsCopy.raw = false let task // Create hasMany and hasOne after the main create because we needed // a generated id to attach to these items if (def.type === hasManyType &amp;&amp; def.foreignKey) { def.setForeignKey(createdRecord, relationData) task = def.getRelation().createMany(relationData, optsCopy).then((data) =&gt; { def.setLocalField(createdRecord, data) }) } else if (def.type === hasOneType) { def.setForeignKey(createdRecord, relationData) task = def.getRelation().create(relationData, optsCopy).then((data) =&gt; { def.setLocalField(createdRecord, data) }) } else if (def.type === belongsToType &amp;&amp; def.getLocalField(belongsToRelationData)) { def.setLocalField(createdRecord, def.getLocalField(belongsToRelationData)) } else if (def.type === hasManyType &amp;&amp; def.localKeys &amp;&amp; def.getLocalField(belongsToRelationData)) { def.setLocalField(createdRecord, def.getLocalField(belongsToRelationData)) } if (task) { tasks.push(task) } }) return utils.Promise.all(tasks).then(() =&gt; { return data }) }) }).then((result) =&gt; { result = this._end(result, opts) // afterCreate lifecycle hook op = opts.op = 'afterCreate' return utils.resolve(this[op](props, opts, result)).then((_result) =&gt; { // Allow for re-assignment from lifecycle hook return utils.isUndefined(_result) ? result : _result }) }) }, /** * Use {@link Mapper#createRecord} instead. * @deprecated * @method Mapper#createInstance * @param {Object|Array} props See {@link Mapper#createRecord}. * @param {Object} [opts] See {@link Mapper#createRecord}. * @returns {Object|Array} See {@link Mapper#createRecord}. * @see Mapper#createRecord * @since 3.0.0 */ createInstance (props, opts) { return this.createRecord(props, opts) }, /** * Given an array of records, batch create them via an adapter. * * {@link Mapper#beforeCreateMany} will be called before calling the adapter. * {@link Mapper#afterCreateMany} will be called after calling the adapter. * * @example &lt;caption&gt;Create and save several new blog posts&lt;/caption&gt; * PostService.createMany([{ * title: 'Modeling your data', * status: 'draft' * }, { * title: 'Reading data', * status: 'draft' * }]).then((posts) =&gt; { * console.log(posts[0]) // { id: 1234, status: 'draft', ... } * console.log(posts[1]) // { id: 1235, status: 'draft', ... } * }) * * @method Mapper#createMany * @param {Record[]} records Array of records to be created in one batch. * @param {Object} [opts] Configuration options. Refer to the `createMany` * method of whatever adapter you're using for more configuration options. * @param {boolean} [opts.adapter={@link Mapper#defaultAdapter}] Name of the * adapter to use. * @param {boolean} [opts.notify={@link Mapper#notify}] See {@link Mapper#notify}. * @param {boolean} [opts.raw={@link Mapper#raw}] See {@link Mapper#raw}. * @param {string[]} [opts.with=[]] Relations to create in a cascading * create if `records` contains nested relations. NOT performed in a * transaction. Each nested create will result in another {@link Mapper#createMany} * call. * @param {string[]} [opts.pass=[]] Relations to send to the adapter as part * of the payload. Normally relations are not sent. * @returns {Promise} Resolves with the created records. * @since 3.0.0 * @tutorial [&quot;http://www.js-data.io/v3.0/docs/saving-data&quot;,&quot;Saving data&quot;] */ createMany (records, opts) { let op, adapter // Default values for arguments records || (records = []) opts || (opts = {}) // Fill in &quot;opts&quot; with the Mapper's configuration utils._(opts, this) adapter = opts.adapter = this.getAdapterName(opts) // beforeCreateMany lifecycle hook op = opts.op = 'beforeCreateMany' return utils.resolve(this[op](records, opts)).then((_records) =&gt; { // Allow for re-assignment from lifecycle hook records = utils.isUndefined(_records) ? records : _records // Deep pre-create belongsTo relations const belongsToRelationData = {} opts.with || (opts.with = []) let tasks = [] utils.forEachRelation(this, opts, (def, optsCopy) =&gt; { const relationData = records .map((record) =&gt; def.getLocalField(record)) .filter((relatedRecord) =&gt; relatedRecord) if (def.type === belongsToType &amp;&amp; relationData.length === records.length) { // Create belongsTo relation first because we need a generated id to // attach to the child tasks.push(def.getRelation().createMany(relationData, optsCopy).then((data) =&gt; { const relatedRecords = optsCopy.raw ? data.data : data def.setLocalField(belongsToRelationData, relatedRecords) records.forEach((record, i) =&gt; { def.setForeignKey(record, relatedRecords[i]) }) })) } }) return utils.Promise.all(tasks).then(() =&gt; { // Now delegate to the adapter op = opts.op = 'createMany' const json = records.map((record) =&gt; this.toJSON(record, { with: opts.pass || [] })) this.dbg(op, records, opts) return utils.resolve(this.getAdapter(adapter)[op](this, json, opts)) }).then((data) =&gt; { const createdRecords = opts.raw ? data.data : data // Deep post-create hasOne relations tasks = [] utils.forEachRelation(this, opts, (def, optsCopy) =&gt; { const relationData = records .map((record) =&gt; def.getLocalField(record)) .filter((relatedRecord) =&gt; relatedRecord) if (relationData.length !== records.length) { return } const belongsToData = def.getLocalField(belongsToRelationData) let task // Create hasMany and hasOne after the main create because we needed // a generated id to attach to these items if (def.type === hasManyType) { // Not supported this.log('warn', 'deep createMany of hasMany type not supported!') } else if (def.type === hasOneType) { createdRecords.forEach((createdRecord, i) =&gt; { def.setForeignKey(createdRecord, relationData[i]) }) task = def.getRelation().createMany(relationData, optsCopy).then((data) =&gt; { const relatedData = opts.raw ? data.data : data createdRecords.forEach((createdRecord, i) =&gt; { def.setLocalField(createdRecord, relatedData[i]) }) }) } else if (def.type === belongsToType &amp;&amp; belongsToData &amp;&amp; belongsToData.length === createdRecords.length) { createdRecords.forEach((createdRecord, i) =&gt; { def.setLocalField(createdRecord, belongsToData[i]) }) } if (task) { tasks.push(task) } }) return utils.Promise.all(tasks).then(() =&gt; data) }) }).then((result) =&gt; { result = this._end(result, opts) // afterCreateMany lifecycle hook op = opts.op = 'afterCreateMany' return utils.resolve(this[op](records, opts, result)).then((_result) =&gt; { // Allow for re-assignment from lifecycle hook return utils.isUndefined(_result) ? result : _result }) }) }, /** * Create an unsaved, uncached instance of this Mapper's * {@link Mapper#recordClass}. * * Returns `props` if `props` is already an instance of * {@link Mapper#recordClass}. * * __Note:__ This method does __not__ interact with any adapter, and does * __not__ save any data. It only creates new objects in memory. * * @example &lt;caption&gt;Create empty unsaved record instance&lt;/caption&gt; * const post = PostService.createRecord() * * @example &lt;caption&gt;Create an unsaved record instance with inital properties&lt;/caption&gt; * const post = PostService.createRecord({ * title: 'Modeling your data', * status: 'draft' * }) * * @example &lt;caption&gt;Create a record instance that corresponds to a saved record&lt;/caption&gt; * const post = PostService.createRecord({ * // JSData thinks this record has been saved if it has a primary key * id: 1234, * title: 'Modeling your data', * status: 'draft' * }) * * @example &lt;caption&gt;Create record instances from an array&lt;/caption&gt; * const posts = PostService.createRecord([{ * title: 'Modeling your data', * status: 'draft' * }, { * title: 'Reading data', * status: 'draft' * }]) * * @example &lt;caption&gt;Records are validated by default&lt;/caption&gt; * import {Mapper} from 'js-data' * const PostService = new Mapper({ * name: 'post', * schema: { properties: { title: { type: 'string' } } } * }) * try { * const post = PostService.createRecord({ * title: 1234, * }) * } catch (err) { * console.log(err.errors) // [{ expected: 'one of (string)', actual: 'number', path: 'title' }] * } * * @example &lt;caption&gt;Skip validation&lt;/caption&gt; * import {Mapper} from 'js-data' * const PostService = new Mapper({ * name: 'post', * schema: { properties: { title: { type: 'string' } } } * }) * const post = PostService.createRecord({ * title: 1234, * }, { noValidate: true }) * console.log(post.isValid()) // false * * @method Mapper#createRecord * @param {Object|Object[]} props The properties for the Record instance or an * array of property objects for the Record instances. * @param {Object} [opts] Configuration options. * @param {boolean} [opts.noValidate=false] Whether to skip validation when * the Record instances are created. * @returns {Record|Record[]} The Record instance or Record instances. * @since 3.0.0 */ createRecord (props, opts) { props || (props = {}) if (utils.isArray(props)) { return props.map((_props) =&gt; this.createRecord(_props, opts)) } if (!utils.isObject(props)) { throw utils.err(`${DOMAIN}#createRecord`, 'props')(400, 'array or object', props) } const recordClass = this.recordClass const relationList = this.relationList || [] relationList.forEach(function (def) { const relatedMapper = def.getRelation() const relationData = def.getLocalField(props) if (relationData &amp;&amp; !relatedMapper.is(relationData)) { if (utils.isArray(relationData) &amp;&amp; (!relationData.length || relatedMapper.is(relationData[0]))) { return } utils.set(props, def.localField, relatedMapper.createRecord(relationData, opts)) } }) // Check to make sure &quot;props&quot; is not already an instance of this Mapper. return recordClass ? (props instanceof recordClass ? props : new recordClass(props, opts)) : props // eslint-disable-line }, /** * Lifecycle invocation method. * * TODO: Improve documentation for this method. * * @method Mapper#crud * @param {string} method Name of the lifecycle method to invoke. * @param {...*} args Arguments to pass to the lifecycle method. * @returns {Promise} * @since 3.0.0 */ crud (method, ...args) { const config = this.lifecycleMethods[method] if (!config) { throw utils.err(`${DOMAIN}#crud`, method)(404, 'method') } const upper = `${method.charAt(0).toUpperCase()}${method.substr(1)}` const before = `before${upper}` const after = `after${upper}` let op, adapter // Default values for arguments config.defaults.forEach((value, i) =&gt; { if (utils.isUndefined(args[i])) { args[i] = utils.copy(value) } }) const opts = args[args.length - 1] // Fill in &quot;opts&quot; with the Mapper's configuration utils._(opts, this) adapter = opts.adapter = this.getAdapterName(opts) // before lifecycle hook op = opts.op = before return utils.resolve(this[op](...args)).then((_value) =&gt; { if (!utils.isUndefined(args[config.beforeAssign])) { // Allow for re-assignment from lifecycle hook args[config.beforeAssign] = utils.isUndefined(_value) ? args[config.beforeAssign] : _value } // Now delegate to the adapter op = opts.op = method args = config.adapterArgs ? config.adapterArgs(this, ...args) : args this.dbg(op, ...args) return utils.resolve(this.getAdapter(adapter)[op](this, ...args)) }).then((result) =&gt; { result = this._end(result, opts, !!config.skip) args.push(result) // after lifecycle hook op = opts.op = after return utils.resolve(this[op](...args)).then((_result) =&gt; { // Allow for re-assignment from lifecycle hook return utils.isUndefined(_result) ? result : _result }) }) }, /** * Using an adapter, destroy the record with the given primary key. * * {@link Mapper#beforeDestroy} will be called before destroying the record. * {@link Mapper#afterDestroy} will be called after destroying the record. * * @example &lt;caption&gt;Destroy a specific blog post&lt;/caption&gt; * PostService.destroy(1234).then(() =&gt; { * // Blog post #1234 has been destroyed * }) * * @example &lt;caption&gt;Get full response&lt;/caption&gt; * PostService.destroy(1234, { raw: true }).then((result) =&gt; { * console.log(result.deleted) e.g. 1 * console.log(...) // etc., more metadata can be found on the result * }) * * @method Mapper#destroy * @param {(string|number)} id The primary key of the record to destroy. * @param {Object} [opts] Configuration options. Refer to the `destroy` method * of whatever adapter you're using for more configuration options. * @param {boolean} [opts.adapter={@link Mapper#defaultAdapter}] Name of the * adapter to use. * @param {boolean} [opts.notify={@link Mapper#notify}] See {@link Mapper#notify}. * @param {boolean} [opts.raw={@link Mapper#raw}] See {@link Mapper#raw}. * @returns {Promise} Resolves when the record has been destroyed. Resolves * even if no record was found to be destroyed. * @since 3.0.0 * @tutorial [&quot;http://www.js-data.io/v3.0/docs/saving-data&quot;,&quot;Saving data&quot;] */ destroy (id, opts) { return this.crud('destroy', id, opts) }, /** * Destroy the records selected by `query` via an adapter. If no `query` is * provided then all records will be destroyed. * * {@link Mapper#beforeDestroyAll} will be called before destroying the records. * {@link Mapper#afterDestroyAll} will be called after destroying the records. * * @example &lt;caption&gt;Destroy all blog posts&lt;/caption&gt; * PostService.destroyAll().then(() =&gt; { * // All blog posts have been destroyed * }) * * @example &lt;caption&gt;Destroy all &quot;draft&quot; blog posts&lt;/caption&gt; * PostService.destroyAll({ status: 'draft' }).then(() =&gt; { * // All &quot;draft&quot; blog posts have been destroyed * }) * * @example &lt;caption&gt;Get full response&lt;/caption&gt; * const query = null * const options = { raw: true } * PostService.destroyAll(query, options).then((result) =&gt; { * console.log(result.deleted) e.g. 14 * console.log(...) // etc., more metadata can be found on the result * }) * * @method Mapper#destroyAll * @param {Object} [query={}] Selection query. See {@link query}. * @param {Object} [query.where] See {@link query.where}. * @param {number} [query.offset] See {@link query.offset}. * @param {number} [query.limit] See {@link query.limit}. * @param {string|Array[]} [query.orderBy] See {@link query.orderBy}. * @param {Object} [opts] Configuration options. Refer to the `destroyAll` * method of whatever adapter you're using for more configuration options. * @param {boolean} [opts.adapter={@link Mapper#defaultAdapter}] Name of the * adapter to use. * @param {boolean} [opts.notify={@link Mapper#notify}] See {@link Mapper#notify}. * @param {boolean} [opts.raw={@link Mapper#raw}] See {@link Mapper#raw}. * @returns {Promise} Resolves when the records have been destroyed. Resolves * even if no records were found to be destroyed. * @see query * @since 3.0.0 * @tutorial [&quot;http://www.js-data.io/v3.0/docs/saving-data&quot;,&quot;Saving data&quot;] */ destroyAll (query, opts) { return this.crud('destroyAll', query, opts) }, /** * Retrieve via an adapter the record with the given primary key. * * {@link Mapper#beforeFind} will be called before calling the adapter. * {@link Mapper#afterFind} will be called after calling the adapter. * * @example * PostService.find(1).then((post) =&gt; { * console.log(post) // { id: 1, ...} * }) * * @example &lt;caption&gt;Get full response&lt;/caption&gt; * PostService.find(1, { raw: true }).then((result) =&gt; { * console.log(result.data) // { id: 1, ...} * console.log(result.found) // 1 * console.log(...) // etc., more metadata can be found on the result * }) * * @method Mapper#find * @param {(string|number)} id The primary key of the record to retrieve. * @param {Object} [opts] Configuration options. Refer to the `find` method * of whatever adapter you're using for more configuration options. * @param {boolean} [opts.adapter={@link Mapper#defaultAdapter}] Name of the * adapter to use. * @param {boolean} [opts.notify={@link Mapper#notify}] See {@link Mapper#notify}. * @param {boolean} [opts.raw={@link Mapper#raw}] See {@link Mapper#raw}. * @param {string[]} [opts.with=[]] Relations to eager load in the request. * @returns {Promise} Resolves with the found record. Resolves with * `undefined` if no record was found. * @see http://www.js-data.io/v3.0/docs/reading-data * @since 3.0.0 * @tutorial [&quot;http://www.js-data.io/v3.0/docs/reading-data&quot;,&quot;Reading data&quot;] */ find (id, opts) { return this.crud('find', id, opts) }, /** * Using the `query` argument, select records to retrieve via an adapter. * * {@link Mapper#beforeFindAll} will be called before calling the adapter. * {@link Mapper#afterFindAll} will be called after calling the adapter. * * @example &lt;caption&gt;Find all &quot;published&quot; blog posts&lt;/caption&gt; * PostService.findAll({ status: 'published' }).then((posts) =&gt; { * console.log(posts) // [{ id: 1, status: 'published', ...}, ...] * }) * * @example &lt;caption&gt;Get full response&lt;/caption&gt; * PostService.findAll({ status: 'published' }, { raw: true }).then((result) =&gt; { * console.log(result.data) // [{ id: 1, status: 'published', ...}, ...] * console.log(result.found) // e.g. 13 * console.log(...) // etc., more metadata can be found on the result * }) * * @method Mapper#findAll * @param {Object} [query={}] Selection query. See {@link query}. * @param {Object} [query.where] See {@link query.where}. * @param {number} [query.offset] See {@link query.offset}. * @param {number} [query.limit] See {@link query.limit}. * @param {string|Array[]} [query.orderBy] See {@link query.orderBy}. * @param {Object} [opts] Configuration options. Refer to the `findAll` method * of whatever adapter you're using for more configuration options. * @param {boolean} [opts.adapter={@link Mapper#defaultAdapter}] Name of the * adapter to use. * @param {boolean} [opts.notify={@link Mapper#notify}] See {@link Mapper#notify}. * @param {boolean} [opts.raw={@link Mapper#raw}] See {@link Mapper#raw}. * @param {string[]} [opts.with=[]] Relations to eager load in the request. * @returns {Promise} Resolves with the found records, if any. * @see query * @since 3.0.0 * @tutorial [&quot;http://www.js-data.io/v3.0/docs/reading-data&quot;,&quot;Reading data&quot;] */ findAll (query, opts) { return this.crud('findAll', query, opts) }, /** * Return the registered adapter with the given name or the default adapter if * no name is provided. * * @method Mapper#getAdapter * @param {string} [name] The name of the adapter to retrieve. * @returns {Adapter} The adapter. * @since 3.0.0 * @tutorial [&quot;http://www.js-data.io/v3.0/docs/connecting-to-a-data-source&quot;,&quot;Connecting to a data source&quot;] */ getAdapter (name) { this.dbg('getAdapter', 'name:', name) const adapter = this.getAdapterName(name) if (!adapter) { throw utils.err(`${DOMAIN}#getAdapter`, 'name')(400, 'string', name) } return this.getAdapters()[adapter] }, /** * Return the name of a registered adapter based on the given name or options, * or the name of the default adapter if no name provided. * * @method Mapper#getAdapterName * @param {(Object|string)} [opts] The name of an adapter or options, if any. * @returns {string} The name of the adapter. * @since 3.0.0 * @tutorial [&quot;http://www.js-data.io/v3.0/docs/connecting-to-a-data-source&quot;,&quot;Connecting to a data source&quot;] */ getAdapterName (opts) { opts || (opts = {}) if (utils.isString(opts)) { opts = { adapter: opts } } return opts.adapter || opts.defaultAdapter }, /** * Get the object of registered adapters for this Mapper. * * @method Mapper#getAdapters * @returns {Object} {@link Mapper#_adapters} * @since 3.0.0 * @tutorial [&quot;http://www.js-data.io/v3.0/docs/connecting-to-a-data-source&quot;,&quot;Connecting to a data source&quot;] */ getAdapters () { return this._adapters }, /** * Returns this Mapper's {@link Schema}. * * @method Mapper#getSchema * @returns {Schema} This Mapper's {@link Schema}. * @see Mapper#schema * @since 3.0.0 */ getSchema () { return this.schema }, /** * Defines a hasMany relationship. Only useful if you're managing your * Mappers manually and not using a Container or DataStore component. * * @example * UserService.hasMany(PostService, { * // post.user_id points to user.id * foreignKey: 'user_id' * // post records will be attached to user records at &quot;user.posts&quot; * localField: 'posts' * }) * * @method Mapper#hasMany * @see http://www.js-data.io/v3.0/docs/relations * @since 3.0.0 */ hasMany (relatedMapper, opts) { return hasMany(relatedMapper, opts)(this) }, /** * Defines a hasOne relationship. Only useful if you're managing your Mappers * manually and not using a {@link Container} or {@link DataStore} component. * * @example * UserService.hasOne(ProfileService, { * // profile.user_id points to user.id * foreignKey: 'user_id' * // profile records will be attached to user records at &quot;user.profile&quot; * localField: 'profile' * }) * * @method Mapper#hasOne * @see http://www.js-data.io/v3.0/docs/relations * @since 3.0.0 */ hasOne (relatedMapper, opts) { return hasOne(relatedMapper, opts)(this) }, /** * Return whether `record` is an instance of this Mapper's recordClass. * * @example * const post = PostService.createRecord() * * console.log(PostService.is(post)) // true * // Equivalent to what's above * console.log(post instanceof PostService.recordClass) // true * * @method Mapper#is * @param {Object|Record} record The record to check. * @returns {boolean} Whether `record` is an instance of this Mapper's * {@link Mapper#recordClass}. * @since 3.0.0 */ is (record) { const recordClass = this.recordClass return recordClass ? record instanceof recordClass : false }, /** * Register an adapter on this Mapper under the given name. * * @method Mapper#registerAdapter * @param {string} name The name of the adapter to register. * @param {Adapter} adapter The adapter to register. * @param {Object} [opts] Configuration options. * @param {boolean} [opts.default=false] Whether to make the adapter the * default adapter for this Mapper. * @since 3.0.0 * @tutorial [&quot;http://www.js-data.io/v3.0/docs/connecting-to-a-data-source&quot;,&quot;Connecting to a data source&quot;] */ registerAdapter (name, adapter, opts) { opts || (opts = {}) this.getAdapters()[name] = adapter // Optionally make it the default adapter for the target. if (opts === true || opts.default) { this.defaultAdapter = name } }, /** * Select records according to the `query` argument, and aggregate the sum * value of the property specified by `field`. * * {@link Mapper#beforeSum} will be called before calling the adapter. * {@link Mapper#afterSum} will be called after calling the adapter. * * @example * PurchaseOrderService.sum('amount', { status: 'paid' }).then((amountPaid) =&gt; { * console.log(amountPaid) // e.g. 451125.34 * }) * * @method Mapper#sum * @param {string} field The field to sum. * @param {Object} [query={}] Selection query. See {@link query}. * @param {Object} [query.where] See {@link query.where}. * @param {number} [query.offset] See {@link query.offset}. * @param {number} [query.limit] See {@link query.limit}. * @param {string|Array[]} [query.orderBy] See {@link query.orderBy}. * @param {Object} [opts] Configuration options. Refer to the `sum` method * of whatever adapter you're using for more configuration options. * @param {boolean} [opts.adapter={@link Mapper#defaultAdapter}] Name of the * adapter to use. * @param {boolean} [opts.notify={@link Mapper#notify}] See {@link Mapper#notify}. * @param {boolean} [opts.raw={@link Mapper#raw}] See {@link Mapper#raw}. * @returns {Promise} Resolves with the aggregated sum. * @since 3.0.0 */ sum (field, query, opts) { return this.crud('sum', field, query, opts) }, /** * Return a plain object representation of the given record. Relations can * be optionally be included. Non-schema properties can be excluded. * * @example * import {Mapper, Schema} from 'js-data' * const PersonService = new Mapper({ * name: 'person', * schema: { * properties: { * name: { type: 'string' }, * id: { type: 'string' } * } * } * }) * const person = PersonService.createRecord({ id: 1, name: 'John', foo: 'bar' }) * console.log(PersonService.toJSON(person)) // {&quot;id&quot;:1,&quot;name&quot;:&quot;John&quot;,&quot;foo&quot;:&quot;bar&quot;} * console.log(PersonService.toJSON(person), { strict: true }) // {&quot;id&quot;:1,&quot;name&quot;:&quot;John&quot;} * * @method Mapper#toJSON * @param {Record|Record[]} records Record or records from which to create a * POJO representation. * @param {Object} [opts] Configuration options. * @param {boolean} [opts.strict] Whether to include properties that are not * defined in {@link Mapper#schema}. * @param {string[]} [opts.with] Array of relation names or relation fields * to include in the POJO representation. * @param {boolean} [opts.withAll] Whether to simply include all relations in * the representation. Overrides `opts.with`. * @returns {Object|Object[]} POJO representation of the record or records. * @since 3.0.0 */ toJSON (records, opts) { let record opts || (opts = {}) if (utils.isArray(records)) { return records.map((record) =&gt; this.toJSON(record, opts)) } else { record = records } const relationFields = (this ? this.relationFields : []) || [] let json = {} let properties if (this &amp;&amp; this.schema) { properties = this.schema.properties || {} // TODO: Make this work recursively utils.forOwn(properties, (opts, prop) =&gt; { json[prop] = utils.plainCopy(record[prop]) }) } properties || (properties = {}) if (!opts.strict) { for (var key in record) { if (!properties[key] &amp;&amp; relationFields.indexOf(key) === -1) { json[key] = utils.plainCopy(record[key]) } } } // The user wants to include relations in the resulting plain object // representation if (this &amp;&amp; opts.withAll) { opts.with = relationFields.slice() } if (this &amp;&amp; opts.with) { if (utils.isString(opts.with)) { opts.with = [opts.with] } utils.forEachRelation(this, opts, (def, optsCopy) =&gt; { const relationData = def.getLocalField(record) if (relationData) { // The actual recursion if (utils.isArray(relationData)) { def.setLocalField(json, relationData.map((item) =&gt; { return def.getRelation().toJSON(item, optsCopy) })) } else { def.setLocalField(json, def.getRelation().toJSON(relationData, optsCopy)) } } }) } return json }, /** * Using an adapter, update the record with the primary key specified by the * `id` argument. * * {@link Mapper#beforeUpdate} will be called before updating the record. * {@link Mapper#afterUpdate} will be called after updating the record. * * @example &lt;caption&gt;Update a specific post&lt;/caption&gt; * PostService.update(1234, { * status: 'published', * published_at: new Date() * }).then((post) =&gt; { * console.log(post) // { id: 1234, status: 'published', ... } * }) * * @method Mapper#update * @param {(string|number)} id The primary key of the record to update. * @param {Object} props The update to apply to the record. * @param {Object} [opts] Configuration options. Refer to the `update` method * of whatever adapter you're using for more configuration options. * @param {boolean} [opts.adapter={@link Mapper#defaultAdapter}] Name of the * adapter to use. * @param {boolean} [opts.notify={@link Mapper#notify}] See {@link Mapper#notify}. * @param {boolean} [opts.raw={@link Mapper#raw}] See {@link Mapper#raw}. * transaction. * @returns {Promise} Resolves with the updated record. Rejects if the record * could not be found. * @since 3.0.0 * @tutorial [&quot;http://www.js-data.io/v3.0/docs/saving-data&quot;,&quot;Saving data&quot;] */ update (id, props, opts) { return this.crud('update', id, props, opts) }, /** * Using the `query` argument, perform the a single updated to the selected * records. * * {@link Mapper#beforeUpdateAll} will be called before making the update. * {@link Mapper#afterUpdateAll} will be called after making the update. * * @example &lt;caption&gt;Turn all of John's blog posts into drafts.&lt;/caption&gt; * const update = { status: draft: published_at: null } * const query = { userId: 1234 } * PostService.updateAll(update, query).then((posts) =&gt; { * console.log(posts) // [...] * }) * * @method Mapper#updateAll * @param {Object} props Update to apply to selected records. * @param {Object} [query={}] Selection query. See {@link query}. * @param {Object} [query.where] See {@link query.where}. * @param {number} [query.offset] See {@link query.offset}. * @param {number} [query.limit] See {@link query.limit}. * @param {string|Array[]} [query.orderBy] See {@link query.orderBy}. * @param {Object} [opts] Configuration options. Refer to the `updateAll` * method of whatever adapter you're using for more configuration options. * @param {boolean} [opts.adapter={@link Mapper#defaultAdapter}] Name of the * adapter to use. * @param {boolean} [opts.notify={@link Mapper#notify}] See {@link Mapper#notify}. * @param {boolean} [opts.raw={@link Mapper#raw}] See {@link Mapper#raw}. * @returns {Promise} Resolves with the update records, if any. * @see query * @since 3.0.0 * @tutorial [&quot;http://www.js-data.io/v3.0/docs/saving-data&quot;,&quot;Saving data&quot;] */ updateAll (props, query, opts) { return this.crud('updateAll', props, query, opts) }, /** * Given an array of updates, perform each of the updates via an adapter. Each * &quot;update&quot; is a hash of properties with which to update an record. Each * update must contain the primary key of the record to be updated. * * {@link Mapper#beforeUpdateMany} will be called before making the update. * {@link Mapper#afterUpdateMany} will be called after making the update. * * @example * PostService.updateMany([ * { id: 1234, status: 'draft' }, * { id: 2468, status: 'published', published_at: new Date() } * ]).then((posts) =&gt; { * console.log(posts) // [...] * }) * * @method Mapper#updateMany * @param {Record[]} records Array up record updates. * @param {Object} [opts] Configuration options. Refer to the `updateMany` * method of whatever adapter you're using for more configuration options. * @param {boolean} [opts.adapter={@link Mapper#defaultAdapter}] Name of the * adapter to use. * @param {boolean} [opts.notify={@link Mapper#notify}] See {@link Mapper#notify}. * @param {boolean} [opts.raw={@link Mapper#raw}] See {@link Mapper#raw}. * @returns {Promise} Resolves with the updated records. Rejects if any of the * records could be found. * @since 3.0.0 * @tutorial [&quot;http://www.js-data.io/v3.0/docs/saving-data&quot;,&quot;Saving data&quot;] */ updateMany (records, opts) { return this.crud('updateMany', records, opts) }, /** * Validate the given record or records according to this Mapper's * {@link Schema}. If there are no validation errors then the return value * will be `undefined`. * * @example * import {Mapper, Schema} from 'js-data' * const PersonSchema = new Schema({ * properties: { * name: { type: 'string' }, * id: { type: 'string' } * } * }) * const PersonService = new Mapper({ * name: 'person', * schema: PersonSchema * }) * let errors = PersonService.validate({ name: 'John' }) * console.log(errors) // undefined * errors = PersonService.validate({ name: 123 }) * console.log(errors) // [{ expected: 'one of (string)', actual: 'number', path: 'name' }] * * @method Mapper#validate * @param {Object|Object[]} record The record or records to validate. * @param {Object} [opts] Configuration options. Passed to * {@link Schema#validate}. * @returns {Object[]} Array of errors or `undefined` if no errors. * @since 3.0.0 */ validate (record, opts) { opts || (opts = {}) const schema = this.getSchema() const _opts = utils.pick(opts, ['existingOnly']) if (utils.isArray(record)) { const errors = record.map((_record) =&gt; schema.validate(_record, utils.pick(_opts, ['existingOnly']))) let hasErrors = false errors.forEach(function (err) { if (err) { hasErrors = true } }) if (hasErrors) { return errors } return undefined } return schema.validate(record, _opts) }, /** * Method used to wrap data returned by an adapter with this Mapper's * {@link Mapper#recordClass}. This method is used by all of a Mapper's CRUD * methods. The provided implementation of this method assumes that the `data` * passed to it is a record or records that need to be wrapped with * {@link Mapper#createRecord}. Override with care. * * Provided implementation of {@link Mapper#wrap}: * * ``` * function (data, opts) { * return this.createRecord(data, opts) * } * ``` * * @example &lt;caption&gt;Override to customize behavior&lt;/caption&gt; * const PostMapper = new Mapper({ * name: 'post', * wrap (data, opts) { * const originalWrap = this.constructor.prototype.wrap * // Let's say &quot;GET /post&quot; doesn't return JSON quite like JSData expects, * // but the actual post records are nested under a &quot;posts&quot; field. So, * // we override Mapper#wrap to handle this special case. * if (opts.op === 'findAll') { * return originalWrap.call(this, data.posts, opts) * } * // Otherwise perform original behavior * return originalWrap.call(this, data, opts) * } * }) * * @method Mapper#wrap * @param {Object|Object[]} data The record or records to be wrapped. * @param {Object} [opts] Configuration options. Passed to {@link Mapper#createRecord}. * @returns {Record|Record[]} The wrapped record or records. * @since 3.0.0 */ wrap (data, opts) { return this.createRecord(data, opts) }, /** * @ignore */ defineRelations() { // Setup the mapper's relations, including generating Mapper#relationList // and Mapper#relationFields utils.forOwn(this.relations, (group, type) =&gt; { utils.forOwn(group, (relations, _name) =&gt; { if (utils.isObject(relations)) { relations = [relations] } relations.forEach((def) =&gt; { const relatedMapper = this.datastore.getMapperByName(_name) || _name def.getRelation = () =&gt; this.datastore.getMapper(_name) if (typeof Relation[type] !== 'function') { throw utils.err(DOMAIN, 'defineRelations')(400, 'relation type (hasOne, hasMany, etc)', type, true) } this[type](relatedMapper, def) }) }) }) } }) /** * Create a subclass of this Mapper. * * @example &lt;caption&gt;Extend the class in a cross-browser manner.&lt;/caption&gt; * import {Mapper} from 'js-data' * const CustomMapperClass = Mapper.extend({ * foo () { return 'bar' } * }) * const customMapper = new CustomMapperClass({ name: 'test' }) * console.log(customMapper.foo()) // &quot;bar&quot; * * @example &lt;caption&gt;Extend the class using ES2015 class syntax.&lt;/caption&gt; * class CustomMapperClass extends Mapper { * foo () { return 'bar' } * } * const customMapper = new CustomMapperClass({ name: 'test' }) * console.log(customMapper.foo()) // &quot;bar&quot; * * @method Mapper.extend * @param {Object} [props={}] Properties to add to the prototype of the * subclass. * @param {Object} [classProps={}] Static properties to add to the subclass. * @returns {Constructor} Subclass of this Mapper class. * @since 3.0.0 */ × Search results Close api.js-data.io • js-data.io "},"index.js.html":{"id":"index.js.html","title":"Source: index.js","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentDataStoreLinkedCollectionMapperQueryRecordSchema Source: index.js /** * Registered as `js-data` in NPM and Bower. * * Also available from CDN.JS and JSDelivr. * * @module js-data * * @example &lt;caption&gt;Install from NPM&lt;/caption&gt; * npm i --save js-data@beta * @example &lt;caption&gt;Install from Bower&lt;/caption&gt; * bower i --save js-data@3.0.0-beta.1 * @example &lt;caption&gt;Install from CDN.JS&lt;/caption&gt; * &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/js-data/3.0.0-beta.1/js-data.min.js&quot;&gt;&lt;/script&gt; * @example &lt;caption&gt;Install from JSDelivr&lt;/caption&gt; * &lt;script src=&quot;https://cdn.jsdelivr.net/js-data/3.0.0-beta.1/js-data.min.js&quot;&gt;&lt;/script&gt; * @example &lt;caption&gt;Load into your app via script tag&lt;/caption&gt; * &lt;script src=&quot;/path/to/js-data.min.js&quot;&gt;&lt;/script&gt; * &lt;script&gt; * console.log(JSData.version.full); // &quot;3.0.0-beta.1&quot; * &lt;/script&gt; * @example &lt;caption&gt;Load into your app via CommonJS&lt;/caption&gt; * var JSData = require('js-data'); * @example &lt;caption&gt;Load into your app via ES2015 Modules&lt;/caption&gt; * import * as JSData from 'js-data'; * @example &lt;caption&gt;Load into your app via AMD&lt;/caption&gt; * define('myApp', ['js-data'], function (JSData) { ... }) */ /** * Describes the version of this `JSData` object. * * @example * console.log(JSData.version.full) // &quot;3.0.0-beta.1&quot; * * @name version * @memberof module:js-data * @property {string} full The full semver value. * @property {number} major The major version number. * @property {number} minor The minor version number. * @property {number} patch The patch version number. * @property {(string|boolean)} alpha The alpha version value, otherwise `false` * if the current version is not alpha. * @property {(string|boolean)} beta The beta version value, otherwise `false` * if the current version is not beta. * @since 2.0.0 * @type {Object} */ export const version = '&lt;%= version %&gt;' /** * JSData's utility methods. * * @example * import {utils} from 'js-data' * console.log(utils.isString('foo')) // true * * @name module:js-data.utils * @property {Function} Promise See {@link utils.Promise}. * @see utils * @since 3.0.0 * @type {Object} */ import utils from './utils' /** * JSData's {@link Collection} class. * * @example * import {Collection} from 'js-data' * const collection = new Collection() * * @name module:js-data.Collection * @see Collection * @since 3.0.0 * @tutorial [&quot;http://www.js-data.io/v3.0/docs/components-of-jsdata#collection&quot;,&quot;Components of JSData: Collection&quot;] * @type {Constructor} */ import Collection from './Collection' /** * JSData's {@link Component} class. Most components in JSData extend this * class. * * @example * import {Component} from 'js-data' * // Make a custom component. * const MyComponent = Component.extend({ * myMethod (someArg) { ... } * }) * * @name module:js-data.Component * @see Component * @since 3.0.0 * @type {Constructor} */ import Component from './Component' /** * JSData's {@link Container} class. Defines and manages {@link Mapper}s. Used * in Node.js and in the browser, though in the browser you may want to use * {@link DataStore} instead. * * @example * import {Container} from 'js-data' * const store = new Container() * * @name module:js-data.Container * @see Container * @since 3.0.0 * @tutorial [&quot;http://www.js-data.io/v3.0/docs/components-of-jsdata#container&quot;,&quot;Components of JSData: Container&quot;] * @type {Constructor} */ import {Container} from './Container' /** * JSData's {@link DataStore} class. Primarily for use in the browser. In * Node.js you probably want to use {@link Container} instead. * * @example * import {DataStore} from 'js-data' * const store = new DataStore() * * @name module:js-data.DataStore * @see DataStore * @since 3.0.0 * @tutorial [&quot;http://www.js-data.io/v3.0/docs/components-of-jsdata#datastore&quot;,&quot;Components of JSData: DataStore&quot;] * @type {Constructor} */ import DataStore from './DataStore' /** * JSData's {@link Index} class, based on [mindex]{@link https://github.com/internalfx/mindex}. * * @name module:js-data.Index * @see Index * @since 3.0.0 * @type {Constructor} */ import Index from '../lib/mindex/index' /** * JSData's {@link LinkedCollection} class. Used by the {@link DataStore} * component. If you need to create a collection manually, you should probably * use the {@link Collection} class. * * @name module:js-data.LinkedCollection * @see DataStore * @see LinkedCollection * @since 3.0.0 * @type {Constructor} */ import LinkedCollection from './LinkedCollection' /** * JSData's {@link Mapper} class. The core of the ORM. * * @example &lt;caption&gt;Recommended use&lt;/caption&gt; * import {Container} from 'js-data' * const store = new Container() * store.defineMapper('user') * * @example &lt;caption&gt;Create Mapper manually&lt;/caption&gt; * import {Mapper} from 'js-data' * const UserMapper = new Mapper({ name: 'user' }) * * @name module:js-data.Mapper * @see Container * @see Mapper * @since 3.0.0 * @tutorial [&quot;http://www.js-data.io/v3.0/docs/modeling-your-data&quot;,&quot;Modeling your data&quot;] * @tutorial [&quot;http://www.js-data.io/v3.0/docs/components-of-jsdata#mapper&quot;,&quot;Components of JSData: Mapper&quot;] * @type {Constructor} */ import Mapper from './Mapper' /** * JSData's {@link Query} class. Used by the {@link Collection} component. * * @name module:js-data.Query * @see Query * @since 3.0.0 * @type {Constructor} */ import Query from './Query' /** * JSData's {@link Record} class. * * @example * import {Container} from 'js-data' * const store = new Container() * store.defineMapper('user') * const user = store.createRecord('user') * * @name module:js-data.Record * @see Record * @since 3.0.0 * @tutorial [&quot;http://www.js-data.io/v3.0/docs/components-of-jsdata#record&quot;,&quot;Components of JSData: Record&quot;] * @type {Constructor} */ import Record from './Record' /** * JSData's {@link Schema} class. Implements http://json-schema.org/draft-04. * * @example * import {Container, Schema} from 'js-data' * const userSchema = new Schema({ * properties: { * id: { type: 'string' }, * name: { type: 'string' } * } * }) * const store = new Container() * store.defineMapper('user', { * schema: userSchema * }) * * @name module:js-data.Schema * @see Schema * @see http://json-schema.org/ * @since 3.0.0 * @tutorial [&quot;http://www.js-data.io/v3.0/docs/components-of-jsdata#schema&quot;,&quot;Components of JSData: schema&quot;] * @tutorial [&quot;http://www.js-data.io/v3.0/docs/schemas&quot;,&quot;JSData's Schema Syntax&quot;] * @type {Constructor} */ import Schema from './Schema' export * from './decorators' export { Collection, Component, Container, DataStore, Index, LinkedCollection, Mapper, Query, Record, Schema, utils } × Search results Close api.js-data.io • js-data.io "},"decorators.js.html":{"id":"decorators.js.html","title":"Source: decorators.js","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentDataStoreLinkedCollectionMapperQueryRecordSchema Source: decorators.js import { Relation } from './relations' export { belongsToType, hasManyType, hasOneType } from './relations' /** * TODO * * @name module:js-data.belongsTo * @method * @param {Mapper} related The relation the target belongs to. * @param {Object} opts Configuration options. * @param {string} opts.foreignKey The field that holds the primary key of the * related record. * @param {string} opts.localField The field that holds a reference to the * related record object. * @returns {Function} Invocation function, which accepts the target as the only * parameter. */ export const belongsTo = function (related, opts) { return function (mapper) { Relation.belongsTo(related, opts).assignTo(mapper) } } /** * TODO * * @name module:js-data.hasMany * @method * @param {Mapper} related The relation of which the target has many. * @param {Object} opts Configuration options. * @param {string} [opts.foreignKey] The field that holds the primary key of the * related record. * @param {string} opts.localField The field that holds a reference to the * related record object. * @returns {Function} Invocation function, which accepts the target as the only * parameter. */ export const hasMany = function (related, opts) { return function (mapper) { Relation.hasMany(related, opts).assignTo(mapper) } } /** * TODO * * @name module:js-data.hasOne * @method * @param {Mapper} related The relation of which the target has one. * @param {Object} opts Configuration options. * @param {string} [opts.foreignKey] The field that holds the primary key of the * related record. * @param {string} opts.localField The field that holds a reference to the * related record object. * @returns {Function} Invocation function, which accepts the target as the only * parameter. */ export const hasOne = function (related, opts) { return function (mapper) { Relation.hasOne(related, opts).assignTo(mapper) } } × Search results Close api.js-data.io • js-data.io "},"Query.js.html":{"id":"Query.js.html","title":"Source: Query.js","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentDataStoreLinkedCollectionMapperQueryRecordSchema Source: Query.js import utils from './utils' import Component from './Component' const DOMAIN = 'Query' const INDEX_ERR = 'Index inaccessible after first operation' // Reserved words used by JSData's Query Syntax const reserved = { limit: '', offset: '', orderBy: '', skip: '', sort: '', where: '' } // Used by our JavaScript implementation of the LIKE operator const escapeRegExp = /([.*+?^=!:${}()|[\\]\\/\\\\])/g const percentRegExp = /%/g const underscoreRegExp = /_/g const escape = function (pattern) { return pattern.replace(escapeRegExp, '\\\\$1') } /** * A class used by the {@link Collection} class to build queries to be executed * against the collection's data. An instance of `Query` is returned by * {@link Collection#query}. Query instances are typically short-lived, and you * shouldn't have to create them yourself. Just use {@link Collection#query}. * * ```javascript * import {Query} from 'js-data' * ``` * * @example * const posts = store.query('post').filter({ status: 'draft' }).limit(2).run() * * @class Query * @extends Component * @param {Collection} collection The collection on which this query operates. * @since 3.0.0 */ function Query (collection) { utils.classCallCheck(this, Query) /** * The {@link Collection} on which this query operates. * * @name Query#collection * @since 3.0.0 * @type {Collection} */ this.collection = collection /** * The current data result of this query. * * @name Query#data * @since 3.0.0 * @type {Array} */ this.data = null } export default Component.extend({ constructor: Query, _applyWhereFromObject (where) { const fields = [] const ops = [] const predicates = [] utils.forOwn(where, (clause, field) =&gt; { if (!utils.isObject(clause)) { clause = { '==': clause } } utils.forOwn(clause, (expr, op) =&gt; { fields.push(field) ops.push(op) predicates.push(expr) }) }) return { fields, ops, predicates } }, _applyWhereFromArray (where) { const groups = [] where.forEach((_where, i) =&gt; { if (utils.isString(_where)) { return } const prev = where[i - 1] const parser = utils.isArray(_where) ? this._applyWhereFromArray : this._applyWhereFromObject const group = parser.call(this, _where) if (prev === 'or') { group.isOr = true } groups.push(group) }) groups.isArray = true return groups }, _testObjectGroup (keep, first, group, item) { let i const fields = group.fields const ops = group.ops const predicates = group.predicates const len = ops.length for (i = 0; i &lt; len; i++) { let op = ops[i] const isOr = op.charAt(0) === '|' op = isOr ? op.substr(1) : op const expr = this.evaluate(utils.get(item, fields[i]), op, predicates[i]) if (expr !== undefined) { keep = first ? expr : (isOr ? keep || expr : keep &amp;&amp; expr) } first = false } return { keep, first } }, _testArrayGroup (keep, first, groups, item) { let i const len = groups.length for (i = 0; i &lt; len; i++) { const group = groups[i] const parser = group.isArray ? this._testArrayGroup : this._testObjectGroup const result = parser.call(this, true, true, group, item) if (groups[i - 1]) { if (group.isOr) { keep = keep || result.keep } else { keep = keep &amp;&amp; result.keep } } else { keep = result.keep } first = result.first } return { keep, first } }, /** * Find all entities between two boundaries. * * @example &lt;caption&gt;Get the users ages 18 to 30.&lt;/caption&gt; * const users = query.between(18, 30, { index: 'age' }).run() * * @example &lt;caption&gt;Same as above.&lt;/caption&gt; * const users = query.between([18], [30], { index: 'age' }).run() * * @method Query#between * @param {Array} leftKeys Keys defining the left boundary. * @param {Array} rightKeys Keys defining the right boundary. * @param {Object} [opts] Configuration options. * @param {string} [opts.index] Name of the secondary index to use in the * query. If no index is specified, the main index is used. * @param {boolean} [opts.leftInclusive=true] Whether to include entities * on the left boundary. * @param {boolean} [opts.rightInclusive=false] Whether to include entities * on the left boundary. * @param {boolean} [opts.limit] Limit the result to a certain number. * @param {boolean} [opts.offset] The number of resulting entities to skip. * @returns {Query} A reference to itself for chaining. * @since 3.0.0 */ between (leftKeys, rightKeys, opts) { opts || (opts = {}) if (this.data) { throw utils.err(`${DOMAIN}#between`)(500, 'Cannot access index') } this.data = this.collection.getIndex(opts.index).between(leftKeys, rightKeys, opts) return this }, /** * The comparison function used by the {@link Query} class. * * @method Query#compare * @param {Array} orderBy An orderBy clause used for sorting and sub-sorting. * @param {number} index The index of the current orderBy clause being used. * @param {*} a The first item in the comparison. * @param {*} b The second item in the comparison. * @returns {number} -1 if `b` should preceed `a`. 0 if `a` and `b` are equal. * 1 if `a` should preceed `b`. * @since 3.0.0 */ compare (orderBy, index, a, b) { const def = orderBy[index] let cA = utils.get(a, def[0]) let cB = utils.get(b, def[0]) if (cA &amp;&amp; utils.isString(cA)) { cA = cA.toUpperCase() } if (cB &amp;&amp; utils.isString(cB)) { cB = cB.toUpperCase() } if (a === undefined) { a = null } if (b === undefined) { b = null } if (def[1].toUpperCase() === 'DESC') { const temp = cB cB = cA cA = temp } if (cA &lt; cB) { return -1 } else if (cA &gt; cB) { return 1 } else { if (index &lt; orderBy.length - 1) { return this.compare(orderBy, index + 1, a, b) } else { return 0 } } }, /** * Predicate evaluation function used by the {@link Query} class. * * @method Query#evaluate * @param {*} value The value to evaluate. * @param {string} op The operator to use in this evaluation. * @param {*} predicate The predicate to use in this evaluation. * @returns {boolean} Whether the value passed the evaluation or not. * @since 3.0.0 */ evaluate (value, op, predicate) { const ops = this.constructor.ops if (ops[op]) { return ops[op](value, predicate) } if (op.indexOf('like') === 0) { return !utils.isNull(this.like(predicate, op.substr(4)).exec(value)) } else if (op.indexOf('notLike') === 0) { return utils.isNull(this.like(predicate, op.substr(7)).exec(value)) } }, /** * Find the record or records that match the provided query or are accepted by * the provided filter function. * * @example &lt;caption&gt;Get the draft posts created less than three months&lt;/caption&gt; * const posts = query.filter({ * where: { * status: { * '==': 'draft' * }, * created_at_timestamp: { * '&gt;=': (new Date().getTime() (1000 * 60 * 60 * 24 * 30 * 3)) // 3 months ago * } * } * }).run() * * @example &lt;caption&gt;Use a custom filter function&lt;/caption&gt; * const posts = query.filter(function (post) { * return post.isReady() * }).run() * * @method Query#filter * @param {(Object|Function)} [queryOrFn={}] Selection query or filter * function. * @param {Function} [thisArg] Context to which to bind `queryOrFn` if * `queryOrFn` is a function. * @returns {Query} A reference to itself for chaining. * @since 3.0.0 */ filter (query, thisArg) { /** * Selection query as defined by JSData's [Query Syntax][querysyntax]. * * [querysyntax]: http://www.js-data.io/v3.0/docs/query-syntax * * @example &lt;caption&gt;Empty &quot;findAll&quot; query&lt;/caption&gt; * store.findAll('post').then((posts) =&gt; { * console.log(posts) // [...] * }) * * @example &lt;caption&gt;Empty &quot;filter&quot; query&lt;/caption&gt; * const posts = store.filter('post') * console.log(posts) // [...] * * @example &lt;caption&gt;Complex &quot;findAll&quot; query&lt;/caption&gt; * const PAGE_SIZE = 10 * let currentPage = 3 * * // Retrieve a filtered page of blog posts * store.findAll('post', { * where: { * status: { * // WHERE status = 'published' * '==': 'published' * }, * author: { * // AND author IN ('bob', 'alice') * 'in': ['bob', 'alice'], * // OR author IN ('karen') * '|in': ['karen'] * } * }, * orderBy: [ * // ORDER BY date_published DESC, * ['date_published', 'DESC'], * // ORDER BY title ASC * ['title', 'ASC'] * ], * // LIMIT 10 * limit: PAGE_SIZE, * // SKIP 20 * offset: PAGE_SIZE * (currentPage 1) * }).then((posts) =&gt; { * console.log(posts) // [...] * }) * * @namespace query * @property {number} [limit] See {@link query.limit}. * @property {number} [offset] See {@link query.offset}. * @property {string|Array[]} [orderBy] See {@link query.orderBy}. * @property {number} [skip] Alias for {@link query.offset}. * @property {string|Array[]} [sort] Alias for {@link query.orderBy}. * @property {Object} [where] See {@link query.where}. * @since 3.0.0 * @tutorial [&quot;http://www.js-data.io/v3.0/docs/query-syntax&quot;,&quot;JSData's Query Syntax&quot;] */ query || (query = {}) this.getData() if (utils.isObject(query)) { let where = {} /** * Filtering criteria. Records that do not meet this criteria will be exluded * from the result. * * @example * TODO * * @name query.where * @type {Object} * @see http://www.js-data.io/v3.0/docs/query-syntax * @since 3.0.0 */ if (utils.isObject(query.where) || utils.isArray(query.where)) { where = query.where } utils.forOwn(query, function (value, key) { if (!(key in reserved) &amp;&amp; !(key in where)) { where[key] = { '==': value } } }) let groups // Apply filter for each field if (utils.isObject(where) &amp;&amp; Object.keys(where).length !== 0) { groups = this._applyWhereFromArray([where]) } else if (utils.isArray(where)) { groups = this._applyWhereFromArray(where) } if (groups) { this.data = this.data.filter((item, i) =&gt; this._testArrayGroup(true, true, groups, item).keep) } // Sort let orderBy = query.orderBy || query.sort if (utils.isString(orderBy)) { orderBy = [ [orderBy, 'ASC'] ] } if (!utils.isArray(orderBy)) { orderBy = null } /** * Determines how records should be ordered in the result. * * @example * TODO * * @name query.orderBy * @type {string|Array[]} * @see http://www.js-data.io/v3.0/docs/query-syntax * @since 3.0.0 */ if (orderBy) { let index = 0 orderBy.forEach(function (def, i) { if (utils.isString(def)) { orderBy[i] = [def, 'ASC'] } }) this.data.sort((a, b) =&gt; this.compare(orderBy, index, a, b)) } /** * Number of records to skip. * * @example &lt;caption&gt;Retrieve the first &quot;page&quot; of blog posts&lt;/caption&gt; * const PAGE_SIZE = 10 * let currentPage = 1 * PostService.findAll({ * offset: PAGE_SIZE * (currentPage 1) * limit: PAGE_SIZE * }) * * @name query.offset * @type {number} * @see http://www.js-data.io/v3.0/docs/query-syntax * @since 3.0.0 */ if (utils.isNumber(query.skip)) { this.skip(query.skip) } else if (utils.isNumber(query.offset)) { this.skip(query.offset) } /** * Maximum number of records to retrieve. * * @example &lt;caption&gt;Retrieve the first &quot;page&quot; of blog posts&lt;/caption&gt; * const PAGE_SIZE = 10 * let currentPage = 1 * PostService.findAll({ * offset: PAGE_SIZE * (currentPage 1) * limit: PAGE_SIZE * }) * * @name query.limit * @type {number} * @see http://www.js-data.io/v3.0/docs/query-syntax * @since 3.0.0 */ if (utils.isNumber(query.limit)) { this.limit(query.limit) } } else if (utils.isFunction(query)) { this.data = this.data.filter(query, thisArg) } return this }, /** * Iterate over all entities. * * @method Query#forEach * @param {Function} forEachFn Iteration function. * @param {*} [thisArg] Context to which to bind `forEachFn`. * @returns {Query} A reference to itself for chaining. * @since 3.0.0 */ forEach (forEachFn, thisArg) { this.getData().forEach(forEachFn, thisArg) return this }, /** * Find the entity or entities that match the provided key. * * @example &lt;caption&gt;Get the entity whose primary key is 25.&lt;/caption&gt; * const entities = query.get(25).run() * * @example &lt;caption&gt;Same as above.&lt;/caption&gt; * const entities = query.get([25]).run() * * @example &lt;caption&gt;Get all users who are active and have the &quot;admin&quot; role.&lt;/caption&gt; * const activeAdmins = query.get(['active', 'admin'], { * index: 'activityAndRoles' * }).run() * * @example &lt;caption&gt;Get all entities that match a certain weather condition.&lt;/caption&gt; * const niceDays = query.get(['sunny', 'humid', 'calm'], { * index: 'weatherConditions' * }).run() * * @method Query#get * @param {Array} keyList Key(s) defining the entity to retrieve. If * `keyList` is not an array (i.e. for a single-value key), it will be * wrapped in an array. * @param {Object} [opts] Configuration options. * @param {string} [opts.string] Name of the secondary index to use in the * query. If no index is specified, the main index is used. * @returns {Query} A reference to itself for chaining. * @since 3.0.0 */ get (keyList, opts) { keyList || (keyList = []) opts || (opts = {}) if (this.data) { throw utils.err(`${DOMAIN}#get`)(500, INDEX_ERR) } if (keyList &amp;&amp; !utils.isArray(keyList)) { keyList = [keyList] } if (!keyList.length) { this.getData() return this } this.data = this.collection.getIndex(opts.index).get(keyList) return this }, /** * Find the entity or entities that match the provided keyLists. * * @example &lt;caption&gt;Get the posts where &quot;status&quot; is &quot;draft&quot; or &quot;inReview&quot;.&lt;/caption&gt; * const posts = query.getAll('draft', 'inReview', { index: 'status' }).run() * * @example &lt;caption&gt;Same as above.&lt;/caption&gt; * const posts = query.getAll(['draft'], ['inReview'], { index: 'status' }).run() * * @method Query#getAll * @param {...Array} [keyList] Provide one or more keyLists, and all * entities matching each keyList will be retrieved. If no keyLists are * provided, all entities will be returned. * @param {Object} [opts] Configuration options. * @param {string} [opts.index] Name of the secondary index to use in the * query. If no index is specified, the main index is used. * @returns {Query} A reference to itself for chaining. * @since 3.0.0 */ getAll (...args) { let opts = {} if (this.data) { throw utils.err(`${DOMAIN}#getAll`)(500, INDEX_ERR) } if (!args.length || args.length === 1 &amp;&amp; utils.isObject(args[0])) { this.getData() return this } else if (args.length &amp;&amp; utils.isObject(args[args.length - 1])) { opts = args[args.length - 1] args.pop() } const collection = this.collection const index = collection.getIndex(opts.index) this.data = [] args.forEach((keyList) =&gt; { this.data = this.data.concat(index.get(keyList)) }) return this }, /** * Return the current data result of this query. * * @method Query#getData * @returns {Array} The data in this query. * @since 3.0.0 */ getData () { if (!this.data) { this.data = this.collection.index.getAll() } return this.data }, /** * Implementation used by the `like` operator. Takes a pattern and flags and * returns a `RegExp` instance that can test strings. * * @method Query#like * @param {string} pattern Testing pattern. * @param {string} flags Flags for the regular expression. * @returns {RegExp} Regular expression for testing strings. * @since 3.0.0 */ like (pattern, flags) { return new RegExp(`^${(escape(pattern).replace(percentRegExp, '.*').replace(underscoreRegExp, '.'))}$`, flags) }, /** * Limit the result. * * @example &lt;caption&gt;Get only the first 10 draft posts.&lt;/caption&gt; * const posts = query.get('draft', { index: 'status' }).limit(10).run() * * @method Query#limit * @param {number} num The maximum number of entities to keep in the result. * @returns {Query} A reference to itself for chaining. * @since 3.0.0 */ limit (num) { if (!utils.isNumber(num)) { throw utils.err(`${DOMAIN}#limit`, 'num')(400, 'number', num) } const data = this.getData() this.data = data.slice(0, Math.min(data.length, num)) return this }, /** * Apply a mapping function to the result data. * * @example * const ages = UserCollection.query().map((user) =&gt; { * return user.age * }).run() * * @method Query#map * @param {Function} mapFn Mapping function. * @param {*} [thisArg] Context to which to bind `mapFn`. * @returns {Query} A reference to itself for chaining. * @since 3.0.0 */ map (mapFn, thisArg) { this.data = this.getData().map(mapFn, thisArg) return this }, /** * Return the result of calling the specified function on each item in this * collection's main index. * * @example * const stringAges = UserCollection.query().mapCall('toString').run() * * @method Query#mapCall * @param {string} funcName Name of function to call * @parama {...*} [args] Remaining arguments to be passed to the function. * @returns {Query} A reference to itself for chaining. * @since 3.0.0 */ mapCall (funcName, ...args) { this.data = this.getData().map(function (item) { return item[funcName](...args) }) return this }, /** * Complete the execution of the query and return the resulting data. * * @method Query#run * @returns {Array} The result of executing this query. * @since 3.0.0 */ run () { const data = this.data this.data = null return data }, /** * Skip a number of results. * * @example &lt;caption&gt;Get all but the first 10 draft posts.&lt;/caption&gt; * const posts = query.get('draft', { index: 'status' }).skip(10).run() * * @method Query#skip * @param {number} num The number of entities to skip. * @returns {Query} A reference to itself for chaining. * @since 3.0.0 */ skip (num) { if (!utils.isNumber(num)) { throw utils.err(`${DOMAIN}#skip`, 'num')(400, 'number', num) } const data = this.getData() if (num &lt; data.length) { this.data = data.slice(num) } else { this.data = [] } return this } }, { /** * The filtering operators supported by {@link Query#filter}, and which are * implemented by adapters (for the most part). * * @example &lt;caption&gt;Variant 1&lt;/caption&gt; * const publishedPosts = store.filter('post', { * status: 'published', * limit: 2 * }) * * @example &lt;caption&gt;Variant 2&lt;/caption&gt; * const publishedPosts = store.filter('post', { * where: { * status: { * '==': 'published' * } * }, * limit: 2 * }) * * @example &lt;caption&gt;Variant 3&lt;/caption&gt; * const publishedPosts = store.query('post').filter({ * status: 'published' * }).limit(2).run() * * @example &lt;caption&gt;Variant 4&lt;/caption&gt; * const publishedPosts = store.query('post').filter({ * where: { * status: { * '==': 'published' * } * } * }).limit(2).run() * * @example &lt;caption&gt;Multiple operators&lt;/caption&gt; * const myPublishedPosts = store.filter('post', { * where: { * status: { * '==': 'published' * }, * user_id: { * '==': currentUser.id * } * } * }) * * @name Query.ops * @property {Function} == Equality operator. * @property {Function} != Inequality operator. * @property {Function} &gt; Greater than operator. * @property {Function} &gt;= Greater than (inclusive) operator. * @property {Function} &lt; Less than operator. * @property {Function} &lt;= Less than (inclusive) operator. * @property {Function} isectEmpty Operator that asserts that the intersection * between two arrays is empty. * @property {Function} isectNotEmpty Operator that asserts that the * intersection between two arrays is __not__ empty. * @property {Function} in Operator that asserts whether a value is in an * array. * @property {Function} notIn Operator that asserts whether a value is __not__ * in an array. * @property {Function} contains Operator that asserts whether an array * contains a value. * @property {Function} notContains Operator that asserts whether an array * does __not__ contain a value. * @since 3.0.0 * @type {Object} */ ops: { '=': function (value, predicate) { return value == predicate // eslint-disable-line }, '==': function (value, predicate) { return value == predicate // eslint-disable-line }, '===': function (value, predicate) { return value === predicate }, '!=': function (value, predicate) { return value != predicate // eslint-disable-line }, '!==': function (value, predicate) { return value !== predicate }, '&gt;': function (value, predicate) { return value &gt; predicate }, '&gt;=': function (value, predicate) { return value &gt;= predicate }, '&lt;': function (value, predicate) { return value &lt; predicate }, '&lt;=': function (value, predicate) { return value &lt;= predicate }, 'isectEmpty': function (value, predicate) { return !utils.intersection((value || []), (predicate || [])).length }, 'isectNotEmpty': function (value, predicate) { return utils.intersection((value || []), (predicate || [])).length }, 'in': function (value, predicate) { return predicate.indexOf(value) !== -1 }, 'notIn': function (value, predicate) { return predicate.indexOf(value) === -1 }, 'contains': function (value, predicate) { return (value || []).indexOf(predicate) !== -1 }, 'notContains': function (value, predicate) { return (value || []).indexOf(predicate) === -1 } } }) /** * Create a subclass of this Query. * * @example &lt;caption&gt;Extend the class in a cross-browser manner.&lt;/caption&gt; * import {Query} from 'js-data' * const CustomQueryClass = Query.extend({ * foo () { return 'bar' } * }) * const customQuery = new CustomQueryClass({ name: 'test' }) * console.log(customQuery.foo()) // &quot;bar&quot; * * @example &lt;caption&gt;Extend the class using ES2015 class syntax.&lt;/caption&gt; * class CustomQueryClass extends Query { * foo () { return 'bar' } * } * const customQuery = new CustomQueryClass({ name: 'test' }) * console.log(customQuery.foo()) // &quot;bar&quot; * * @method Query.extend * @param {Object} [props={}] Properties to add to the prototype of the * subclass. * @param {Object} [classProps={}] Static properties to add to the subclass. * @returns {Constructor} Subclass of this Query class. * @since 3.0.0 */ × Search results Close api.js-data.io • js-data.io "},"Record.js.html":{"id":"Record.js.html","title":"Source: Record.js","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentDataStoreLinkedCollectionMapperQueryRecordSchema Source: Record.js import utils from './utils' import Component from './Component' const DOMAIN = 'Record' const superMethod = function (mapper, name) { const store = mapper.datastore if (store &amp;&amp; store[name]) { return function (...args) { return store[name](mapper.name, ...args) } } return mapper[name].bind(mapper) } /** * js-data's Record class. * * ```javascript * import {Record} from 'js-data' * ``` * * @class Record * @extends Component * @param {Object} [props] The initial properties of the new Record instance. * @param {Object} [opts] Configuration options. * @param {boolean} [opts.noValidate=false] Whether to skip validation on the * initial properties. * @since 3.0.0 */ function Record (props, opts) { utils.classCallCheck(this, Record) props || (props = {}) opts || (opts = {}) const _props = {} Object.defineProperties(this, { _get: { value (key) { return utils.get(_props, key) } }, _set: { value (key, value) { return utils.set(_props, key, value) } }, _unset: { value (key) { return utils.unset(_props, key) } } }) const _set = this._set // TODO: Optimize these strings _set('creating', true) if (opts.noValidate) { _set('noValidate', true) } utils.fillIn(this, props) _set('creating', false) _set('noValidate', false) _set('previous', utils.plainCopy(props)) } export default Component.extend({ constructor: Record, /** * Returns the {@link Mapper} paired with this record's class, if any. * * @private * @method Record#_mapper * @returns {Mapper} The {@link Mapper} paired with this record's class, if any. * @since 3.0.0 */ _mapper () { const mapper = this.constructor.mapper if (!mapper) { throw utils.err(`${DOMAIN}#_mapper`, '')(404, 'mapper') } return mapper }, /** * Lifecycle hook. * * @method Record#afterLoadRelations * @param {string[]} relations The `relations` argument passed to {@link Record#loadRelations}. * @param {Object} opts The `opts` argument passed to {@link Record#loadRelations}. * @since 3.0.0 */ afterLoadRelations () {}, /** * Lifecycle hook. * * @method Record#beforeLoadRelations * @param {string[]} relations The `relations` argument passed to {@link Record#loadRelations}. * @param {Object} opts The `opts` argument passed to {@link Record#loadRelations}. * @since 3.0.0 */ beforeLoadRelations () {}, /** * Return changes to this record since it was instantiated or * {@link Record#commit} was called. * * @method Record#changes * @param [opts] Configuration options. * @param {Function} [opts.equalsFn={@link utils.deepEqual}] Equality function. * @param {Array} [opts.ignore=[]] Array of strings or RegExp of fields to ignore. * @returns {Object} Object describing the changes to this record since it was * instantiated or its {@link Record#commit} method was last called. * @since 3.0.0 */ changes (opts) { opts || (opts = {}) return utils.diffObjects(typeof this.toJSON === 'function' ? this.toJSON(opts) : this, this._get('previous'), opts) }, /** * Make the record's current in-memory state it's only state, with any * previous property values being set to current values. * * @method Record#commit * @since 3.0.0 */ commit () { this._set('changed') // unset this._set('previous', utils.plainCopy(this)) }, /** * Call {@link Mapper#destroy} using this record's primary key. * * @method Record#destroy * @param {Object} [opts] Configuration options passed to {@link Mapper#destroy}. * @returns {Promise} The result of calling {@link Mapper#destroy} with the * primary key of this record. * @since 3.0.0 */ destroy (opts) { opts || (opts = {}) const mapper = this._mapper() return superMethod(mapper, 'destroy')(utils.get(this, mapper.idAttribute), opts) }, /** * Return the value at the given path for this instance. * * @method Record#get * @param {string} key Path of value to retrieve. * @returns {*} Value at path. * @since 3.0.0 */ 'get' (key) { return utils.get(this, key) }, /** * Return whether this record has changed since it was instantiated or * {@link Record#commit} was called. * * @method Record#hasChanges * @param [opts] Configuration options. * @param {Function} [opts.equalsFn={@link utils.deepEqual}] Equality function. * @param {Array} [opts.ignore=[]] Array of strings or RegExp of fields to ignore. * @returns {boolean} Return whether the record has changed since it was * instantiated or since its {@link Record#commit} method was called. * @since 3.0.0 */ hasChanges (opts) { const quickHasChanges = !!(this._get('changed') || []).length return quickHasChanges || utils.areDifferent(typeof this.toJSON === 'function' ? this.toJSON(opts) : this, this._get('previous'), opts) }, /** * Return whether the record in its current state passes validation. * * @method Record#isValid * @param {Object} [opts] Configuration options. Passed to {@link Mapper#validate}. * @returns {boolean} Whether the record in its current state passes * validation. * @since 3.0.0 */ isValid (opts) { return !this._mapper().validate(this, opts) }, /** * Lazy load relations of this record, to be attached to the record once their * loaded. * * @method Record#loadRelations * @param {string[]} [relations] List of relations to load. * @param {Object} [opts] Configuration options. * @returns {Promise} Resolves with the record, with the loaded relations now * attached. * @since 3.0.0 */ loadRelations (relations, opts) { let op const mapper = this._mapper() // Default values for arguments relations || (relations = []) if (utils.isString(relations)) { relations = [relations] } opts || (opts = {}) opts.with = relations // Fill in &quot;opts&quot; with the Model's configuration utils._(opts, mapper) opts.adapter = mapper.getAdapterName(opts) // beforeLoadRelations lifecycle hook op = opts.op = 'beforeLoadRelations' return utils.resolve(this[op](relations, opts)).then(() =&gt; { // Now delegate to the adapter op = opts.op = 'loadRelations' mapper.dbg(op, this, relations, opts) let tasks = [] let task utils.forEachRelation(mapper, opts, (def, optsCopy) =&gt; { const relatedMapper = def.getRelation() optsCopy.raw = false if (utils.isFunction(def.load)) { task = def.load(mapper, def, this, opts) } else if (def.type === 'hasMany' || def.type === 'hasOne') { if (def.foreignKey) { task = superMethod(relatedMapper, 'findAll')({ [def.foreignKey]: utils.get(this, mapper.idAttribute) }, optsCopy).then(function (relatedData) { if (def.type === 'hasOne') { return relatedData.length ? relatedData[0] : undefined } return relatedData }) } else if (def.localKeys) { task = superMethod(relatedMapper, 'findAll')({ where: { [relatedMapper.idAttribute]: { 'in': utils.get(this, def.localKeys) } } }) } else if (def.foreignKeys) { task = superMethod(relatedMapper, 'findAll')({ where: { [def.foreignKeys]: { 'contains': utils.get(this, mapper.idAttribute) } } }, opts) } } else if (def.type === 'belongsTo') { const key = utils.get(this, def.foreignKey) if (utils.isSorN(key)) { task = superMethod(relatedMapper, 'find')(key, optsCopy) } } if (task) { task = task.then((relatedData) =&gt; { def.setLocalField(this, relatedData) }) tasks.push(task) } }) return Promise.all(tasks) }).then(() =&gt; { // afterLoadRelations lifecycle hook op = opts.op = 'afterLoadRelations' return utils.resolve(this[op](relations, opts)).then(() =&gt; this) }) }, /** * Return the properties with which this record was instantiated. * * @method Record#previous * @param {string} [key] If specified, return just the initial value of the * given key. * @returns {Object} The initial properties of this record. * @since 3.0.0 */ previous (key) { if (key) { return this._get(`previous.${key}`) } return this._get('previous') }, /** * Revert changes to this record back to the properties it had when it was * instantiated. * * @method Record#revert * @param {Object} [opts] Configuration options. * @param {string[]} [opts.preserve] Array of strings or Regular Expressions * denoting properties that should not be reverted. * @since 3.0.0 */ revert (opts) { const previous = this._get('previous') opts || (opts = {}) opts.preserve || (opts.preserve = []) utils.forOwn(this, (value, key) =&gt; { if (key !== this._mapper().idAttribute &amp;&amp; !previous.hasOwnProperty(key) &amp;&amp; this.hasOwnProperty(key) &amp;&amp; opts.preserve.indexOf(key) === -1) { delete this[key] } }) utils.forOwn(previous, (value, key) =&gt; { if (opts.preserve.indexOf(key) === -1) { this[key] = value } }) this.commit() }, /** * Delegates to {@link Mapper#create} or {@link Mapper#update}. * * @method Record#save * @param {Object} [opts] Configuration options. See {@link Mapper#create} and * {@link Mapper#update}. * @param {boolean} [opts.changesOnly] Equality function. Default uses `===`. * @param {Function} [opts.equalsFn] Passed to {@link Record#changes} when * `opts.changesOnly` is `true`. * @param {Array} [opts.ignore] Passed to {@link Record#changes} when * `opts.changesOnly` is `true`. * @returns {Promise} The result of calling {@link Mapper#create} or * {@link Mapper#update}. * @since 3.0.0 */ save (opts) { opts || (opts = {}) const mapper = this._mapper() const id = utils.get(this, mapper.idAttribute) let props = this if (utils.isUndefined(id)) { return superMethod(mapper, 'create')(props, opts) } if (opts.changesOnly) { const changes = this.changes(opts) props = {} utils.fillIn(props, changes.added) utils.fillIn(props, changes.changed) } return superMethod(mapper, 'update')(id, props, opts).then((result) =&gt; { const record = opts.raw ? result.data : result if (record) { utils.deepMixIn(this, record) this.commit() } return result }) }, /** * Set the value for a given key, or the values for the given keys if &quot;key&quot; is * an object. * * @method Record#set * @param {(string|Object)} key Key to set or hash of key-value pairs to set. * @param {*} [value] Value to set for the given key. * @param {Object} [opts] Configuration options. * @param {boolean} [opts.silent=false] Whether to trigger change events. * @since 3.0.0 */ 'set' (key, value, opts) { if (utils.isObject(key)) { opts = value } opts || (opts = {}) if (opts.silent) { this._set('silent', true) } utils.set(this, key, value) if (!this._get('eventId')) { this._set('silent') // unset } }, /** * Return a plain object representation of this record. If the class from * which this record was created has a Mapper, then {@link Mapper#toJSON} will * be called with this record instead. * * @method Record#toJSON * @param {Object} [opts] Configuration options. * @param {string[]} [opts.with] Array of relation names or relation fields * to include in the representation. Only available as an option if the class * from which this record was created has a Mapper and this record resides in * an instance of {@link DataStore}. * @returns {Object} Plain object representation of this record. * @since 3.0.0 */ toJSON (opts) { const mapper = this.constructor.mapper if (mapper) { return mapper.toJSON(this, opts) } else { const json = {} utils.forOwn(this, function (prop, key) { json[key] = utils.plainCopy(prop) }) return json } }, /** * Unset the value for a given key. * * @method Record#unset * @param {string} key Key to unset. * @param {Object} [opts] Configuration options. * @param {boolean} [opts.silent=false] Whether to trigger change events. * @since 3.0.0 */ unset (key, opts) { this.set(key, undefined, opts) }, /** * Validate this record based on its current properties. * * @method Record#validate * @param {Object} [opts] Configuration options. Passed to {@link Mapper#validate}. * @returns {*} Array of errors or `undefined` if no errors. * @since 3.0.0 */ validate (opts) { return this._mapper().validate(this, opts) } }) /** * Allow records to emit events. * * An record's registered listeners are stored in the record's private data. */ utils.eventify( Record.prototype, function () { return this._get('events') }, function (value) { this._set('events', value) } ) /** * Create a subclass of this Record. * * @example &lt;caption&gt;Extend the class in a cross-browser manner.&lt;/caption&gt; * import {Record} from 'js-data' * const CustomRecordClass = Record.extend({ * foo () { return 'bar' } * }) * const customRecord = new CustomRecordClass() * console.log(customRecord.foo()) // &quot;bar&quot; * * @example &lt;caption&gt;Extend the class using ES2015 class syntax.&lt;/caption&gt; * class CustomRecordClass extends Record { * foo () { return 'bar' } * } * const customRecord = new CustomRecordClass() * console.log(customRecord.foo()) // &quot;bar&quot; * * @method Record.extend * @param {Object} [props={}] Properties to add to the prototype of the * subclass. * @param {Object} [classProps={}] Static properties to add to the subclass. * @returns {Constructor} Subclass of this Record class. * @since 3.0.0 */ × Search results Close api.js-data.io • js-data.io "},"Schema.js.html":{"id":"Schema.js.html","title":"Source: Schema.js","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentDataStoreLinkedCollectionMapperQueryRecordSchema Source: Schema.js import utils from './utils' import Component from './Component' const DOMAIN = 'Schema' /** * A function map for each of the seven primitive JSON types defined by the core specification. * Each function will check a given value and return true or false if the value is an instance of that type. * ``` * types.integer(1) // returns true * types.string({}) // returns false * ``` * http://json-schema.org/latest/json-schema-core.html#anchor8 * @name Schema.types * @type {Object} */ const types = { array: utils.isArray, boolean: utils.isBoolean, integer: utils.isInteger, 'null': utils.isNull, number: utils.isNumber, object: utils.isObject, string: utils.isString } /** * @ignore */ const segmentToString = function (segment, prev) { let str = '' if (segment) { if (utils.isNumber(segment)) { str += `[${segment}]` } else if (prev) { str += `.${segment}` } else { str += `${segment}` } } return str } /** * @ignore */ const makePath = function (opts) { opts || (opts = {}) let path = '' const segments = opts.path || [] segments.forEach(function (segment) { path += segmentToString(segment, path) }) path += segmentToString(opts.prop, path) return path } /** * @ignore */ const makeError = function (actual, expected, opts) { return { expected, actual: '' + actual, path: makePath(opts) } } /** * @ignore */ const addError = function (actual, expected, opts, errors) { errors.push(makeError(actual, expected, opts)) } /** * @ignore */ const maxLengthCommon = function (keyword, value, schema, opts) { const max = schema[keyword] if (value.length &gt; max) { return makeError(value.length, `length no more than ${max}`, opts) } } /** * @ignore */ const minLengthCommon = function (keyword, value, schema, opts) { const min = schema[keyword] if (value.length &lt; min) { return makeError(value.length, `length no less than ${min}`, opts) } } /** * A map of all object member validation functions for each keyword defined in the JSON Schema. * @name Schema.validationKeywords * @type {Object} */ const validationKeywords = { /** * Validates the provided value against all schemas defined in the Schemas `allOf` keyword. * The instance is valid against if and only if it is valid against all the schemas declared in the Schema's value. * * The value of this keyword MUST be an array. This array MUST have at least one element. * Each element of this array MUST be a valid JSON Schema. * * see http://json-schema.org/latest/json-schema-validation.html#anchor82 * * @name Schema.validationKeywords.allOf * @method * @param {*} value Value to be validated. * @param {Object} [schema] Schema containing the `allOf` keyword. * @param {Object} [opts] Configuration options. * @returns {(array|undefined)} Array of errors or `undefined` if valid. */ allOf (value, schema, opts) { let allErrors = [] schema.allOf.forEach(function (_schema) { allErrors = allErrors.concat(validate(value, _schema, opts) || []) }) return allErrors.length ? undefined : allErrors }, /** * Validates the provided value against all schemas defined in the Schemas `anyOf` keyword. * The instance is valid against this keyword if and only if it is valid against * at least one of the schemas in this keyword's value. * * The value of this keyword MUST be an array. This array MUST have at least one element. * Each element of this array MUST be an object, and each object MUST be a valid JSON Schema. * see http://json-schema.org/latest/json-schema-validation.html#anchor85 * * @name Schema.validationKeywords.anyOf * @method * @param {*} value Value to be validated. * @param {Object} [schema] Schema containing the `anyOf` keyword. * @param {Object} [opts] Configuration options. * @returns {(array|undefined)} Array of errors or `undefined` if valid. */ anyOf (value, schema, opts) { let validated = false let allErrors = [] schema.anyOf.forEach(function (_schema) { const errors = validate(value, _schema, opts) if (errors) { allErrors = allErrors.concat(errors) } else { validated = true } }) return validated ? undefined : allErrors }, /** * http://json-schema.org/latest/json-schema-validation.html#anchor70 * * @name Schema.validationKeywords.dependencies * @method * @param {*} value TODO * @param {Object} schema TODO * @param {Object} opts TODO */ dependencies (value, schema, opts) { // TODO }, /** * Validates the provided value against an array of possible values defined by the Schema's `enum` keyword * Validation succeeds if the value is deeply equal to one of the values in the array. * see http://json-schema.org/latest/json-schema-validation.html#anchor76 * * @name Schema.validationKeywords.enum * @method * @param {*} value Value to validate * @param {Object} [schema] Schema containing the `enum` keyword. * @param {Object} [opts] Configuration options. * @returns {(array|undefined)} Array of errors or `undefined` if valid. */ enum (value, schema, opts) { const possibleValues = schema['enum'] if (utils.findIndex(possibleValues, (item) =&gt; utils.deepEqual(item, value)) === -1) { return makeError(value, `one of (${possibleValues.join(', ')})`, opts) } }, /** * Validates each of the provided array values against a schema or an array of schemas defined by the Schema's `items` keyword * see http://json-schema.org/latest/json-schema-validation.html#anchor37 for validation rules. * * @name Schema.validationKeywords.items * @method * @param {*} value [Array] Array to be validated. * @param {Object} [schema] Schema containing the items keyword. * @param {Object} [opts] Configuration options. * @returns {(array|undefined)} Array of errors or `undefined` if valid. */ items (value, schema, opts) { opts || (opts = {}) // TODO: additionalItems let items = schema.items let errors = [] const checkingTuple = utils.isArray(items) const length = value.length for (var prop = 0; prop &lt; length; prop++) { if (checkingTuple) { // Validating a tuple, instead of just checking each item against the // same schema items = schema.items[prop] } opts.prop = prop errors = errors.concat(validate(value[prop], items, opts) || []) } return errors.length ? errors : undefined }, /** * Validates the provided number against a maximum value defined by the Schema's `maximum` keyword * Validation succeeds if the value is a number, and is less than, or equal to, the value of this keyword. * http://json-schema.org/latest/json-schema-validation.html#anchor17 * * @name Schema.validationKeywords.maximum * @method * @param {*} value [Number] number to validate against the keyword. * @param {Object} schema [schema] Schema containing the `maximum` keyword. * @param {Object} [opts] Configuration options. * @returns {(array|undefined)} Array of errors or `undefined` if valid. */ maximum (value, schema, opts) { // Must be a number const maximum = schema.maximum // Must be a boolean // Depends on maximum // default: false const exclusiveMaximum = schema.exclusiveMaximum if (typeof value === typeof maximum &amp;&amp; !(exclusiveMaximum ? maximum &gt; value : maximum &gt;= value)) { return exclusiveMaximum ? makeError(value, `no more than nor equal to ${maximum}`, opts) : makeError(value, `no more than ${maximum}`, opts) } }, /** * Validates the length of the provided array against a maximum value defined by the Schema's `maxItems` keyword. * Validation succeeds if the length of the array is less than, or equal to the value of this keyword. * see http://json-schema.org/latest/json-schema-validation.html#anchor42 * * @name Schema.validationKeywords.maxItems * @method * @param {*} value [array] Array to be validated. * @param {Object} [schema] Schema containing the `maxItems` keyword. * @param {Object} [opts] Configuration options. * @returns {(array|undefined)} Array of errors or `undefined` if valid. */ maxItems (value, schema, opts) { if (utils.isArray(value)) { return maxLengthCommon('maxItems', value, schema, opts) } }, /** * Validates the length of the provided string against a maximum value defined in the Schema's `maxLength` keyword. * Validation succeeds if the length of the string is less than, or equal to the value of this keyword. * see http://json-schema.org/latest/json-schema-validation.html#anchor26 * * @name Schema.validationKeywords.maxLength * @method * @param {*} value [string] String to be validated. * @param {Object} [schema] Schema containing the `maxLength` keyword. * @param {Object} [opts] Configuration options. * @returns {(array|undefined)} Array of errors or `undefined` if valid. */ maxLength (value, schema, opts) { return maxLengthCommon('maxLength', value, schema, opts) }, /** * Validates the count of the provided object's properties against a maximum value defined in the Schema's `maxProperties` keyword. * Validation succeeds if the object's property count is less than, or equal to the value of this keyword. * see http://json-schema.org/latest/json-schema-validation.html#anchor54 * * @name Schema.validationKeywords.maxProperties * @method * @param {*} value [Object] Object to be validated. * @param {Object} [schema] Schema containing the `maxProperties` keyword. * @param {Object} [opts] Configuration options. * @returns {(array|undefined)} Array of errors or `undefined` if valid. */ maxProperties (value, schema, opts) { // validate only objects if (!utils.isObject(value)) return const maxProperties = schema.maxProperties const length = Object.keys(value).length if (length &gt; maxProperties) { return makeError(length, `no more than ${maxProperties} properties`, opts) } }, /** * Validates the provided value against a minimum value defined by the Schema's `minimum` keyword * Validation succeeds if the value is a number and is greater than, or equal to, the value of this keyword. * http://json-schema.org/latest/json-schema-validation.html#anchor21 * * @name Schema.validationKeywords.minimum * @method * @param {*} value [number] number to validate against the keyword. * @param {Object} [schema] Schema containing the `minimum` keyword. * @param {Object} [opts] Configuration options. * @returns {(array|undefined)} Array of errors or `undefined` if valid. */ minimum (value, schema, opts) { // Must be a number const minimum = schema.minimum // Must be a boolean // Depends on minimum // default: false const exclusiveMinimum = schema.exclusiveMinimum if (typeof value === typeof minimum &amp;&amp; !(exclusiveMinimum ? value &gt; minimum : value &gt;= minimum)) { return exclusiveMinimum ? makeError(value, `no less than nor equal to ${minimum}`, opts) : makeError(value, `no less than ${minimum}`, opts) } }, /** * Validates the length of the provided array against a minimum value defined by the Schema's `minItems` keyword. * Validation succeeds if the length of the array is greater than, or equal to the value of this keyword. * see http://json-schema.org/latest/json-schema-validation.html#anchor45 * * @name Schema.validationKeywords.minItems * @method * @param {*} value [array] Array to be validated. * @param {Object} [schema] Schema containing the `minItems` keyword. * @param {Object} [opts] Configuration options. * @returns {(array|undefined)} Array of errors or `undefined` if valid. */ minItems (value, schema, opts) { if (utils.isArray(value)) { return minLengthCommon('minItems', value, schema, opts) } }, /** * Validates the length of the provided string against a minimum value defined in the Schema's `minLength` keyword. * Validation succeeds if the length of the string is greater than, or equal to the value of this keyword. * see http://json-schema.org/latest/json-schema-validation.html#anchor29 * * @name Schema.validationKeywords.minLength * @method * @param {*} value [string] String to be validated. * @param {Object} [schema] Schema containing the `minLength` keyword. * @param {Object} [opts] Configuration options. * @returns {(array|undefined)} Array of errors or `undefined` if valid. */ minLength (value, schema, opts) { return minLengthCommon('minLength', value, schema, opts) }, /** * Validates the count of the provided object's properties against a minimum value defined in the Schema's `minProperties` keyword. * Validation succeeds if the object's property count is greater than, or equal to the value of this keyword. * see http://json-schema.org/latest/json-schema-validation.html#anchor57 * * @name Schema.validationKeywords.minProperties * @method * @param {*} value [Object] Object to be validated. * @param {Object} [schema] Schema containing the `minProperties` keyword. * @param {Object} [opts] Configuration options. * @returns {(array|undefined)} Array of errors or `undefined` if valid. */ minProperties (value, schema, opts) { // validate only objects if (!utils.isObject(value)) return const minProperties = schema.minProperties const length = Object.keys(value).length if (length &lt; minProperties) { return makeError(length, `no more than ${minProperties} properties`, opts) } }, /** * Validates the provided number is a multiple of the number defined in the Schema's `multipleOf` keyword. * Validation succeeds if the number can be divided equally into the value of this keyword. * see http://json-schema.org/latest/json-schema-validation.html#anchor14 * * @name Schema.validationKeywords.multipleOf * @method * @param {*} value [number] Number to be validated. * @param {Object} [schema] Schema containing the `multipleOf` keyword. * @param {Object} [opts] Configuration options. * @returns {(array|undefined)} Array of errors or `undefined` if valid. */ multipleOf (value, schema, opts) { const multipleOf = schema.multipleOf if (utils.isNumber(value)) { if ((value / multipleOf) % 1 !== 0) { return makeError(value, `multipleOf ${multipleOf}`, opts) } } }, /** * Validates the provided value is not valid with any of the schemas defined in the Schema's `not` keyword. * An instance is valid against this keyword if and only if it is NOT valid against the schemas in this keyword's value. * * see http://json-schema.org/latest/json-schema-validation.html#anchor91 * @name Schema.validationKeywords.not * @method * @param {*} value to be checked. * @param {Object} [schema] Schema containing the not keyword. * @param {Object} [opts] Configuration options. * @returns {(array|undefined)} Array of errors or `undefined` if valid. */ not (value, schema, opts) { if (!validate(value, schema.not, opts)) { // TODO: better messaging return makeError('succeeded', 'should have failed', opts) } }, /** * Validates the provided value is valid with one and only one of the schemas defined in the Schema's `oneOf` keyword. * An instance is valid against this keyword if and only if it is valid against a single schemas in this keyword's value. * * see http://json-schema.org/latest/json-schema-validation.html#anchor88 * @name Schema.validationKeywords.oneOf * @method * @param {*} value to be checked. * @param {Object} [schema] Schema containing the `oneOf` keyword. * @param {Object} [opts] Configuration options. * @returns {(array|undefined)} Array of errors or `undefined` if valid. */ oneOf (value, schema, opts) { let validated = false let allErrors = [] schema.oneOf.forEach(function (_schema) { const errors = validate(value, _schema, opts) if (errors) { allErrors = allErrors.concat(errors) } else if (validated) { allErrors = [makeError('valid against more than one', 'valid against only one', opts)] validated = false return false } else { validated = true } }) return validated ? undefined : allErrors }, /** * Validates the provided string matches a pattern defined in the Schema's `pattern` keyword. * Validation succeeds if the string is a match of the regex value of this keyword. * * see http://json-schema.org/latest/json-schema-validation.html#anchor33 * @name Schema.validationKeywords.pattern * @method * @param {*} value [string] String to be validated. * @param {Object} [schema] Schema containing the `pattern` keyword. * @param {Object} [opts] Configuration options. * @returns {(array|undefined)} Array of errors or `undefined` if valid. */ pattern (value, schema, opts) { const pattern = schema.pattern if (utils.isString(value) &amp;&amp; !value.match(pattern)) { return makeError(value, pattern, opts) } }, /** * Validates the provided object's properties against a map of values defined in the Schema's `properties` keyword. * Validation succeeds if the object's property are valid with each of the schema's in the provided map. * Validation also depends on the additionalProperties and or patternProperties. * * see http://json-schema.org/latest/json-schema-validation.html#anchor64 for more info. * * @name Schema.validationKeywords.properties * @method * @param {*} value [Object] Object to be validated. * @param {Object} [schema] Schema containing the `properties` keyword. * @param {Object} [opts] Configuration options. * @returns {(array|undefined)} Array of errors or `undefined` if valid. */ properties (value, schema, opts) { opts || (opts = {}) // Can be a boolean or an object // Technically the default is an &quot;empty schema&quot;, but here &quot;true&quot; is // functionally the same const additionalProperties = utils.isUndefined(schema.additionalProperties) ? true : schema.additionalProperties // &quot;s&quot;: The property set of the instance to validate. const toValidate = {} // &quot;p&quot;: The property set from &quot;properties&quot;. // Default is an object const properties = schema.properties || {} // &quot;pp&quot;: The property set from &quot;patternProperties&quot;. // Default is an object const patternProperties = schema.patternProperties || {} let errors = [] // Collect set &quot;s&quot; utils.forOwn(value, function (_value, prop) { toValidate[prop] = undefined }) // Remove from &quot;s&quot; all elements of &quot;p&quot;, if any. utils.forOwn(properties || {}, function (_schema, prop) { if (utils.isUndefined(value[prop]) &amp;&amp; !utils.isUndefined(_schema['default'])) { value[prop] = utils.copy(_schema['default']) } opts.prop = prop errors = errors.concat(validate(value[prop], _schema, opts) || []) delete toValidate[prop] }) // For each regex in &quot;pp&quot;, remove all elements of &quot;s&quot; which this regex // matches. utils.forOwn(patternProperties, function (_schema, pattern) { utils.forOwn(toValidate, function (undef, prop) { if (prop.match(pattern)) { opts.prop = prop errors = errors.concat(validate(value[prop], _schema, opts) || []) delete toValidate[prop] } }) }) const keys = Object.keys(toValidate) // If &quot;s&quot; is not empty, validation fails if (additionalProperties === false) { if (keys.length) { addError(`extra fields: ${keys.join(', ')}`, 'no extra fields', opts, errors) } } else if (utils.isObject(additionalProperties)) { // Otherwise, validate according to provided schema keys.forEach(function (prop) { opts.prop = prop errors = errors.concat(validate(value[prop], additionalProperties, opts) || []) }) } return errors.length ? errors : undefined }, /** * Validates the provided object's has all properties listed in the Schema's `properties` keyword array. * Validation succeeds if the object contains all properties provided in the array value of this keyword. * see http://json-schema.org/latest/json-schema-validation.html#anchor61 * * @name Schema.validationKeywords.required * @method * @param {*} value [Object] Object to be validated. * @param {Object} [schema] Schema containing the `required` keyword. * @param {Object} [opts] Configuration options. * @returns {(array|undefined)} Array of errors or `undefined` if valid. */ required (value, schema, opts) { opts || (opts = {}) const required = schema.required let errors = [] if (!opts.existingOnly) { required.forEach(function (prop) { if (utils.isUndefined(utils.get(value, prop))) { const prevProp = opts.prop opts.prop = prop addError(undefined, 'a value', opts, errors) opts.prop = prevProp } }) } return errors.length ? errors : undefined }, /** * Validates the provided value's type is equal to the type, or array of types, defined in the Schema's `type` keyword. * see http://json-schema.org/latest/json-schema-validation.html#anchor79 * * @name Schema.validationKeywords.type * @method * @param {*} value Value to be validated. * @param {Object} [schema] Schema containing the `type` keyword. * @param {Object} [opts] Configuration options. * @returns {(array|undefined)} Array of errors or `undefined` if valid. */ type (value, schema, opts) { let type = schema.type let validType // Can be one of several types if (utils.isString(type)) { type = [type] } // Try to match the value against an expected type type.forEach(function (_type) { // TODO: throw an error if type is not defined if (types[_type](value, schema, opts)) { // Matched a type validType = _type return false } }) // Value did not match any expected type if (!validType) { return makeError(!utils.isUndefined(value) &amp;&amp; value !== null ? typeof value : '' + value, `one of (${type.join(', ')})`, opts) } // Run keyword validators for matched type // http://json-schema.org/latest/json-schema-validation.html#anchor12 const validator = typeGroupValidators[validType] if (validator) { return validator(value, schema, opts) } }, /** * Validates the provided array values are unique. * Validation succeeds if the items in the array are unique, but only if the value of this keyword is true * see http://json-schema.org/latest/json-schema-validation.html#anchor49 * * @name Schema.validationKeywords.uniqueItems * @method * @param {*} value [array] Array to be validated. * @param {Object} [schema] Schema containing the `uniqueItems` keyword. * @param {Object} [opts] Configuration options. * @returns {(array|undefined)} Array of errors or `undefined` if valid. */ uniqueItems (value, schema, opts) { if (value &amp;&amp; value.length &amp;&amp; schema.uniqueItems) { const length = value.length let item, i, j // Check n - 1 items for (i = length - 1; i &gt; 0; i--) { item = value[i] // Only compare against unchecked items for (j = i - 1; j &gt;= 0; j--) { // Found a duplicate if (utils.deepEqual(item, value[j])) { return makeError(item, 'no duplicates', opts) } } } } } } /** * @ignore */ const validateKeyword = function (op, value, schema, opts) { return !utils.isUndefined(schema[op]) &amp;&amp; validationKeywords[op](value, schema, opts) } /** * @ignore */ const runOps = function (ops, value, schema, opts) { let errors = [] ops.forEach(function (op) { errors = errors.concat(validateKeyword(op, value, schema, opts) || []) }) return errors.length ? errors : undefined } const ANY_OPS = ['enum', 'type', 'allOf', 'anyOf', 'oneOf', 'not'] const ARRAY_OPS = ['items', 'maxItems', 'minItems', 'uniqueItems'] const NUMERIC_OPS = ['multipleOf', 'maximum', 'minimum'] const OBJECT_OPS = ['maxProperties', 'minProperties', 'required', 'properties', 'dependencies'] const STRING_OPS = ['maxLength', 'minLength', 'pattern'] /** * http://json-schema.org/latest/json-schema-validation.html#anchor75 * @ignore */ const validateAny = function (value, schema, opts) { return runOps(ANY_OPS, value, schema, opts) } /** * Validates the provided value against a given Schema according to the http://json-schema.org/ v4 specification. * * @name Schema.validate * @method * @param {*} value Value to be validated. * @param {Object} [schema] Valid Schema according to the http://json-schema.org/ v4 specification. * @param {Object} [opts] Configuration options. * @returns {(array|undefined)} Array of errors or `undefined` if valid. */ const validate = function (value, schema, opts) { let errors = [] opts || (opts = {}) let shouldPop let prevProp = opts.prop if (utils.isUndefined(schema)) { return } if (!utils.isObject(schema)) { throw utils.err(`${DOMAIN}#validate`)(500, `Invalid schema at path: &quot;${opts.path}&quot;`) } if (utils.isUndefined(opts.path)) { opts.path = [] } // Track our location as we recurse if (!utils.isUndefined(opts.prop)) { shouldPop = true opts.path.push(opts.prop) opts.prop = undefined } // Validate against parent schema if (schema['extends']) { // opts.path = path // opts.prop = prop if (utils.isFunction(schema['extends'].validate)) { errors = errors.concat(schema['extends'].validate(value, opts) || []) } else { errors = errors.concat(validate(value, schema['extends'], opts) || []) } } if (utils.isUndefined(value)) { // Check if property is required if (schema.required === true &amp;&amp; !opts.existingOnly) { addError(value, 'a value', opts, errors) } if (shouldPop) { opts.path.pop() opts.prop = prevProp } return errors.length ? errors : undefined } errors = errors.concat(validateAny(value, schema, opts) || []) if (shouldPop) { opts.path.pop() opts.prop = prevProp } return errors.length ? errors : undefined } // These strings are cached for optimal performance of the change detection // boolean - Whether a Record is changing in the current execution frame const changingPath = 'changing' // string[] - Properties that have changed in the current execution frame const changedPath = 'changed' // boolean - Whether a Record is currently being instantiated const creatingPath = 'creating' // number - The setTimeout change event id of a Record, if any const eventIdPath = 'eventId' // boolean - Whether to skip validation for a Record's currently changing property const noValidatePath = 'noValidate' // boolean - Whether to skip change notification for a Record's currently // changing property const silentPath = 'silent' const validationFailureMsg = 'validation failed' /** * Assemble a property descriptor which will be added to the prototype of * {@link Mapper#recordClass}. This method is called when * {@link Mapper#applySchema} is set to `true`. * * TODO: Make this more configurable, i.e. not so tied to the Record class. * * @ignore */ const makeDescriptor = function (prop, schema, opts) { const descriptor = { // Better to allow configurability, but at the user's own risk configurable: true, // These properties are enumerable by default, but regardless of their // enumerability, they won't be &quot;own&quot; properties of individual records enumerable: utils.isUndefined(schema.enumerable) ? true : !!schema.enumerable } // Cache a few strings for optimal performance const keyPath = `props.${prop}` const previousPath = `previous.${prop}` const getter = opts.getter const setter = opts.setter const unsetter = opts.unsetter descriptor.get = function () { return this._get(keyPath) } if (utils.isFunction(schema.get)) { const originalGet = descriptor.get descriptor.get = function () { return schema.get.call(this, originalGet) } } descriptor.set = function (value) { // These are accessed a lot const _get = this[getter] const _set = this[setter] const _unset = this[unsetter] // Optionally check that the new value passes validation if (!_get(noValidatePath)) { const errors = schema.validate(value) if (errors) { // Immediately throw an error, preventing the record from getting into // an invalid state const error = new Error(validationFailureMsg) error.errors = errors throw error } } // TODO: Make it so tracking can be turned on for all properties instead of // only per-property if (schema.track &amp;&amp; !_get(creatingPath)) { const previous = _get(previousPath) const current = _get(keyPath) let changing = _get(changingPath) let changed = _get(changedPath) if (!changing) { // Track properties that are changing in the current event loop changed = [] } // Add changing properties to this array once at most const index = changed.indexOf(prop) if (current !== value &amp;&amp; index === -1) { changed.push(prop) } if (previous === value) { if (index &gt;= 0) { changed.splice(index, 1) } } // No changes in current event loop if (!changed.length) { changing = false _unset(changingPath) _unset(changedPath) // Cancel pending change event if (_get(eventIdPath)) { clearTimeout(_get(eventIdPath)) _unset(eventIdPath) } } // Changes detected in current event loop if (!changing &amp;&amp; changed.length) { _set(changedPath, changed) _set(changingPath, true) // Saving the timeout id allows us to batch all changes in the same // event loop into a single &quot;change&quot; // TODO: Optimize _set(eventIdPath, setTimeout(() =&gt; { // Previous event loop where changes were gathered has ended, so // notify any listeners of those changes and prepare for any new // changes _unset(changedPath) _unset(eventIdPath) _unset(changingPath) // TODO: Optimize if (!_get(silentPath)) { let i for (i = 0; i &lt; changed.length; i++) { this.emit('change:' + changed[i], this, utils.get(this, changed[i])) } this.emit('change', this, this.changes()) } _unset(silentPath) }, 0)) } } _set(keyPath, value) return value } if (utils.isFunction(schema.set)) { const originalSet = descriptor.set descriptor.set = function (value) { return schema.set.call(this, value, originalSet) } } return descriptor } /** * A map of validation functions grouped by type. * * @name Schema.typeGroupValidators * @type {Object} */ const typeGroupValidators = { /** * Validates the provided value against the schema using all of the validation keywords specific to instances of an array. * The validation keywords for the type `array` are: *``` * ['items', 'maxItems', 'minItems', 'uniqueItems'] *``` * see http://json-schema.org/latest/json-schema-validation.html#anchor25 * * @name Schema.typeGroupValidators.array * @method * @param {*} value [array] Array to be validated. * @param {Object} [schema] Schema containing at least one array keyword. * @param {Object} [opts] Configuration options. * @returns {(array|undefined)} Array of errors or `undefined` if valid. */ array: function (value, schema, opts) { return runOps(ARRAY_OPS, value, schema, opts) }, /** * Validates the provided value against the schema using all of the validation keywords specific to instances of an integer. * The validation keywords for the type `integer` are: *``` * ['multipleOf', 'maximum', 'minimum'] *``` * @name Schema.typeGroupValidators.integer * @method * @param {*} value [number] Number to be validated. * @param {Object} [schema] Schema containing at least one `integer` keyword. * @param {Object} [opts] Configuration options. * @returns {(array|undefined)} Array of errors or `undefined` if valid. */ integer: function (value, schema, opts) { // Additional validations for numerics are the same return typeGroupValidators.numeric(value, schema, opts) }, /** * Validates the provided value against the schema using all of the validation keywords specific to instances of an number. * The validation keywords for the type `number` are: *``` * ['multipleOf', 'maximum', 'minimum'] *``` * @name Schema.typeGroupValidators.number * @method * @param {*} value [number] Number to be validated. * @param {Object} [schema] Schema containing at least one `number` keyword. * @param {Object} [opts] Configuration options. * @returns {(array|undefined)} Array of errors or `undefined` if valid. */ number: function (value, schema, opts) { // Additional validations for numerics are the same return typeGroupValidators.numeric(value, schema, opts) }, /** * Validates the provided value against the schema using all of the validation keywords specific to instances of a number or integer. * The validation keywords for the type `numeric` are: *``` * ['multipleOf', 'maximum', 'minimum'] *``` * See http://json-schema.org/latest/json-schema-validation.html#anchor13. * * @name Schema.typeGroupValidators.numeric * @method * @param {*} value [number] Number to be validated. * @param {Object} [schema] Schema containing at least one `numeric` keyword. * @param {Object} [opts] Configuration options. * @returns {(array|undefined)} Array of errors or `undefined` if valid. */ numeric: function (value, schema, opts) { return runOps(NUMERIC_OPS, value, schema, opts) }, /** * Validates the provided value against the schema using all of the validation keywords specific to instances of an object. * The validation keywords for the type `object` are: *``` * ['maxProperties', 'minProperties', 'required', 'properties', 'dependencies'] *``` * See http://json-schema.org/latest/json-schema-validation.html#anchor53. * * @name Schema.typeGroupValidators.object * @method * @param {*} value [number] Object to be validated. * @param {Object} [schema] Schema containing at least one `object` keyword. * @param {Object} [opts] Configuration options. * @returns {(array|undefined)} Array of errors or `undefined` if valid. */ object: function (value, schema, opts) { return runOps(OBJECT_OPS, value, schema, opts) }, /** * Validates the provided value against the schema using all of the validation keywords specific to instances of an string. * The validation keywords for the type `string` are: *``` * ['maxLength', 'minLength', 'pattern'] *``` * See http://json-schema.org/latest/json-schema-validation.html#anchor25. * * @name Schema.typeGroupValidators.string * @method * @param {*} value [number] String to be validated. * @param {Object} [schema] Schema containing at least one `string` keyword. * @param {Object} [opts] Configuration options. * @returns {(array|undefined)} Array of errors or `undefined` if valid. */ string: function (value, schema, opts) { return runOps(STRING_OPS, value, schema, opts) } } /** * js-data's Schema class. * * ```javascript * import {Schema} from 'js-data' * ``` * * @class Schema * @extends Component * @param {Object} definition Schema definition according to json-schema.org */ function Schema (definition) { definition || (definition = {}) // TODO: schema validation utils.fillIn(this, definition) // TODO: rework this to make sure all possible keywords are converted if (definition.properties) { utils.forOwn(definition.properties, function (_definition, prop) { if (!(_definition instanceof Schema)) { definition.properties[prop] = new Schema(_definition) } }) } } export default Component.extend({ constructor: Schema, /** * This adds ES5 getters/setters to the target based on the &quot;properties&quot; in * this Schema, which makes possible change tracking and validation on * property assignment. * * @name Schema#validate * @method * @param {Object} target The prototype to which to apply this schema. */ apply (target, opts) { opts || (opts = {}) opts.getter = opts.getter || '_get' opts.setter = opts.setter || '_set' opts.unsetter = opts.unsetter || '_unset' const properties = this.properties || {} utils.forOwn(properties, function (schema, prop) { Object.defineProperty( target, prop, makeDescriptor(prop, schema, opts) ) }) }, /** * Validate the provided value against this schema. * * @name Schema#validate * @method * @param {*} value Value to validate. * @param {Object} [opts] Configuration options. * @returns {(array|undefined)} Array of errors or `undefined` if valid. */ validate (value, opts) { return validate(value, this, opts) } }, { typeGroupValidators, types, validate, validationKeywords }) × Search results Close api.js-data.io • js-data.io "},"utils.js.html":{"id":"utils.js.html","title":"Source: utils.js","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentDataStoreLinkedCollectionMapperQueryRecordSchema Source: utils.js /** * Utility methods used by JSData. * * @example * import {utils} from 'js-data' * console.log(utils.isString('foo')) // true * * @namespace utils * @type {Object} */ const DOMAIN = 'utils' const INFINITY = 1 / 0 const MAX_INTEGER = 1.7976931348623157e+308 const BOOL_TAG = '[object Boolean]' const DATE_TAG = '[object Date]' const FUNC_TAG = '[object Function]' const NUMBER_TAG = '[object Number]' const OBJECT_TAG = '[object Object]' const REGEXP_TAG = '[object RegExp]' const STRING_TAG = '[object String]' const objToString = Object.prototype.toString const PATH = /^(.+)\\.(.+)$/ const ERRORS = { '400' () { return `expected: ${arguments[0]}, found: ${arguments[2] ? arguments[1] : typeof arguments[1]}` }, '404' () { return `${arguments[0]} not found` } } const toInteger = function (value) { if (!value) { return 0 } // Coerce to number value = +value if (value === INFINITY || value === -INFINITY) { const sign = (value &lt; 0 ? -1 : 1) return sign * MAX_INTEGER } const remainder = value % 1 return value === value ? (remainder ? value - remainder : value) : 0 // eslint-disable-line } const toStr = function (value) { return objToString.call(value) } const isPlainObject = function (value) { return (!!value &amp;&amp; typeof value === 'object' &amp;&amp; value.constructor === Object) } const mkdirP = function (object, path) { if (!path) { return object } const parts = path.split('.') parts.forEach(function (key) { if (!object[key]) { object[key] = {} } object = object[key] }) return object } const utils = { /** * Reference to the Promise constructor used by JSData. Defaults to * `window.Promise` or `global.Promise`. * * @example &lt;caption&gt;Make JSData use a different `Promise` constructor&lt;/caption&gt; * import Promise from 'bluebird' * import {utils} from 'js-data' * utils.Promise = Promise * * @name utils.Promise * @since 3.0.0 * @type {Function} */ Promise: Promise, /** * Shallow copy properties that meet the following criteria from `src` to * `dest`: * * - own enumerable * - not a function * - does not start with &quot;_&quot; * * @method utils._ * @param {Object} dest Destination object. * @param {Object} src Source object. * @private * @since 3.0.0 */ _ (dest, src) { utils.forOwn(src, function (value, key) { if (key &amp;&amp; utils.isUndefined(dest[key]) &amp;&amp; !utils.isFunction(value) &amp;&amp; key.indexOf('_') !== 0) { dest[key] = value } }) }, /** * Recursively iterates over relations found in `opts.with`. * * @method utils._forRelation * @param {Object} opts Configuration options. * @param {Relation} def Relation definition. * @param {Function} fn Callback function. * @param {*} [thisArg] Execution context for the callback function. * @private * @since 3.0.0 */ _forRelation (opts, def, fn, thisArg) { const relationName = def.relation let containedName = null let index opts || (opts = {}) opts.with || (opts.with = []) if ((index = utils._getIndex(opts.with, relationName)) &gt;= 0) { containedName = relationName } else if ((index = utils._getIndex(opts.with, def.localField)) &gt;= 0) { containedName = def.localField } if (opts.withAll) { fn.call(thisArg, def, {}) return } else if (!containedName) { return } let optsCopy = {} utils.fillIn(optsCopy, def.getRelation()) utils.fillIn(optsCopy, opts) optsCopy.with = opts.with.slice() optsCopy._activeWith = optsCopy.with.splice(index, 1)[0] optsCopy.with.forEach(function (relation, i) { if (relation &amp;&amp; relation.indexOf(containedName) === 0 &amp;&amp; relation.length &gt;= containedName.length &amp;&amp; relation[containedName.length] === '.') { optsCopy.with[i] = relation.substr(containedName.length + 1) } else { optsCopy.with[i] = '' } }) fn.call(thisArg, def, optsCopy) }, /** * Find the index of a relation in the given list * * @method utils._getIndex * @param {string[]} list List to search. * @param {string} relation Relation to find. * @private * @returns {number} */ _getIndex (list, relation) { let index = -1 list.forEach(function (_relation, i) { if (_relation === relation) { index = i return false } else if (utils.isObject(_relation)) { if (_relation.relation === relation) { index = i return false } } }) return index }, /** * Define hidden (non-enumerable), writable properties on `target` from the * provided `props`. * * @example * import {utils} from 'js-data' * function Cat () {} * utils.addHiddenPropsToTarget(Cat.prototype, { * say () { * console.log('meow') * } * }) * const cat = new Cat() * cat.say() // &quot;meow&quot; * * @method utils.addHiddenPropsToTarget * @param {Object} target That to which `props` should be added. * @param {Object} props Properties to be added to `target`. * @since 3.0.0 */ addHiddenPropsToTarget (target, props) { const map = {} Object.keys(props).forEach(function (propName) { const descriptor = Object.getOwnPropertyDescriptor(props, propName) descriptor.enumerable = false map[propName] = descriptor }) Object.defineProperties(target, map) }, /** * Return whether the two objects are deeply different. * * @example * import {utils} from 'js-data' * utils.areDifferent({}, {}) // false * utils.areDifferent({ a: 1 }, { a: 1 }) // false * utils.areDifferent({ foo: 'bar' }, {}) // true * * @method utils.areDifferent * @param {Object} a Base object. * @param {Object} b Comparison object. * @param {Object} [opts] Configuration options. * @param {Function} [opts.equalsFn={@link utils.deepEqual}] Equality function. * @param {Array} [opts.ignore=[]] Array of strings or RegExp of fields to ignore. * @returns {boolean} Whether the two objects are deeply different. * @see utils.diffObjects * @since 3.0.0 */ areDifferent (newObject, oldObject, opts) { opts || (opts = {}) const diff = utils.diffObjects(newObject, oldObject, opts) const diffCount = Object.keys(diff.added).length + Object.keys(diff.removed).length + Object.keys(diff.changed).length return diffCount &gt; 0 }, /** * Verified that the given constructor is being invoked via `new`, as opposed * to just being called like a normal function. * * @example * import {utils} from 'js-data' * function Cat () { * utils.classCallCheck(this, Cat) * } * const cat = new Cat() // this is ok * Cat() // this throws an error * * @method utils.classCallCheck * @param {*} instance Instance that is being constructed. * @param {Constructor} ctor Constructor function used to construct the * instance. * @since 3.0.0 * @throws {Error} Throws an error if the constructor is being improperly * invoked. */ classCallCheck (instance, ctor) { if (!(instance instanceof ctor)) { throw utils.err(`${ctor.name}`)(500, 'Cannot call a class as a function') } }, /** * Deep copy a value. * * @example * import {utils} from 'js-data' * const a = { foo: { bar: 'baz' } } * const b = utils.copy(a) * a === b // false * utils.areDifferent(a, b) // false * * @param {*} from Value to deep copy. * @param {*} [to] Destination object for the copy operation. * @param {*} [stackFrom] For internal use. * @param {*} [stackTo] For internal use. * @param {string[]|RegExp[]} [blacklist] List of strings or RegExp of * properties to skip. * @param {boolean} [plain] Whether to make a plain copy (don't try to use * original prototype). * @returns {*} Deep copy of `from`. * @since 3.0.0 */ copy (from, to, stackFrom, stackTo, blacklist, plain) { if (!to) { to = from if (from) { if (utils.isArray(from)) { to = utils.copy(from, [], stackFrom, stackTo, blacklist, plain) } else if (utils.isDate(from)) { to = new Date(from.getTime()) } else if (utils.isRegExp(from)) { to = new RegExp(from.source, from.toString().match(/[^\\/]*$/)[0]) to.lastIndex = from.lastIndex } else if (utils.isObject(from)) { if (plain) { to = utils.copy(from, {}, stackFrom, stackTo, blacklist, plain) } else { to = utils.copy(from, Object.create(Object.getPrototypeOf(from)), stackFrom, stackTo, blacklist, plain) } } } } else { if (from === to) { throw utils.err(`${DOMAIN}.copy`)(500, 'Cannot copy! Source and destination are identical.') } stackFrom = stackFrom || [] stackTo = stackTo || [] if (utils.isObject(from)) { let index = stackFrom.indexOf(from) if (index !== -1) { return stackTo[index] } stackFrom.push(from) stackTo.push(to) } let result if (utils.isArray(from)) { let i to.length = 0 for (i = 0; i &lt; from.length; i++) { result = utils.copy(from[i], null, stackFrom, stackTo, blacklist, plain) if (utils.isObject(from[i])) { stackFrom.push(from[i]) stackTo.push(result) } to.push(result) } } else { if (utils.isArray(to)) { to.length = 0 } else { utils.forOwn(to, function (value, key) { delete to[key] }) } for (var key in from) { if (from.hasOwnProperty(key)) { if (utils.isBlacklisted(key, blacklist)) { continue } result = utils.copy(from[key], null, stackFrom, stackTo, blacklist, plain) if (utils.isObject(from[key])) { stackFrom.push(from[key]) stackTo.push(result) } to[key] = result } } } } return to }, /** * Recursively shallow fill in own enumerable properties from `source` to * `dest`. * * @example * import {utils} from 'js-data' * const a = { foo: { bar: 'baz' }, beep: 'boop' } * const b = { beep: 'bip' } * utils.deepFillIn(b, a) * console.log(b) // {&quot;foo&quot;:{&quot;bar&quot;:&quot;baz&quot;},&quot;beep&quot;:&quot;bip&quot;} * * @method utils.deepFillIn * @param {Object} dest The destination object. * @param {Object} source The source object. * @see utils.fillIn * @see utils.deepMixIn * @since 3.0.0 */ deepFillIn (dest, source) { if (source) { utils.forOwn(source, function (value, key) { const existing = dest[key] if (isPlainObject(value) &amp;&amp; isPlainObject(existing)) { utils.deepFillIn(existing, value) } else if (!dest.hasOwnProperty(key) || dest[key] === undefined) { dest[key] = value } }) } return dest }, /** * Recursively shallow copy own enumerable properties from `source` to `dest`. * * @example * import {utils} from 'js-data' * const a = { foo: { bar: 'baz' }, beep: 'boop' } * const b = { beep: 'bip' } * utils.deepFillIn(b, a) * console.log(b) // {&quot;foo&quot;:{&quot;bar&quot;:&quot;baz&quot;},&quot;beep&quot;:&quot;boop&quot;} * * @method utils.deepMixIn * @param {Object} dest The destination object. * @param {Object} source The source object. * @see utils.fillIn * @see utils.deepFillIn * @since 3.0.0 */ deepMixIn (dest, source) { if (source) { utils.forOwn(source, function (value, key) { const existing = dest[key] if (isPlainObject(value) &amp;&amp; isPlainObject(existing)) { utils.deepMixIn(existing, value) } else { dest[key] = value } }) } return dest }, /** * Return a diff of the base object to the comparison object. * * @example * import {utils} from 'js-data' * const oldObject = { foo: 'bar', a: 1234 } * const newObject = { beep: 'boop', a: 5678 } * const diff = utils.diffObjects(oldObject, newObject) * console.log(diff.added) // {&quot;beep&quot;:&quot;boop&quot;} * console.log(diff.changed) // {&quot;a&quot;:5678} * console.log(diff.removed) // {&quot;foo&quot;:undefined} * * @method utils.diffObjects * @param {Object} newObject Comparison object. * @param {Object} oldObject Base object. * @param {Object} [opts] Configuration options. * @param {Function} [opts.equalsFn={@link utils.deepEqual}] Equality function. * @param {Array} [opts.ignore=[]] Array of strings or RegExp of fields to ignore. * @returns {Object} The diff from the base object to the comparison object. * @see utils.areDifferent * @since 3.0.0 */ diffObjects (newObject, oldObject, opts) { opts || (opts = {}) let equalsFn = opts.equalsFn let blacklist = opts.ignore const diff = { added: {}, changed: {}, removed: {} } if (!utils.isFunction(equalsFn)) { equalsFn = utils.deepEqual } const newKeys = Object.keys(newObject).filter(function (key) { return !utils.isBlacklisted(key, blacklist) }) const oldKeys = Object.keys(oldObject).filter(function (key) { return !utils.isBlacklisted(key, blacklist) }) // Check for properties that were added or changed newKeys.forEach(function (key) { const oldValue = oldObject[key] const newValue = newObject[key] if (equalsFn(oldValue, newValue)) { return } if (utils.isUndefined(oldValue)) { diff.added[key] = newValue } else { diff.changed[key] = newValue } }) // Check for properties that were removed oldKeys.forEach(function (key) { const oldValue = oldObject[key] const newValue = newObject[key] if (utils.isUndefined(newValue) &amp;&amp; !utils.isUndefined(oldValue)) { diff.removed[key] = undefined } }) return diff }, /** * Return whether the two values are equal according to the `==` operator. * * @method utils.equal * @param {*} a First value in the comparison. * @param {*} b Second value in the comparison. * @returns {boolean} Whether the two values are equal according to `==`. * @since 3.0.0 */ equal (a, b) { return a == b // eslint-disable-line }, /** * Produce a factory function for making Error objects with the provided * metadata. Used throughout the various js-data components. * * @method utils.err * @param {string} domain Namespace. * @param {string} target Target. * @returns {Function} Factory function. * @since 3.0.0 */ err (domain, target) { return function (code) { const prefix = `[${domain}:${target}] ` let message = ERRORS[code].apply(null, Array.prototype.slice.call(arguments, 1)) message = `${prefix}${message}\\nhttp://www.js-data.io/v3.0/docs/errors#${code}` return new Error(message) } }, /** * Add eventing capabilities into the target object. * * @method utils.eventify * @param {Object} target Target object. * @param {Function} [getter] Custom getter for retrieving the object's event * listeners. * @param {Function} [setter] Custom setter for setting the object's event * listeners. * @since 3.0.0 */ eventify (target, getter, setter) { target = target || this let _events = {} if (!getter &amp;&amp; !setter) { getter = function () { return _events } setter = function (value) { _events = value } } Object.defineProperties(target, { emit: { value (...args) { const events = getter.call(this) || {} const type = args.shift() let listeners = events[type] || [] let i for (i = 0; i &lt; listeners.length; i++) { listeners[i].f.apply(listeners[i].c, args) } listeners = events.all || [] args.unshift(type) for (i = 0; i &lt; listeners.length; i++) { listeners[i].f.apply(listeners[i].c, args) } } }, off: { value (type, func) { const events = getter.call(this) const listeners = events[type] if (!listeners) { setter.call(this, {}) } else if (func) { for (let i = 0; i &lt; listeners.length; i++) { if (listeners[i].f === func) { listeners.splice(i, 1) break } } } else { listeners.splice(0, listeners.length) } } }, on: { value (type, func, thisArg) { if (!getter.call(this)) { setter.call(this, {}) } const events = getter.call(this) events[type] = events[type] || [] events[type].push({ c: thisArg, f: func }) } } }) }, /** * Used for sublcassing. Invoke this method in the context of a superclass to * to produce a subclass based on `props` and `classProps`. * * @example * import {utils} from 'js-data' * function Animal () {} * Animal.extend = utils.extend * const Cat = Animal.extend({ * say () { * console.log('meow') * } * }) * const cat = new Cat() * cat instanceof Animal // true * cat instanceof Cat // true * cat.say() // &quot;meow&quot; * * @method utils.extend * @param {Object} props Instance properties for the subclass. * @param {Object} [props.constructor] Provide a custom constructor function * to use as the subclass. * @param {Object} props Static properties for the subclass. * @returns {Constructor} A new subclass. * @since 3.0.0 */ extend (props, classProps) { const superClass = this let subClass props || (props = {}) classProps || (classProps = {}) if (props.hasOwnProperty('constructor')) { subClass = props.constructor delete props.constructor } else { subClass = function (...args) { utils.classCallCheck(this, subClass) superClass.apply(this, args) } } // Setup inheritance of instance members subClass.prototype = Object.create(superClass &amp;&amp; superClass.prototype, { constructor: { configurable: true, enumerable: false, value: subClass, writable: true } }) const obj = Object // Setup inheritance of static members if (obj.setPrototypeOf) { obj.setPrototypeOf(subClass, superClass) } else if (classProps.strictEs6Class) { subClass.__proto__ = superClass // eslint-disable-line } else { utils.forOwn(superClass, function (value, key) { subClass[key] = value }) } if (!subClass.hasOwnProperty('__super__')) { Object.defineProperty(subClass, '__super__', { configurable: true, value: superClass }) } utils.addHiddenPropsToTarget(subClass.prototype, props) utils.fillIn(subClass, classProps) return subClass }, /** * Shallow copy own enumerable properties from `src` to `dest` that are on * `src` but are missing from `dest. * * @example * import {utils} from 'js-data' * const a = { foo: 'bar', beep: 'boop' } * const b = { beep: 'bip' } * utils.fillIn(b, a) * console.log(b) // {&quot;foo&quot;:&quot;bar&quot;,&quot;beep&quot;:&quot;bip&quot;} * * @method utils.fillIn * @param {Object} dest The destination object. * @param {Object} source The source object. * @see utils.deepFillIn * @see utils.deepMixIn * @since 3.0.0 */ fillIn (dest, src) { utils.forOwn(src, function (value, key) { if (!dest.hasOwnProperty(key) || dest[key] === undefined) { dest[key] = value } }) }, /** * Find the last index of something according to the given checker function. * * @method utils.findIndex * @param {Array} array The array to search. * @param {Function} fn Checker function. * @returns {number} Index if found or -1 if not found. * @since 3.0.0 */ findIndex (array, fn) { let index = -1 if (!array) { return index } array.forEach(function (record, i) { if (fn(record)) { index = i return false } }) return index }, /** * Recursively iterate over a {@link Mapper}'s relations according to * `opts.with`. * * @method utils.forEachRelation * @param {Mapper} mapper Mapper. * @param {Object} opts Configuration options. * @param {Function} fn Callback function. * @param {*} thisArg Execution context for the callback function. * @since 3.0.0 */ forEachRelation (mapper, opts, fn, thisArg) { const relationList = mapper.relationList || [] if (!relationList.length) { return } relationList.forEach(function (def) { utils._forRelation(opts, def, fn, thisArg) }) }, /** * Iterate over an object's own enumerable properties. * * @example * import {utils} from 'js-data' * const a = { b: 1, c: 4 } * let sum = 0 * utils.forOwn(a, function (value, key) { * sum += value * }) * console.log(sum) // 5 * * @method utils.forOwn * @param {Object} object The object whose properties are to be enumerated. * @param {Function} fn Iteration function. * @param {Object} [thisArg] Content to which to bind `fn`. * @since 3.0.0 */ forOwn (obj, fn, thisArg) { const keys = Object.keys(obj) const len = keys.length let i for (i = 0; i &lt; len; i++) { fn.call(thisArg, obj[keys[i]], keys[i], obj) } }, /** * Proxy for `JSON.parse`. * * @method utils.fromJson * @param {string} json JSON to parse. * @returns {Object} Parsed object. * @see utils.toJson * @since 3.0.0 */ fromJson (json) { return utils.isString(json) ? JSON.parse(json) : json }, /** * Retrieve the specified property from the given object. Supports retrieving * nested properties. * * @example * import {utils} from 'js-data' * const a = { foo: { bar: 'baz' }, beep: 'boop' } * console.log(utils.get(a, 'beep')) // &quot;boop&quot; * console.log(utils.get(a, 'foo.bar')) // &quot;bar&quot; * * @method utils.get * @param {Object} object Object from which to retrieve a property's value. * @param {string} prop Property to retrieve. * @returns {*} Value of the specified property. * @see utils.set * @since 3.0.0 */ 'get': function (object, prop) { if (!prop) { return } const parts = prop.split('.') const last = parts.pop() while (prop = parts.shift()) { // eslint-disable-line object = object[prop] if (object == null) { // eslint-disable-line return } } return object[last] }, /** * Return the superclass for the given instance or subclass. If an instance is * provided, then finds the parent class of the instance's constructor. * * @method utils.getSuper * @param {Object|Function} instance Instance or constructor. * @param {boolean} [isCtor=false] Whether `instance` is a constructor. * @returns {Constructor} The superclass (grandparent constructor). * @since 3.0.0 */ getSuper (instance, isCtor) { const ctor = isCtor ? instance : instance.constructor if (ctor.hasOwnProperty('__super__')) { return ctor.__super__ } return Object.getPrototypeOf(ctor) || ctor.__proto__ // eslint-disable-line }, /** * Return the intersection of two arrays. * * @method utils.intersection * @param {Array} array1 First array. * @param {Array} array2 Second array. * @returns {Array} Array of elements common to both arrays. * @since 3.0.0 */ intersection (array1, array2) { if (!array1 || !array2) { return [] } const result = [] let item let i const len = array1.length for (i = 0; i &lt; len; i++) { item = array1[i] if (result.indexOf(item) !== -1) { continue } if (array2.indexOf(item) !== -1) { result.push(item) } } return result }, /** * Proxy for `Array.isArray`. * * @method utils.isArray * @param {*} value The value to test. * @returns {boolean} Whether the provided value is an array. * @since 3.0.0 */ isArray: Array.isArray, /** * Return whether `prop` is matched by any string or regular expression in * `blacklist`. * * @method utils.isBlacklisted * @param {string} prop The name of a property to check. * @param {Array} blacklist Array of strings and regular expressions. * @returns {boolean} Whether `prop` was matched. * @since 3.0.0 */ isBlacklisted (prop, blacklist) { if (!blacklist || !blacklist.length) { return false } let matches for (var i = 0; i &lt; blacklist.length; i++) { if ((toStr(blacklist[i]) === REGEXP_TAG &amp;&amp; blacklist[i].test(prop)) || blacklist[i] === prop) { matches = prop return matches } } return !!matches }, /** * Return whether the provided value is a boolean. * * @method utils.isBoolean * @param {*} value The value to test. * @returns {boolean} Whether the provided value is a boolean. * @since 3.0.0 */ isBoolean (value) { return toStr(value) === BOOL_TAG }, /** * Return whether the provided value is a date. * * @method utils.isDate * @param {*} value The value to test. * @returns {Date} Whether the provided value is a date. * @since 3.0.0 */ isDate (value) { return (value &amp;&amp; typeof value === 'object' &amp;&amp; toStr(value) === DATE_TAG) }, /** * Return whether the provided value is a function. * * @method utils.isFunction * @param {*} value The value to test. * @returns {boolean} Whether the provided value is a function. * @since 3.0.0 */ isFunction (value) { return typeof value === 'function' || (value &amp;&amp; toStr(value) === FUNC_TAG) }, /** * Return whether the provided value is an integer. * * @method utils.isInteger * @param {*} value The value to test. * @returns {boolean} Whether the provided value is an integer. * @since 3.0.0 */ isInteger (value) { return toStr(value) === NUMBER_TAG &amp;&amp; value == toInteger(value) // eslint-disable-line }, /** * Return whether the provided value is `null`. * * @method utils.isNull * @param {*} value The value to test. * @returns {boolean} Whether the provided value is `null`. * @since 3.0.0 */ isNull (value) { return value === null }, /** * Return whether the provided value is a number. * * @method utils.isNumber * @param {*} value The value to test. * @returns {boolean} Whether the provided value is a number. * @since 3.0.0 */ isNumber (value) { const type = typeof value return type === 'number' || (value &amp;&amp; type === 'object' &amp;&amp; toStr(value) === NUMBER_TAG) }, /** * Return whether the provided value is an object. * * @method utils.isObject * @param {*} value The value to test. * @returns {boolean} Whether the provided value is an object. * @since 3.0.0 */ isObject (value) { return toStr(value) === OBJECT_TAG }, /** * Return whether the provided value is a regular expression. * * @method utils.isRegExp * @param {*} value The value to test. * @returns {boolean} Whether the provided value is a regular expression. * @since 3.0.0 */ isRegExp (value) { return toStr(value) === REGEXP_TAG }, /** * Return whether the provided value is a string or a number. * * @method utils.isSorN * @param {*} value The value to test. * @returns {boolean} Whether the provided value is a string or a number. * @since 3.0.0 */ isSorN (value) { return utils.isString(value) || utils.isNumber(value) }, /** * Return whether the provided value is a string. * * @method utils.isString * @param {*} value The value to test. * @returns {boolean} Whether the provided value is a string. * @since 3.0.0 */ isString (value) { return typeof value === 'string' || (value &amp;&amp; typeof value === 'object' &amp;&amp; toStr(value) === STRING_TAG) }, /** * Return whether the provided value is a `undefined`. * * @method utils.isUndefined * @param {*} value The value to test. * @returns {boolean} Whether the provided value is a `undefined`. * @since 3.0.0 */ isUndefined (value) { return value === undefined }, /** * Mix in logging capabilities to the target. * * @method utils.logify * @param {*} target The target. * @since 3.0.0 */ logify (target) { utils.addHiddenPropsToTarget(target, { dbg (...args) { this.log('debug', ...args) }, log (level, ...args) { if (level &amp;&amp; !args.length) { args.push(level) level = 'debug' } if (level === 'debug' &amp;&amp; !this.debug) { return } const prefix = `${level.toUpperCase()}: (${this.name || this.constructor.name})` if (console[level]) { console[level](prefix, ...args) } else { console.log(prefix, ...args) } } }) }, /** * Adds the given record to the provided array only if it's not already in the * array. * * @method utils.noDupeAdd * @param {Array} array The array. * @param {*} record The value to add. * @param {Function} fn Callback function passed to {@link utils.findIndex}. * @since 3.0.0 */ noDupeAdd (array, record, fn) { if (!array) { return } const index = this.findIndex(array, fn) if (index &lt; 0) { array.push(record) } }, /** * Return a shallow copy of the provided object, minus the properties * specified in `keys`. * * @method utils.omit * @param {Object} props The object to copy. * @param {string[]} keys Array of strings, representing properties to skip. * @returns {Object} Shallow copy of `props`, minus `keys`. * @since 3.0.0 */ omit (props, keys) { const _props = {} utils.forOwn(props, function (value, key) { if (keys.indexOf(key) === -1) { _props[key] = value } }) return _props }, /** * Return a shallow copy of the provided object, but only include the * properties specified in `keys`. * * @method utils.pick * @param {Object} props The object to copy. * @param {string[]} keys Array of strings, representing properties to keep. * @returns {Object} Shallow copy of `props`, but only including `keys`. * @since 3.0.0 */ pick (props, keys) { const _props = {} utils.forOwn(props, function (value, key) { if (keys.indexOf(key) !== -1) { _props[key] = value } }) return _props }, /** * Return a plain copy of the given value. * * @method utils.plainCopy * @param {*} value The value to copy. * @returns {*} Plain copy of `value`. * @see utils.copy * @since 3.0.0 */ plainCopy (value) { return utils.copy(value, undefined, undefined, undefined, undefined, true) }, /** * Shortcut for `utils.Promise.reject(value)`. * * @method utils.reject * @param {*} [value] Value with which to reject the Promise. * @returns {Promise} Promise reject with `value`. * @see utils.Promise * @since 3.0.0 */ reject (value) { return utils.Promise.reject(value) }, /** * Remove the last item found in array according to the given checker function. * * @method utils.remove * @param {Array} array The array to search. * @param {Function} fn Checker function. */ remove (array, fn) { if (!array || !array.length) { return } const index = this.findIndex(array, fn) if (index &gt;= 0) { array.splice(index, 1) } }, /** * Shortcut for `utils.Promise.resolve(value)`. * * @ignore * @param {*} [value] Value with which to resolve the Promise. * @returns {Promise} Promise resolved with `value`. * @see utils.Promise * @since 3.0.0 */ resolve (value) { return utils.Promise.resolve(value) }, /** * Set the value at the provided key or path. * * @method utils.set * @param {Object} object The object on which to set a property. * @param {(string|Object)} path The key or path to the property. Can also * pass in an object of path/value pairs, which will all be set on the target * object. * @param {*} [value] The value to set. */ set: function (object, path, value) { if (utils.isObject(path)) { utils.forOwn(path, function (value, _path) { utils.set(object, _path, value) }) } else { const parts = PATH.exec(path) if (parts) { mkdirP(object, parts[1])[parts[2]] = value } else { object[path] = value } } }, /** * Check whether the two provided objects are deeply equal. * * @method utils.deepEqual * @param {Object} a First object in the comparison. * @param {Object} b Second object in the comparison. * @returns {boolean} Whether the two provided objects are deeply equal. * @see utils.equal * @since 3.0.0 */ deepEqual (a, b) { if (a === b) { return true } let _equal = true if (utils.isObject(a) &amp;&amp; utils.isObject(b)) { utils.forOwn(a, function (value, key) { _equal = _equal &amp;&amp; utils.deepEqual(value, b[key]) }) if (!_equal) { return _equal } utils.forOwn(b, function (value, key) { _equal = _equal &amp;&amp; utils.deepEqual(value, a[key]) }) } else if (utils.isArray(a) &amp;&amp; utils.isArray(b)) { a.forEach(function (value, i) { _equal = _equal &amp;&amp; utils.deepEqual(value, b[i]) if (!_equal) { return false } }) } else { return false } return _equal }, /** * Proxy for `JSON.stringify`. * * @method utils.toJson * @param {*} value Value to serialize to JSON. * @returns {string} JSON string. * @see utils.fromJson * @since 3.0.0 */ toJson: JSON.stringify, /** * Unset the value at the provided key or path. * * @method utils.unset * @param {Object} object The object from which to delete the property. * @param {string} path The key or path to the property. * @see utils.set * @since 3.0.0 */ unset (object, path) { const parts = path.split('.') const last = parts.pop() while (path = parts.shift()) { // eslint-disable-line object = object[path] if (object == null) { // eslint-disable-line return } } object[last] = undefined } } export default utils × Search results Close api.js-data.io • js-data.io "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentDataStoreLinkedCollectionMapperQueryRecordSchema Modules Details Classes Collection Component DataStore LinkedCollection Mapper Query Record Schema Namespaces query utils × Search results Close api.js-data.io • js-data.io "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentDataStoreLinkedCollectionMapperQueryRecordSchema Classes Details Classes Collection Component DataStore LinkedCollection Mapper Query Record Schema Namespaces query utils × Search results Close api.js-data.io • js-data.io "},"namespaces.list.html":{"id":"namespaces.list.html","title":"Namespaces","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentDataStoreLinkedCollectionMapperQueryRecordSchema Namespaces Details Classes Collection Component DataStore LinkedCollection Mapper Query Record Schema Namespaces query utils × Search results Close api.js-data.io • js-data.io "},"index.html":{"id":"index.html","title":"Index","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentDataStoreLinkedCollectionMapperQueryRecordSchema js-data 3.0.0-beta.7 js-data v3 beta Browser tests Node.js tests JSData v3 beta is stable. More features may be added before 3.0.0. Some adapters still need to be updated to work with v3. Message @jmdobry on the JSData Slack channel if you want to help with tests, documentation, tutorials, adapters, etc. JSData is a framework-agnostic, datastore-agnostic ORM/ODM for Node.js and the Browser. Adapters allow JSData to connect to various data sources such as Firebase, MySql, RethinkDB, MongoDB, localStorage, Redis, a REST API, etc. With JSData you can re-use your data modeling code between environments, keep your data layer intact when transitioning between app frameworks, and work with a unified data API on the server and the client. JSData employs conventions for rapid development, but allows for endless customization in order to meet your particular needs. To get started, visit the main website at http://js-data.io. Links Quick start - Get started in 5 minutes Guides and Tutorials - Learn how to use JSData API Reference Docs - Explore components, methods, options, etc. Community &amp; Support - Find solutions and chat with the community General Contributing Guide - Give back and move the project forward Contributing to js-data core LicenseThe MIT License (MIT) Copyright (c) 2014-2016 js-data project authors LICENSE AUTHORS CONTRIBUTORS × Search results Close api.js-data.io • js-data.io "},"Collection.html":{"id":"Collection.html","title":"Class: Collection","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentDataStoreLinkedCollectionMapperQueryRecordSchema Class: Collection Collection new Collection(records, opts) An ordered set of Record instances. Method parameters: Name Type Argument Description records Array &lt;optional&gt; Initial set of records to insert into the collection. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description commitOnMerge String &lt;optional&gt; See Collection#commitOnMerge. idAttribute String &lt;optional&gt; See Collection#idAttribute. onConflict String &lt;optional&gt; &quot;merge&quot; See Collection#onConflict. mapper String &lt;optional&gt; See Collection#mapper. Details Type Since Source Function 3.0.0 Collection.js, line 56 Example import {Collection, Record} from 'js-data' const user1 = new Record({ id: 1 }) const user2 = new Record({ id: 2 }) const UserCollection = new Collection([user1, user2]) UserCollection.get(1) === user1 // true Extends This class extends the Component class. Members _listeners Event listeners attached to this Component. Do not modify. Use Component#on and Component#off instead. Details Type Since Source Object 3.0.0 Component.js, line 7 Inherited From: Component#_listeners commitOnMerge Whether to call Record#commit on records that are added to the collection and already exist in the collection. Details Type Default value Source Boolean true Collection.js, line 9 idAttribute Field to be used as the unique identifier for records in this collection. Defaults to &quot;id&quot; unless Collection#mapper is set, in which case this will default to Mapper#idAttribute. Details Type Default value Source String &quot;id&quot; Collection.js, line 19 index The main index, which uses @{link Collection#recordId} as the key. Details Type Source Index Collection.js, line 137 indexes Object that holds the secondary indexes of this collection. Details Type Source Object.&lt;string, Index&gt; Collection.js, line 151 mapper Default Mapper for this collection. Optional. If a Mapper is provided, then the collection will use the Mapper#idAttribute setting, and will wrap records in Mapper#recordClass. Details Type Since Default value Source Mapper 3.0.0 null Collection.js, line 94 Example import {Collection, Mapper} from 'js-data' class MyMapperClass extends Mapper { foo () { return 'bar' } } const myMapper = new MyMapperClass() const collection = new Collection(null, { mapper: myMapper }) onConflict What to do when inserting a record into this Collection that shares a primary key with a record already in this Collection. Possible values: merge replace Merge: Recursively shallow copy properties from the new record onto the existing record. Replace: Shallow copy top-level properties from the new record onto the existing record. Any top-level own properties of the existing record that are not on the new record will be removed. Details Type Default value Source String &quot;merge&quot; Collection.js, line 30 Methods &lt;static&gt; extend(props, classProps) Create a subclass of this Collection. Method parameters: Name Type Argument Default Description props Object &lt;optional&gt; {} Properties to add to the prototype of the subclass. classProps Object &lt;optional&gt; {} Static properties to add to the subclass. Return value: Type Description Constructor Subclass of this Collection class. Details Since Source 3.0.0 Collection.js, line 751 Examples Extend the class in a cross-browser manner. import {Collection} from 'js-data' const CustomCollectionClass = Collection.extend({ foo () { return 'bar' } }) const customCollection = new CustomCollectionClass() console.log(customCollection.foo()) // &quot;bar&quot; Extend the class using ES2015 class syntax. class CustomCollectionClass extends Collection { foo () { return 'bar' } } const customCollection = new CustomCollectionClass() console.log(customCollection.foo()) // &quot;bar&quot; add(data, opts) Insert the provided record or records. If a record is already in the collection then the provided record will either merge with or replace the existing record based on the value of the onConflict option. The collection's secondary indexes will be updated as each record is visited. Method parameters: Name Type Argument Description data Object | Array.&lt;Object&gt; | Record | Array.&lt;Record&gt; The record or records to insert. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description commitOnMerge Boolean &lt;optional&gt; true See Collection#commitOnMerge. onConflict String &lt;optional&gt; See Collection#onConflict. Return value: Type Description Object | Array.&lt;Object&gt; | Record | Array.&lt;Record&gt; The added record or records. Details Since Source 3.0.0 Collection.js, line 183 afterRemove(id, opts, record) Lifecycle hook called by Collection#remove. If this method returns a value then Collection#remove will return that same value. Method parameters: Name Type Description id String | Number The id argument passed to Collection#remove. opts Object The opts argument passed to Collection#remove. record Object The result that will be returned by Collection#remove. Details Since Source 3.0.0 Collection.js, line 294 afterRemoveAll(query, opts, records) Lifecycle hook called by Collection#removeAll. If this method returns a value then Collection#removeAll will return that same value. Method parameters: Name Type Description query Object The query argument passed to Collection#removeAll. opts Object The opts argument passed to Collection#removeAll. records Object The result that will be returned by Collection#removeAll. Details Since Source 3.0.0 Collection.js, line 306 beforeAdd(records, opts) Lifecycle hook called by Collection#add. If this method returns a value then the records argument in Collection#add will be re-assigned to the returned value. Method parameters: Name Type Description records Object | Array.&lt;Object&gt; | Record | Array.&lt;Record&gt; The records argument passed to Collection#add. opts Object The opts argument passed to Collection#add. Details Since Source 3.0.0 Collection.js, line 319 beforeRemove(id, opts) Lifecycle hook called by Collection#remove. Method parameters: Name Type Description id String | Number The id argument passed to Collection#remove. opts Object The opts argument passed to Collection#remove. Details Since Source 3.0.0 Collection.js, line 331 beforeRemoveAll(query, opts) Lifecycle hook called by Collection#removeAll. Method parameters: Name Type Description query Object The query argument passed to Collection#removeAll. opts Object The opts argument passed to Collection#removeAll. Details Since Source 3.0.0 Collection.js, line 341 between(leftKeys, rightKeys, opts) Find all records between two boundaries. Shortcut for collection.query().between(18, 30, { index: 'age' }).run() Method parameters: Name Type Argument Description leftKeys Array Keys defining the left boundary. rightKeys Array Keys defining the right boundary. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description index String &lt;optional&gt; Name of the secondary index to use in the query. If no index is specified, the main index is used. leftInclusive Boolean &lt;optional&gt; true Whether to include records on the left boundary. rightInclusive Boolean &lt;optional&gt; false Whether to include records on the left boundary. limit Boolean &lt;optional&gt; Limit the result to a certain number. offset Boolean &lt;optional&gt; The number of resulting records to skip. Return value: Type Description Array The result. Details Since Source 3.0.0 Collection.js, line 351 Examples Get all users ages 18 to 30 const users = collection.between(18, 30, { index: 'age' }) Same as above const users = collection.between([18], [30], { index: 'age' }) createIndex(name, fieldList) Create a new secondary index on the contents of the collection. Method parameters: Name Type Argument Description name String The name of the new secondary index. fieldList Array.&lt;String&gt; &lt;optional&gt; Array of field names to use as the key or compound key of the new secondary index. If no fieldList is provided, then the name will also be the field that is used to index the collection. Return value: Type Description Collection A reference to itself for chaining. Details Since Source 3.0.0 Collection.js, line 381 Examples Index users by age collection.createIndex('age') Index users by status and role collection.createIndex('statusAndRole', ['status', 'role']) dbg(args) Log the provided values at the &quot;debug&quot; level. Method parameters: Name Type Argument Description args * &lt;optional&gt; &lt;repeatable&gt; Values to log. Details Since Source 3.0.0 Component.js, line 32 Inherited From: Component#dbg emit(event, args) Trigger an event on this Component. Method parameters: Name Type Argument Description event String Name of event to emit. args * &lt;optional&gt; &lt;repeatable&gt; Arguments to pass to any listeners. Details Since Source 3.0.0 Component.js, line 98 Inherited From: Component#emit Examples collection.on('foo', (msg) =&gt; { console.log(msg) // &quot;bar&quot; }) collection.emit('foo', 'bar') store.on('foo', (msg, val1, val2) =&gt; { console.log(msg, val1, val2) // &quot;bar&quot; &quot;beep&quot; &quot;boop&quot; }) store.emit('foo', 'bar', 'beep', 'boop') filter(queryOrFn, thisArg) Find the record or records that match the provided query or pass the provided filter function. Shortcut for collection.query().filter(queryOrFn[, thisArg]).run() Method parameters: Name Type Argument Default Description queryOrFn Object | Function &lt;optional&gt; {} Selection query or filter function. thisArg Object &lt;optional&gt; Context to which to bind queryOrFn if queryOrFn is a function. Return value: Type Description Array The result. Details Since Source 3.0.0 Collection.js, line 409 Examples Get the draft posts created less than three months const posts = collection.filter({ where: { status: { '==': 'draft' }, created_at_timestamp: { '&gt;=': (new Date().getTime() - (1000 * 60 * 60 * 24 * 30 * 3)) // 3 months ago } } }) Use a custom filter function const posts = collection.filter(function (post) { return post.isReady() }) forEach(forEachFn, thisArg) Iterate over all records. Method parameters: Name Type Argument Description forEachFn Function Iteration function. thisArg * &lt;optional&gt; Context to which to bind forEachFn. Return value: Type Description Array The result. Details Since Source 3.0.0 Collection.js, line 444 Example collection.forEach(function (record) { // do something }) get(id) Get the record with the given id. Method parameters: Name Type Description id String | Number The primary key of the record to get. Return value: Type Description Object | Record The record with the given id. Details Since Source 3.0.0 Collection.js, line 462 getAll(keyList, opts) Find the record or records that match the provided keyLists. Shortcut for collection.query().getAll(keyList1, keyList2, ...).run() Method parameters: Name Type Argument Description keyList Array &lt;optional&gt; &lt;repeatable&gt; Provide one or more keyLists, and all records matching each keyList will be retrieved. If no keyLists are provided, all records will be returned. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Description index String &lt;optional&gt; Name of the secondary index to use in the query. If no index is specified, the main index is used. Return value: Type Description Array The result. Details Since Source 3.0.0 Collection.js, line 475 Examples Get the posts where &quot;status&quot; is &quot;draft&quot; or &quot;inReview&quot; const posts = collection.getAll('draft', 'inReview', { index: 'status' }) Same as above const posts = collection.getAll(['draft'], ['inReview'], { index: 'status' }) getIndex(name) Return the index with the given name. If no name is provided, return the main index. Throws an error if the specified index does not exist. Method parameters: Name Type Argument Description name String &lt;optional&gt; The name of the index to retrieve. Details Since Source 3.0.0 Collection.js, line 500 limit(num) Limit the result. Shortcut for collection.query().limit(maximumNumber).run() Method parameters: Name Type Description num Number The maximum number of records to keep in the result. Return value: Type Description Array The result. Details Since Source 3.0.0 Collection.js, line 516 Example const posts = collection.limit(10) log(level, args) Log the provided values. By default sends values to console[level]. Method parameters: Name Type Argument Description level String Log level args * &lt;optional&gt; &lt;repeatable&gt; Values to log. Details Since Source 3.0.0 Component.js, line 39 Inherited From: Component#log map(mapFn, thisArg) Apply a mapping function to all records. Method parameters: Name Type Argument Description mapFn Function Mapping function. thisArg * &lt;optional&gt; Context to which to bind mapFn. Return value: Type Description Array The result of the mapping. Details Since Source 3.0.0 Collection.js, line 533 Example const names = collection.map(function (user) { return user.name }) mapCall(funcName) Return the result of calling the specified function on each record in this collection's main index. Method parameters: Name Type Description funcName String Name of function to call Return value: Type Description Array The result. Details Since Source 3.0.0 Collection.js, line 555 method(result, opts) Lifecycle hook called by Collection#add. If this method returns a value then Collection#add will return that same value. Method parameters: Name Type Description result Object | Array.&lt;Object&gt; | Record | Array.&lt;Record&gt; The record or records that were added to this Collection by Collection#add. opts Object The opts argument passed to Collection#add. Details Since Source 3.0.0 Collection.js, line 282 off(event, listener) Remove an event listener from this Component. If no listener is provided, then all listeners for the specified event will be removed. If no event is specified then all listeners for all events will be removed. Method parameters: Name Type Argument Description event String &lt;optional&gt; Name of event to unsubsribe to. listener Function &lt;optional&gt; Listener to remove. Details Since Source 3.0.0 Component.js, line 79 Inherited From: Component#off Examples Remove a listener to a single event collection.off('add', handler) Remove all listeners to a single event record.off('change') Remove all listeners to all events store.off() on(event, listener, ctx) Register a new event listener on this Component. Method parameters: Name Type Argument Description event String Name of event to subsribe to. listener Function Listener function to handle the event. ctx * &lt;optional&gt; Optional content in which to invoke the listener. Details Since Source 3.0.0 Component.js, line 49 Inherited From: Component#on Examples Listen for all &quot;afterCreate&quot; events in a DataStore store.on('afterCreate', (mapperName, props, opts, result) =&gt; { console.log(mapperName) // &quot;post&quot; console.log(props.id) // undefined console.log(result.id) // 1234 }) store.create('post', { title: 'Modeling your data' }).then((post) =&gt; { console.log(post.id) // 1234 }) Listen for the &quot;add&quot; event on a collection collection.on('add', (records) =&gt; { console.log(records) // [...] }) Listen for &quot;change&quot; events on a record post.on('change', (record, changes) =&gt; { console.log(changes) // { changed: { title: 'Modeling your data' } } }) post.title = 'Modeling your data' query() Create a new query to be executed against the contents of the collection. The result will be all or a subset of the contents of the collection. Return value: Type Description Query New query object. Details Since Source 3.0.0 Collection.js, line 591 Example Grab page 2 of users between ages 18 and 30 collection.query() .between(18, 30, { index: 'age' }) // between ages 18 and 30 .skip(10) // second page .limit(10) // page size .run() recordId(record) Return the primary key of the given, or if no record is provided, return the name of the field that holds the primary key of records in this Collection. Method parameters: Name Type Argument Description record Object | Record &lt;optional&gt; The record whose primary key is to be returned. Return value: Type Description String | Number Primary key or name of field that holds primary key. Details Since Source 3.0.0 Collection.js, line 573 reduce(cb, initialValue) Reduce the data in the collection to a single value and return the result. Method parameters: Name Type Description cb Function Reduction callback. initialValue * Initial value of the reduction. Return value: Type Description * The result. Details Since Source 3.0.0 Collection.js, line 611 Example const totalVotes = collection.reduce(function (prev, record) { return prev + record.upVotes + record.downVotes }, 0) remove(id, opts) Remove the record with the given id from this Collection. Method parameters: Name Type Argument Description id String | Number The primary key of the record to be removed. opts Object &lt;optional&gt; Configuration options. Return value: Type Description Object | Record The removed record, if any. Details Since Source 3.0.0 Collection.js, line 630 removeAll(query, opts) Remove the record selected by &quot;query&quot; from this collection. Method parameters: Name Type Argument Default Description query Object &lt;optional&gt; {} Selection query. See query. Properties Name Type Argument Description where Object &lt;optional&gt; See query.where. offset Number &lt;optional&gt; See query.offset. limit Number &lt;optional&gt; See query.limit. orderBy String | Array.&lt;Array&gt; &lt;optional&gt; See query.orderBy. opts Object &lt;optional&gt; Configuration options. Return value: Type Description Array.&lt;Object&gt; | Array.&lt;Record&gt; The removed records, if any. Details Since Source 3.0.0 Collection.js, line 659 skip(num) Skip a number of results. Shortcut for collection.query().skip(numberToSkip).run() Method parameters: Name Type Description num Number The number of records to skip. Return value: Type Description Array The result. Details Since Source 3.0.0 Collection.js, line 685 Example const posts = collection.skip(10) toJSON(opts) Return the plain JSON representation of all items in this collection. Assumes records in this collection have a toJSON method. Method parameters: Name Type Argument Description opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Description with Array.&lt;String&gt; &lt;optional&gt; Array of relation names or relation fields to include in the representation. Return value: Type Description Array The records. Details Since Source 3.0.0 Collection.js, line 702 updateIndex(record, opts) Update a record's position in a single index of this collection. See Collection#updateIndexes to update a record's position in all indexes at once. Method parameters: Name Type Argument Description record Object The record to update. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Description index String &lt;optional&gt; The index in which to update the record's position. If you don't specify an index then the record will be updated in the main index. Details Since Source 3.0.0 Collection.js, line 717 updateIndexes(record, opts) TODO Method parameters: Name Type Argument Description record Object TODO opts Object &lt;optional&gt; Configuration options. Details Since Source 3.0.0 Collection.js, line 735 × Search results Close api.js-data.io • js-data.io "},"Component.html":{"id":"Component.html","title":"Class: Component","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentDataStoreLinkedCollectionMapperQueryRecordSchema Class: Component Component new Component() Details Source Component.js, line 3 Members _listeners Event listeners attached to this Component. Do not modify. Use Component#on and Component#off instead. Details Type Since Source Object 3.0.0 Component.js, line 7 Methods &lt;static&gt; extend(props, classProps) Create a subclass of this component. Method parameters: Name Type Argument Default Description props Object &lt;optional&gt; {} Properties to add to the prototype of the subclass. classProps Object &lt;optional&gt; {} Static properties to add to the subclass. Return value: Type Description Constructor Subclass of this component. Details Since Source 3.0.0 Component.js, line 19 dbg(args) Log the provided values at the &quot;debug&quot; level. Method parameters: Name Type Argument Description args * &lt;optional&gt; &lt;repeatable&gt; Values to log. Details Since Source 3.0.0 Component.js, line 32 emit(event, args) Trigger an event on this Component. Method parameters: Name Type Argument Description event String Name of event to emit. args * &lt;optional&gt; &lt;repeatable&gt; Arguments to pass to any listeners. Details Since Source 3.0.0 Component.js, line 98 Examples collection.on('foo', (msg) =&gt; { console.log(msg) // &quot;bar&quot; }) collection.emit('foo', 'bar') store.on('foo', (msg, val1, val2) =&gt; { console.log(msg, val1, val2) // &quot;bar&quot; &quot;beep&quot; &quot;boop&quot; }) store.emit('foo', 'bar', 'beep', 'boop') log(level, args) Log the provided values. By default sends values to console[level]. Method parameters: Name Type Argument Description level String Log level args * &lt;optional&gt; &lt;repeatable&gt; Values to log. Details Since Source 3.0.0 Component.js, line 39 off(event, listener) Remove an event listener from this Component. If no listener is provided, then all listeners for the specified event will be removed. If no event is specified then all listeners for all events will be removed. Method parameters: Name Type Argument Description event String &lt;optional&gt; Name of event to unsubsribe to. listener Function &lt;optional&gt; Listener to remove. Details Since Source 3.0.0 Component.js, line 79 Examples Remove a listener to a single event collection.off('add', handler) Remove all listeners to a single event record.off('change') Remove all listeners to all events store.off() on(event, listener, ctx) Register a new event listener on this Component. Method parameters: Name Type Argument Description event String Name of event to subsribe to. listener Function Listener function to handle the event. ctx * &lt;optional&gt; Optional content in which to invoke the listener. Details Since Source 3.0.0 Component.js, line 49 Examples Listen for all &quot;afterCreate&quot; events in a DataStore store.on('afterCreate', (mapperName, props, opts, result) =&gt; { console.log(mapperName) // &quot;post&quot; console.log(props.id) // undefined console.log(result.id) // 1234 }) store.create('post', { title: 'Modeling your data' }).then((post) =&gt; { console.log(post.id) // 1234 }) Listen for the &quot;add&quot; event on a collection collection.on('add', (records) =&gt; { console.log(records) // [...] }) Listen for &quot;change&quot; events on a record post.on('change', (record, changes) =&gt; { console.log(changes) // { changed: { title: 'Modeling your data' } } }) post.title = 'Modeling your data' × Search results Close api.js-data.io • js-data.io "},"DataStore.html":{"id":"DataStore.html","title":"Class: DataStore","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentDataStoreLinkedCollectionMapperQueryRecordSchema Class: DataStore DataStore new DataStore(opts) The DataStore class is an extension of Container. Not only does DataStore manage mappers, but also collections. DataStore implements the asynchronous Mapper methods, such as Mapper#find and Mapper#create. If you use the asynchronous DataStore methods instead of calling them directly on the mappers, then the results of the method calls will be inserted into the store's collections. You can think of a DataStore as an Identity Map for the ORM (the Mappers). import {DataStore} from 'js-data' Method parameters: Name Type Argument Description opts Object &lt;optional&gt; Configuration options. See Container. Return value: Type Description DataStore Unspecified Details Since Source Tutorials See 3.0.0 DataStore.js, line 57 Components of JSData: DataStore Working with the DataStore Notes on using JSData in the Browser Container Example import {DataStore} from 'js-data' import HttpAdapter from 'js-data-http' const store = new DataStore() // DataStore#defineMapper returns a direct reference to the newly created // Mapper. const UserMapper = store.defineMapper('user') // DataStore#as returns the store scoped to a particular Mapper. const UserStore = store.as('user') // Call &quot;find&quot; on &quot;UserMapper&quot; (Stateless ORM) UserMapper.find(1).then((user) =&gt; { // retrieved a &quot;user&quot; record via the http adapter, but that's it // Call &quot;find&quot; on &quot;store&quot; targeting &quot;user&quot; (Stateful DataStore) return store.find('user', 1) // same as &quot;UserStore.find(1)&quot; }).then((user) =&gt; { // not only was a &quot;user&quot; record retrieved, but it was added to the // store's &quot;user&quot; collection const cachedUser = store.getCollection('user').get(1) console.log(user === cachedUser) // true }) Extends This class extends the Container class. Members mapperClass Constructor function to use in Container#defineMapper to create a new mapper. Mapper Details Type Since Source Constructor 3.0.0 Container.js, line 461 Inherited From: Container#mapperClass mapperDefaults Defaults options to pass to Container#mapperClass when creating a new Mapper. Details Type Since Default value Source Object 3.0.0 {} Container.js, line 450 Inherited From: Container#mapperDefaults Methods &lt;static&gt; extend(props, classProps) Create a subclass of this DataStore. Method parameters: Name Type Argument Default Description props Object &lt;optional&gt; {} Properties to add to the prototype of the subclass. classProps Object &lt;optional&gt; {} Static properties to add to the subclass. Return value: Type Description Constructor Subclass of this DataStore. Details Since Source 3.0.0 DataStore.js, line 1007 Examples Extend the class in a cross-browser manner. import {DataStore} from 'js-data' const CustomDataStoreClass = DataStore.extend({ foo () { return 'bar' } }) const customDataStore = new CustomDataStoreClass() console.log(customDataStore.foo()) // &quot;bar&quot; Extend the class using ES2015 class syntax. class CustomDataStoreClass extends DataStore { foo () { return 'bar' } } const customDataStore = new CustomDataStoreClass() console.log(customDataStore.foo()) // &quot;bar&quot; addToCache(name, data, opts) TODO Method parameters: Name Type Argument Description name String Name of the Mapper to target. data * Data from which data should be selected for add. opts Object &lt;optional&gt; Configuration options. Details Source DataStore.js, line 164 as(name) Return a store scoped to a particular mapper/collection pair. Method parameters: Name Type Description name String Name of the Mapper. Return value: Type Description Object A store scoped to a particular mapper/collection pair. Details Since Source Overrides 3.0.0 DataStore.js, line 176 Container#as Example import {DataStore} from 'js-data' const store = new DataStore() const UserMapper = store.defineMapper('user') const UserStore = store.as('user') const user1 = store.createRecord('user', { name: 'John' }) const user2 = UserStore.createRecord({ name: 'John' }) const user3 = UserMapper.createRecord({ name: 'John' }) assert.deepEqual(user1, user2) assert.deepEqual(user2, user3) assert.deepEqual(user1, user3) cachedFind(name, id, opts) Retrieve a cached find result, if any. Method parameters: Name Type Description name String The name argument passed to DataStore#find. id String | Number The id argument passed to DataStore#find. opts Object The opts argument passed to DataStore#find. Details Since Source 3.0.0 DataStore.js, line 234 cachedFindAll(name, hash, opts) Retrieve a cached findAll result, if any. Method parameters: Name Type Description name String The name argument passed to DataStore#findAll. hash String The result of calling DataStore#hashQuery on the query argument passed to DataStore#findAll. opts Object The opts argument passed to DataStore#findAll. Details Since Source 3.0.0 DataStore.js, line 245 cacheFind(name, data, id, opts) Cache a find result. The default implementation does the following: // Find and return the record from the data store return this.get(name, id)Override this method to customize. Method parameters: Name Type Description name String The name argument passed to DataStore#find. data * The result to cache. id String | Number The id argument passed to DataStore#find. opts Object The opts argument passed to DataStore#find. Details Since Source 3.0.0 DataStore.js, line 257 cacheFindAll(name, data, hash, opts) Cache a findAll result. The default implementation does the following: // Find and return the records from the data store return this.filter(name, utils.fromJson(hash))Override this method to customize. Method parameters: Name Type Description name String The name argument passed to DataStore#findAll. data * The result to cache. hash String The result of calling DataStore#hashQuery on the query argument passed to DataStore#findAll. opts Object The opts argument passed to DataStore#findAll. Details Since Source 3.0.0 DataStore.js, line 278 count(name, query, opts) Wrapper for Mapper#count. Method parameters: Name Type Argument Description name String Name of the Mapper to target. query Object &lt;optional&gt; See Mapper#count. opts Object &lt;optional&gt; See Mapper#count. Return value: Type Description Promise See Mapper#count. Details Since Source See 3.0.0 Container.js, line 8 Mapper#count Inherited From: Container#count Example Get the number of published blog posts import {Container} from 'js-data' import RethinkDBAdapter from 'js-data-rethinkdb' const store = new Container() store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }) store.defineMapper('post') store.count('post', { status: 'published' }).then((numPublished) =&gt; { console.log(numPublished) // e.g. 45 }) create(name, record, opts) Wrapper for Mapper#create. Adds the created to the store. Method parameters: Name Type Argument Description name String Name of the Mapper to target. record Object Passed to Mapper#create. opts Object &lt;optional&gt; Passed to Mapper#create. See Mapper#create for more configuration options. Return value: Type Description Promise Resolves with the result of the create. Details Since Source Overrides 3.0.0 DataStore.js, line 308 Container#create createMany(name, records, opts) Wrapper for Mapper#createMany. Adds the created records to the store. Method parameters: Name Type Argument Description name String Name of the Mapper to target. records Array Passed to Mapper#createMany. opts Object &lt;optional&gt; Passed to Mapper#createMany. See Mapper#createMany for more configuration options. Return value: Type Description Promise Resolves with the result of the create. Details Since Source Overrides 3.0.0 DataStore.js, line 325 Container#createMany createRecord(name, props, opts) Wrapper for Mapper#createRecord. Note: This method does not interact with any adapter, and does not save any data. It only creates new objects in memory. Method parameters: Name Type Argument Description name String Name of the Mapper to target. props Object | Array.&lt;Object&gt; See Mapper#createRecord. opts Object &lt;optional&gt; See Mapper#createRecord. Return value: Type Description Promise See Mapper#createRecord. Details Since Source See 3.0.0 Container.js, line 90 Mapper#createRecord Inherited From: Container#createRecord Example Create empty unsaved record instance import {Container} from 'js-data' const store = new Container() store.defineMapper('post') const post = PostService.createRecord() dbg(name, args) Wrapper for Mapper#dbg. Method parameters: Name Type Argument Description name String Name of the Mapper to target. args * &lt;repeatable&gt; See Mapper#dbg. Details Since Source See 3.0.0 Container.js, line 112 Mapper#dbg Inherited From: Container#dbg defineMapper(name, opts) Create a new mapper and register it in this container. Method parameters: Name Type Argument Description name String Name under which to register the new Mapper. Mapper#name will be set to this value. opts Object &lt;optional&gt; Configuration options. Passed to Container#mapperClass when creating the new Mapper. Return value: Type Description Mapper The newly created instance of Mapper. Details Since Source See 3.0.0 Container.js, line 542 Container#as Inherited From: Container#defineMapper Example import {Container} from 'js-data' const store = new Container({ mapperDefaults: { foo: 'bar' } }) // Container#defineMapper returns a direct reference to the newly created // Mapper. const UserMapper = store.defineMapper('user') UserMapper === store.getMapper('user') // true UserMapper === store.as('user').getMapper() // true UserMapper.foo // &quot;bar&quot; destroy(name, id, opts) Wrapper for Mapper#destroy. Removes any destroyed record from the store. Method parameters: Name Type Argument Description name String Name of the Mapper to target. id String | Number Passed to Mapper#destroy. opts Object &lt;optional&gt; Passed to Mapper#destroy. See Mapper#destroy for more configuration options. Return value: Type Description Promise Resolves when the delete completes. Details Since Source Overrides 3.0.0 DataStore.js, line 655 Container#destroy destroyAll(name, query, opts) Wrapper for Mapper#destroyAll. Removes any destroyed records from the store. Method parameters: Name Type Argument Description name String Name of the Mapper to target. query Object &lt;optional&gt; Passed to Mapper#destroyAll. opts Object &lt;optional&gt; Passed to Mapper#destroyAll. See Mapper#destroyAll for more configuration options. Return value: Type Description Promise Resolves when the delete completes. Details Since Source Overrides 3.0.0 DataStore.js, line 681 Container#destroyAll find(name, id, opts) Wrapper for Mapper#find. Adds any found record to the store. Method parameters: Name Type Argument Description name String Name of the Mapper to target. id String | Number Passed to Mapper#find. opts Object &lt;optional&gt; Passed to Mapper#find. Return value: Type Description Promise Resolves with the result, if any. Details Since Source Overrides 3.0.0 DataStore.js, line 718 Container#find findAll(name, query, opts) Wrapper for Mapper#findAll. Adds any found records to the store. Method parameters: Name Type Argument Description name String Name of the Mapper to target. query Object &lt;optional&gt; Passed to Model.findAll. opts Object &lt;optional&gt; Passed to Model.findAll. Return value: Type Description Promise Resolves with the result, if any. Details Since Source Overrides 3.0.0 DataStore.js, line 756 Container#findAll getAdapter(name) Return the registered adapter with the given name or the default adapter if no name is provided. Method parameters: Name Type Argument Description name String &lt;optional&gt; The name of the adapter to retrieve. Return value: Type Description Adapter The adapter. Details Since Source 3.0.0 Container.js, line 610 Inherited From: Container#getAdapter getAdapterName(opts) Return the name of a registered adapter based on the given name or options, or the name of the default adapter if no name provided. Method parameters: Name Type Argument Description opts Object | String &lt;optional&gt; The name of an adapter or options, if any. Return value: Type Description String The name of the adapter. Details Since Source 3.0.0 Container.js, line 627 Inherited From: Container#getAdapterName getAdapters() Return the registered adapters of this container. Return value: Type Description Adapter Unspecified Details Since Source 3.0.0 Container.js, line 644 Inherited From: Container#getAdapters getCollection(name) Return the LinkedCollection with the given name. Method parameters: Name Type Description name String Name of the LinkedCollection to retrieve. Throws: Thrown if the specified LinkedCollection does not exist. Type Error Return value: Type Description LinkedCollection Unspecified Details Since Source 3.0.0 DataStore.js, line 796 getMapper(name) Return the mapper registered under the specified name. Method parameters: Name Type Description name String Mapper#name. Return value: Type Description Mapper Unspecified Details Since Source 3.0.0 Container.js, line 655 Inherited From: Container#getMapper Example import {Container} from 'js-data' const container = new Container() // Container#defineMapper returns a direct reference to the newly created // Mapper. const UserMapper = container.defineMapper('user') UserMapper === container.getMapper('user') // true UserMapper === container.as('user').getMapper() // true container.getMapper('profile') // throws Error, there is no mapper with name &quot;profile&quot; getMapperByName(name) Return the mapper registered under the specified name. Doesn't throw error if mapper doesn't exist. Method parameters: Name Type Description name String Mapper#name. Return value: Type Description Mapper Unspecified Details Since Source 3.0.0 Container.js, line 681 Inherited From: Container#getMapperByName Example import {Container} from 'js-data' const container = new Container() // Container#defineMapper returns a direct reference to the newly created // Mapper. const UserMapper = container.defineMapper('user') UserMapper === container.getMapperByName('user') // true container.getMapperByName('profile') // undefined getSchema(name) Wrapper for Mapper#getSchema. Method parameters: Name Type Description name String Name of the Mapper to target. Return value: Type Description Schema See Mapper#getSchema. Details Since Source See 3.0.0 Container.js, line 219 Mapper#getSchema Inherited From: Container#getSchema hashQuery(name, query) Hashing function used to cache DataStore#find and DataStore#findAll requests. This method simply JSONifies the query argument passed to DataStore#find or DataStore#findAll. Override this method for custom hashing behavior. Method parameters: Name Type Description name String The name argument passed to DataStore#find or DataStore#findAll. query Object The query argument passed to DataStore#find or DataStore#findAll. Return value: Type Description String The JSONified query. Details Since Source 3.0.0 DataStore.js, line 814 is(name, record) Wrapper for Mapper#is. Method parameters: Name Type Description name String Name of the Mapper to target. record Object | Record See Mapper#is. Return value: Type Description Boolean See Mapper#is. Details Since Source See 3.0.0 Container.js, line 230 Mapper#is Inherited From: Container#is Example import {Container} from 'js-data' const store = new Container() store.defineMapper('post') const post = store.createRecord() console.log(store.is('post', post)) // true // Equivalent to what's above console.log(post instanceof store.getMapper('post').recordClass) // true log(name, args) Wrapper for Mapper#log. Method parameters: Name Type Argument Description name String Name of the Mapper to target. args * &lt;repeatable&gt; See Mapper#log. Details Since Source See 3.0.0 Container.js, line 252 Mapper#log Inherited From: Container#log on(event, listener, ctx) Register a new event listener on this DataStore. Proxy for Container#on. If an event was emitted by a Mapper or Collection in the DataStore, then the name of the Mapper or Collection will be prepended to the arugments passed to the provided event handler. Method parameters: Name Type Argument Description event String Name of event to subsribe to. listener Function Listener function to handle the event. ctx * &lt;optional&gt; Optional content in which to invoke the listener. Details Source Overrides DataStore.js, line 138 Container#on registerAdapter(name, adapter, opts) Register an adapter on this container under the given name. Adapters registered on a container are shared by all mappers in the container. Method parameters: Name Type Argument Description name String The name of the adapter to register. adapter Adapter The adapter to register. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description default Boolean &lt;optional&gt; false Whether to make the adapter the default adapter for all Mappers in this container. Details Since Source Tutorials 3.0.0 Container.js, line 703 Connecting to a data source Inherited From: Container#registerAdapter Example import {Container} from 'js-data' import HttpAdapter from 'js-data-http' const container = new Container() container.registerAdapter('http', new HttpAdapter, { default: true }) remove(name, id, opts) Wrapper for LinkedCollection#remove. Removes the specified Record from the store. Method parameters: Name Type Argument Description name String The name of the LinkedCollection to target. id String | Number The primary key of the Record to remove. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Description with Array.&lt;String&gt; &lt;optional&gt; Relations of the Record to also remove from the store. Return value: Type Description Record The removed Record, if any. Details Since Source 3.0.0 DataStore.js, line 838 removeAll(name, query, opts) Wrapper for LinkedCollection#removeAll. Removes the selected Records from the store. Method parameters: Name Type Argument Default Description name String The name of the LinkedCollection to target. query Object &lt;optional&gt; {} Selection query. See query. Properties Name Type Argument Description where Object &lt;optional&gt; See query.where. offset Number &lt;optional&gt; See query.offset. limit Number &lt;optional&gt; See query.limit. orderBy String | Array.&lt;Array&gt; &lt;optional&gt; See query.orderBy. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Description with Array.&lt;String&gt; &lt;optional&gt; Relations of the Record to also remove from the store. Return value: Type Description Record The removed Records, if any. Details Since Source 3.0.0 DataStore.js, line 859 removeRelated(name, records, opts) Remove from the store Records that are related to the provided Record(s). Method parameters: Name Type Argument Description name String The name of the LinkedCollection to target. records Record | Array.&lt;Record&gt; Records whose relations are to be removed. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Description with Array.&lt;String&gt; &lt;optional&gt; Relations of the Record(s) to remove from the store. Details Since Source 3.0.0 DataStore.js, line 884 sum(name, field, query, opts) Wrapper for Mapper#sum. Method parameters: Name Type Argument Description name String Name of the Mapper to target. field String See Mapper#sum. query Object &lt;optional&gt; See Mapper#sum. opts Object &lt;optional&gt; See Mapper#sum. Return value: Type Description Promise See Mapper#sum. Details Since Source See 3.0.0 Container.js, line 263 Mapper#sum Inherited From: Container#sum Example import {Container} from 'js-data' import RethinkDBAdapter from 'js-data-rethinkdb' const store = new Container() store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }) store.defineMapper('purchase_order') store.sum('purchase_order', 'amount', { status: 'paid' }).then((amountPaid) =&gt; { console.log(amountPaid) // e.g. 451125.34 }) toJSON(name, records, opts) Wrapper for Mapper#toJSON. Method parameters: Name Type Argument Description name String Name of the Mapper to target. records Record | Array.&lt;Record&gt; See Mapper#toJSON. opts Object &lt;optional&gt; See Mapper#toJSON. Return value: Type Description Object | Array.&lt;Object&gt; See Mapper#toJSON. Details Since Source See 3.0.0 Container.js, line 288 Mapper#toJSON Inherited From: Container#toJSON Example import {Container} from 'js-data' import RethinkDBAdapter from 'js-data-rethinkdb' const store = new Container() store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }) store.defineMapper('person', { schema: { properties: { name: { type: 'string' }, id: { type: 'string' } } } }) const person = store.createRecord('person', { id: 1, name: 'John', foo: 'bar' }) console.log(store.toJSON('person', person)) // {&quot;id&quot;:1,&quot;name&quot;:&quot;John&quot;,&quot;foo&quot;:&quot;bar&quot;} console.log(store.toJSON('person', person), { strict: true }) // {&quot;id&quot;:1,&quot;name&quot;:&quot;John&quot;} update(name, id, record, opts) Wrapper for Mapper#update. Adds the updated Record to the store. Method parameters: Name Type Argument Description name String Name of the Mapper to target. id String | Number Passed to Mapper#update. record Object Passed to Mapper#update. opts Object &lt;optional&gt; Passed to Mapper#update. See Mapper#update for more configuration options. Return value: Type Description Promise Resolves with the result of the update. Details Since Source Overrides 3.0.0 DataStore.js, line 942 Container#update updateAll(name, props, query, opts) Wrapper for Mapper#updateAll. Adds the updated Records to the store. Method parameters: Name Type Argument Description name String Name of the Mapper to target. props Object Passed to Mapper#updateAll. query Object &lt;optional&gt; Passed to Mapper#updateAll. opts Object &lt;optional&gt; Passed to Mapper#updateAll. See Mapper#updateAll for more configuration options. Return value: Type Description Promise Resolves with the result of the update. Details Since Source Overrides 3.0.0 DataStore.js, line 961 Container#updateAll updateMany(name, records, opts) Wrapper for Mapper#updateMany. Adds the updated Records to the store. Method parameters: Name Type Argument Description name String Name of the Mapper to target. records Array.&lt;Object&gt; | Array.&lt;Record&gt; Passed to Mapper#updateMany. opts Object &lt;optional&gt; Passed to Mapper#updateMany. See Mapper#updateMany for more configuration options. Return value: Type Description Promise Resolves with the result of the update. Details Since Source Overrides 3.0.0 DataStore.js, line 980 Container#updateMany validate(name, records, opts) Wrapper for Mapper#validate. Method parameters: Name Type Argument Description name String Name of the Mapper to target. records Array.&lt;Object&gt; | Array.&lt;Record&gt; See Mapper#validate. opts Object &lt;optional&gt; See Mapper#validate. Return value: Type Description Promise See Mapper#validate. Details Since Source See 3.0.0 Container.js, line 401 Mapper#validate Inherited From: Container#validate Example import {Container} from 'js-data' const store = new Container() store.defineMapper('post', { schema: { properties: { name: { type: 'string' }, id: { type: 'string' } } } }) let errors = store.validate('post', { name: 'John' }) console.log(errors) // undefined errors = store.validate('post', { name: 123 }) console.log(errors) // [{ expected: 'one of (string)', actual: 'number', path: 'name' }] × Search results Close api.js-data.io • js-data.io "},"LinkedCollection.html":{"id":"LinkedCollection.html","title":"Class: LinkedCollection","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentDataStoreLinkedCollectionMapperQueryRecordSchema Class: LinkedCollection LinkedCollection new LinkedCollection(records, opts) TODO import {LinkedCollection} from 'js-data' Method parameters: Name Type Argument Description records Array &lt;optional&gt; Initial set of records to insert into the collection. See Collection. opts Object &lt;optional&gt; Configuration options. See Collection. Return value: Type Description Mapper Unspecified Details Source LinkedCollection.js, line 7 Extends This class extends the Collection class. Members _listeners Event listeners attached to this Component. Do not modify. Use Component#on and Component#off instead. Details Type Since Source Object 3.0.0 Component.js, line 7 Inherited From: Component#_listeners commitOnMerge Whether to call Record#commit on records that are added to the collection and already exist in the collection. Details Type Default value Source Boolean true Collection.js, line 9 Inherited From: Collection#commitOnMerge idAttribute Field to be used as the unique identifier for records in this collection. Defaults to &quot;id&quot; unless Collection#mapper is set, in which case this will default to Mapper#idAttribute. Details Type Default value Source String &quot;id&quot; Collection.js, line 19 Inherited From: Collection#idAttribute index The main index, which uses @{link Collection#recordId} as the key. Details Type Source Index Collection.js, line 137 Inherited From: Collection#index indexes Object that holds the secondary indexes of this collection. Details Type Source Object.&lt;string, Index&gt; Collection.js, line 151 Inherited From: Collection#indexes mapper Default Mapper for this collection. Optional. If a Mapper is provided, then the collection will use the Mapper#idAttribute setting, and will wrap records in Mapper#recordClass. Details Type Since Default value Source Mapper 3.0.0 null Collection.js, line 94 Inherited From: Collection#mapper Example import {Collection, Mapper} from 'js-data' class MyMapperClass extends Mapper { foo () { return 'bar' } } const myMapper = new MyMapperClass() const collection = new Collection(null, { mapper: myMapper }) onConflict What to do when inserting a record into this Collection that shares a primary key with a record already in this Collection. Possible values: merge replace Merge: Recursively shallow copy properties from the new record onto the existing record. Replace: Shallow copy top-level properties from the new record onto the existing record. Any top-level own properties of the existing record that are not on the new record will be removed. Details Type Default value Source String &quot;merge&quot; Collection.js, line 30 Inherited From: Collection#onConflict Methods &lt;static&gt; extend(props, classProps) Create a subclass of this LinkedCollection. Method parameters: Name Type Argument Default Description props Object &lt;optional&gt; {} Properties to add to the prototype of the subclass. classProps Object &lt;optional&gt; {} Static properties to add to the subclass. Return value: Type Description Constructor Subclass of this LinkedCollection class. Details Since Source 3.0.0 LinkedCollection.js, line 113 Examples Extend the class in a cross-browser manner. import {LinkedCollection} from 'js-data' const CustomLinkedCollectionClass = LinkedCollection.extend({ foo () { return 'bar' } }) const customLinkedCollection = new CustomLinkedCollectionClass() console.log(customLinkedCollection.foo()) // &quot;bar&quot; Extend the class using ES2015 class syntax. class CustomLinkedCollectionClass extends LinkedCollection { foo () { return 'bar' } } const customLinkedCollection = new CustomLinkedCollectionClass() console.log(customLinkedCollection.foo()) // &quot;bar&quot; add(data, opts) Insert the provided record or records. If a record is already in the collection then the provided record will either merge with or replace the existing record based on the value of the onConflict option. The collection's secondary indexes will be updated as each record is visited. Method parameters: Name Type Argument Description data Object | Array.&lt;Object&gt; | Record | Array.&lt;Record&gt; The record or records to insert. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description commitOnMerge Boolean &lt;optional&gt; true See Collection#commitOnMerge. onConflict String &lt;optional&gt; See Collection#onConflict. Return value: Type Description Object | Array.&lt;Object&gt; | Record | Array.&lt;Record&gt; The added record or records. Details Since Source 3.0.0 Collection.js, line 183 Inherited From: Collection#add afterRemove(id, opts, record) Lifecycle hook called by Collection#remove. If this method returns a value then Collection#remove will return that same value. Method parameters: Name Type Description id String | Number The id argument passed to Collection#remove. opts Object The opts argument passed to Collection#remove. record Object The result that will be returned by Collection#remove. Details Since Source 3.0.0 Collection.js, line 294 Inherited From: Collection#afterRemove afterRemoveAll(query, opts, records) Lifecycle hook called by Collection#removeAll. If this method returns a value then Collection#removeAll will return that same value. Method parameters: Name Type Description query Object The query argument passed to Collection#removeAll. opts Object The opts argument passed to Collection#removeAll. records Object The result that will be returned by Collection#removeAll. Details Since Source 3.0.0 Collection.js, line 306 Inherited From: Collection#afterRemoveAll beforeAdd(records, opts) Lifecycle hook called by Collection#add. If this method returns a value then the records argument in Collection#add will be re-assigned to the returned value. Method parameters: Name Type Description records Object | Array.&lt;Object&gt; | Record | Array.&lt;Record&gt; The records argument passed to Collection#add. opts Object The opts argument passed to Collection#add. Details Since Source 3.0.0 Collection.js, line 319 Inherited From: Collection#beforeAdd beforeRemove(id, opts) Lifecycle hook called by Collection#remove. Method parameters: Name Type Description id String | Number The id argument passed to Collection#remove. opts Object The opts argument passed to Collection#remove. Details Since Source 3.0.0 Collection.js, line 331 Inherited From: Collection#beforeRemove beforeRemoveAll(query, opts) Lifecycle hook called by Collection#removeAll. Method parameters: Name Type Description query Object The query argument passed to Collection#removeAll. opts Object The opts argument passed to Collection#removeAll. Details Since Source 3.0.0 Collection.js, line 341 Inherited From: Collection#beforeRemoveAll between(leftKeys, rightKeys, opts) Find all records between two boundaries. Shortcut for collection.query().between(18, 30, { index: 'age' }).run() Method parameters: Name Type Argument Description leftKeys Array Keys defining the left boundary. rightKeys Array Keys defining the right boundary. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description index String &lt;optional&gt; Name of the secondary index to use in the query. If no index is specified, the main index is used. leftInclusive Boolean &lt;optional&gt; true Whether to include records on the left boundary. rightInclusive Boolean &lt;optional&gt; false Whether to include records on the left boundary. limit Boolean &lt;optional&gt; Limit the result to a certain number. offset Boolean &lt;optional&gt; The number of resulting records to skip. Return value: Type Description Array The result. Details Since Source 3.0.0 Collection.js, line 351 Inherited From: Collection#between Examples Get all users ages 18 to 30 const users = collection.between(18, 30, { index: 'age' }) Same as above const users = collection.between([18], [30], { index: 'age' }) createIndex(name, fieldList) Create a new secondary index on the contents of the collection. Method parameters: Name Type Argument Description name String The name of the new secondary index. fieldList Array.&lt;String&gt; &lt;optional&gt; Array of field names to use as the key or compound key of the new secondary index. If no fieldList is provided, then the name will also be the field that is used to index the collection. Return value: Type Description Collection A reference to itself for chaining. Details Since Source 3.0.0 Collection.js, line 381 Inherited From: Collection#createIndex Examples Index users by age collection.createIndex('age') Index users by status and role collection.createIndex('statusAndRole', ['status', 'role']) dbg(args) Log the provided values at the &quot;debug&quot; level. Method parameters: Name Type Argument Description args * &lt;optional&gt; &lt;repeatable&gt; Values to log. Details Since Source 3.0.0 Component.js, line 32 Inherited From: Component#dbg emit(event, args) Trigger an event on this Component. Method parameters: Name Type Argument Description event String Name of event to emit. args * &lt;optional&gt; &lt;repeatable&gt; Arguments to pass to any listeners. Details Since Source 3.0.0 Component.js, line 98 Inherited From: Component#emit Examples collection.on('foo', (msg) =&gt; { console.log(msg) // &quot;bar&quot; }) collection.emit('foo', 'bar') store.on('foo', (msg, val1, val2) =&gt; { console.log(msg, val1, val2) // &quot;bar&quot; &quot;beep&quot; &quot;boop&quot; }) store.emit('foo', 'bar', 'beep', 'boop') filter(queryOrFn, thisArg) Find the record or records that match the provided query or pass the provided filter function. Shortcut for collection.query().filter(queryOrFn[, thisArg]).run() Method parameters: Name Type Argument Default Description queryOrFn Object | Function &lt;optional&gt; {} Selection query or filter function. thisArg Object &lt;optional&gt; Context to which to bind queryOrFn if queryOrFn is a function. Return value: Type Description Array The result. Details Since Source 3.0.0 Collection.js, line 409 Inherited From: Collection#filter Examples Get the draft posts created less than three months const posts = collection.filter({ where: { status: { '==': 'draft' }, created_at_timestamp: { '&gt;=': (new Date().getTime() - (1000 * 60 * 60 * 24 * 30 * 3)) // 3 months ago } } }) Use a custom filter function const posts = collection.filter(function (post) { return post.isReady() }) forEach(forEachFn, thisArg) Iterate over all records. Method parameters: Name Type Argument Description forEachFn Function Iteration function. thisArg * &lt;optional&gt; Context to which to bind forEachFn. Return value: Type Description Array The result. Details Since Source 3.0.0 Collection.js, line 444 Inherited From: Collection#forEach Example collection.forEach(function (record) { // do something }) get(id) Get the record with the given id. Method parameters: Name Type Description id String | Number The primary key of the record to get. Return value: Type Description Object | Record The record with the given id. Details Since Source 3.0.0 Collection.js, line 462 Inherited From: Collection#get getAll(keyList, opts) Find the record or records that match the provided keyLists. Shortcut for collection.query().getAll(keyList1, keyList2, ...).run() Method parameters: Name Type Argument Description keyList Array &lt;optional&gt; &lt;repeatable&gt; Provide one or more keyLists, and all records matching each keyList will be retrieved. If no keyLists are provided, all records will be returned. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Description index String &lt;optional&gt; Name of the secondary index to use in the query. If no index is specified, the main index is used. Return value: Type Description Array The result. Details Since Source 3.0.0 Collection.js, line 475 Inherited From: Collection#getAll Examples Get the posts where &quot;status&quot; is &quot;draft&quot; or &quot;inReview&quot; const posts = collection.getAll('draft', 'inReview', { index: 'status' }) Same as above const posts = collection.getAll(['draft'], ['inReview'], { index: 'status' }) getIndex(name) Return the index with the given name. If no name is provided, return the main index. Throws an error if the specified index does not exist. Method parameters: Name Type Argument Description name String &lt;optional&gt; The name of the index to retrieve. Details Since Source 3.0.0 Collection.js, line 500 Inherited From: Collection#getIndex limit(num) Limit the result. Shortcut for collection.query().limit(maximumNumber).run() Method parameters: Name Type Description num Number The maximum number of records to keep in the result. Return value: Type Description Array The result. Details Since Source 3.0.0 Collection.js, line 516 Inherited From: Collection#limit Example const posts = collection.limit(10) log(level, args) Log the provided values. By default sends values to console[level]. Method parameters: Name Type Argument Description level String Log level args * &lt;optional&gt; &lt;repeatable&gt; Values to log. Details Since Source 3.0.0 Component.js, line 39 Inherited From: Component#log map(mapFn, thisArg) Apply a mapping function to all records. Method parameters: Name Type Argument Description mapFn Function Mapping function. thisArg * &lt;optional&gt; Context to which to bind mapFn. Return value: Type Description Array The result of the mapping. Details Since Source 3.0.0 Collection.js, line 533 Inherited From: Collection#map Example const names = collection.map(function (user) { return user.name }) mapCall(funcName) Return the result of calling the specified function on each record in this collection's main index. Method parameters: Name Type Description funcName String Name of function to call Return value: Type Description Array The result. Details Since Source 3.0.0 Collection.js, line 555 Inherited From: Collection#mapCall method(result, opts) Lifecycle hook called by Collection#add. If this method returns a value then Collection#add will return that same value. Method parameters: Name Type Description result Object | Array.&lt;Object&gt; | Record | Array.&lt;Record&gt; The record or records that were added to this Collection by Collection#add. opts Object The opts argument passed to Collection#add. Details Since Source 3.0.0 Collection.js, line 282 Inherited From: Collection#method off(event, listener) Remove an event listener from this Component. If no listener is provided, then all listeners for the specified event will be removed. If no event is specified then all listeners for all events will be removed. Method parameters: Name Type Argument Description event String &lt;optional&gt; Name of event to unsubsribe to. listener Function &lt;optional&gt; Listener to remove. Details Since Source 3.0.0 Component.js, line 79 Inherited From: Component#off Examples Remove a listener to a single event collection.off('add', handler) Remove all listeners to a single event record.off('change') Remove all listeners to all events store.off() on(event, listener, ctx) Register a new event listener on this Component. Method parameters: Name Type Argument Description event String Name of event to subsribe to. listener Function Listener function to handle the event. ctx * &lt;optional&gt; Optional content in which to invoke the listener. Details Since Source 3.0.0 Component.js, line 49 Inherited From: Component#on Examples Listen for all &quot;afterCreate&quot; events in a DataStore store.on('afterCreate', (mapperName, props, opts, result) =&gt; { console.log(mapperName) // &quot;post&quot; console.log(props.id) // undefined console.log(result.id) // 1234 }) store.create('post', { title: 'Modeling your data' }).then((post) =&gt; { console.log(post.id) // 1234 }) Listen for the &quot;add&quot; event on a collection collection.on('add', (records) =&gt; { console.log(records) // [...] }) Listen for &quot;change&quot; events on a record post.on('change', (record, changes) =&gt; { console.log(changes) // { changed: { title: 'Modeling your data' } } }) post.title = 'Modeling your data' query() Create a new query to be executed against the contents of the collection. The result will be all or a subset of the contents of the collection. Return value: Type Description Query New query object. Details Since Source 3.0.0 Collection.js, line 591 Inherited From: Collection#query Example Grab page 2 of users between ages 18 and 30 collection.query() .between(18, 30, { index: 'age' }) // between ages 18 and 30 .skip(10) // second page .limit(10) // page size .run() recordId(record) Return the primary key of the given, or if no record is provided, return the name of the field that holds the primary key of records in this Collection. Method parameters: Name Type Argument Description record Object | Record &lt;optional&gt; The record whose primary key is to be returned. Return value: Type Description String | Number Primary key or name of field that holds primary key. Details Since Source 3.0.0 Collection.js, line 573 Inherited From: Collection#recordId reduce(cb, initialValue) Reduce the data in the collection to a single value and return the result. Method parameters: Name Type Description cb Function Reduction callback. initialValue * Initial value of the reduction. Return value: Type Description * The result. Details Since Source 3.0.0 Collection.js, line 611 Inherited From: Collection#reduce Example const totalVotes = collection.reduce(function (prev, record) { return prev + record.upVotes + record.downVotes }, 0) remove(id, opts) Remove the record with the given id from this Collection. Method parameters: Name Type Argument Description id String | Number The primary key of the record to be removed. opts Object &lt;optional&gt; Configuration options. Return value: Type Description Object | Record The removed record, if any. Details Since Source 3.0.0 Collection.js, line 630 Inherited From: Collection#remove removeAll(query, opts) Remove the record selected by &quot;query&quot; from this collection. Method parameters: Name Type Argument Default Description query Object &lt;optional&gt; {} Selection query. See query. Properties Name Type Argument Description where Object &lt;optional&gt; See query.where. offset Number &lt;optional&gt; See query.offset. limit Number &lt;optional&gt; See query.limit. orderBy String | Array.&lt;Array&gt; &lt;optional&gt; See query.orderBy. opts Object &lt;optional&gt; Configuration options. Return value: Type Description Array.&lt;Object&gt; | Array.&lt;Record&gt; The removed records, if any. Details Since Source 3.0.0 Collection.js, line 659 Inherited From: Collection#removeAll skip(num) Skip a number of results. Shortcut for collection.query().skip(numberToSkip).run() Method parameters: Name Type Description num Number The number of records to skip. Return value: Type Description Array The result. Details Since Source 3.0.0 Collection.js, line 685 Inherited From: Collection#skip Example const posts = collection.skip(10) toJSON(opts) Return the plain JSON representation of all items in this collection. Assumes records in this collection have a toJSON method. Method parameters: Name Type Argument Description opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Description with Array.&lt;String&gt; &lt;optional&gt; Array of relation names or relation fields to include in the representation. Return value: Type Description Array The records. Details Since Source 3.0.0 Collection.js, line 702 Inherited From: Collection#toJSON updateIndex(record, opts) Update a record's position in a single index of this collection. See Collection#updateIndexes to update a record's position in all indexes at once. Method parameters: Name Type Argument Description record Object The record to update. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Description index String &lt;optional&gt; The index in which to update the record's position. If you don't specify an index then the record will be updated in the main index. Details Since Source 3.0.0 Collection.js, line 717 Inherited From: Collection#updateIndex updateIndexes(record, opts) TODO Method parameters: Name Type Argument Description record Object TODO opts Object &lt;optional&gt; Configuration options. Details Since Source 3.0.0 Collection.js, line 735 Inherited From: Collection#updateIndexes × Search results Close api.js-data.io • js-data.io "},"Mapper.html":{"id":"Mapper.html","title":"Class: Mapper","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentDataStoreLinkedCollectionMapperQueryRecordSchema Class: Mapper Mapper new Mapper(opts) The core of JSData's ORM/ODM implementation. Given a minimum amout of meta information about a resource, a Mapper can perform generic CRUD operations against that resource. Apart from its configuration, a Mapper is stateless. The particulars of various persistence layers have been abstracted into adapters, which a Mapper uses to perform its operations. The term &quot;Mapper&quot; comes from the Data Mapper Pattern described in Martin Fowler's Patterns of Enterprise Application Architecture. A Data Mapper moves data between in-memory object instances and a relational or document-based database. JSData's Mapper can work with any persistence layer you can write an adapter for. (&quot;Model&quot; is a heavily overloaded term and is avoided in this documentation to prevent confusion.) Method parameters: Name Type Description opts Object Configuration options. Properties Name Type Argument Default Description applySchema Boolean &lt;optional&gt; true See Mapper#applySchema. debug Boolean &lt;optional&gt; false See Mapper#debug. defaultAdapter String &lt;optional&gt; http See Mapper#defaultAdapter. idAttribute String &lt;optional&gt; id See Mapper#idAttribute. name String See Mapper#name. notify Boolean &lt;optional&gt; See Mapper#notify. raw Boolean &lt;optional&gt; false See Mapper#raw. recordClass Function | Boolean &lt;optional&gt; See Mapper#recordClass. Return value: Type Description Mapper A new Mapper instance. Details Since Source Tutorials See 3.0.0 Mapper.js, line 207 Components of JSData: Mapper Modeling your data http://www.js-data.io/v3.0/docs/components-of-jsdata#mapper Examples Import and instantiate import {Mapper} from 'js-data' const UserService = new Mapper({ name: 'user' }) Define a Mapper using the Container component import {Container} from 'js-data' const store = new Container() store.defineMapper('user') Extends This class extends the Component class. Members _adapters Hash of registered adapters. Don't modify directly. Use Mapper#registerAdapter instead. Details Since Default value Source Tutorials 3.0.0 {} Mapper.js, line 122 Connecting to a data source _listeners Event listeners attached to this Component. Do not modify. Use Component#on and Component#off instead. Details Type Since Source Object 3.0.0 Component.js, line 7 Inherited From: Component#_listeners applySchema Whether to augment Mapper#recordClass with getter/setter property accessors according to the properties defined in Mapper#schema. This makes possible validation and change tracking on individual properties when using the dot (e.g. user.name = &quot;Bob&quot;) operator to modify a property. Details Type Since Default value Source Boolean 3.0.0 true Mapper.js, line 133 debug Whether to enable debug-level logs. Details Type Since Default value Source Boolean 3.0.0 false Mapper.js, line 147 defaultAdapter The name of the registered adapter that this Mapper should used by default. Details Type Since Default value Source Tutorials String 3.0.0 &quot;http&quot; Mapper.js, line 157 Connecting to a data source idAttribute The field used as the unique identifier on records handled by this Mapper. Details Type Since Default value Source String 3.0.0 id Mapper.js, line 168 lifecycleMethods The meta information describing this Mapper's available lifecycle methods. Do not modify. TODO: Improve documentation. Details Type Since Source Object 3.0.0 Mapper.js, line 321 name The name for this Mapper. This is the minimum amount of meta information required for a Mapper to be able to execute CRUD operations for a Resource. Details Type Since Source String 3.0.0 Mapper.js, line 354 notify Whether this Mapper should emit operational events. Details Type Since Default value Source Boolean 3.0.0 true Mapper.js, line 178 raw Whether Mapper#create, Mapper#createMany, Mapper#update, Mapper#updateAll, Mapper#updateMany, Mapper#find, Mapper#findAll, Mapper#destroy, Mapper#destroyAll, Mapper#count, and Mapper#sum should return a raw result object that contains both the instance data returned by the adapter and metadata about the operation. The default is to NOT return the result object, and instead return just the instance data. Details Type Since Default value Source Boolean 3.0.0 false Mapper.js, line 188 recordClass Set to false to force the Mapper to work with POJO objects only. Details Since Default value Source See 3.0.0 Record Mapper.js, line 268 Record Examples Use POJOs only. import {Mapper, Record} from 'js-data' const UserMapper = new Mapper({ recordClass: false }) UserMapper.recordClass // false const user = UserMapper#createRecord() user instanceof Record // false Set to a custom class to have records wrapped in your custom class. import {Mapper, Record} from 'js-data' // Custom class class User { constructor (props = {}) { for (var key in props) { if (props.hasOwnProperty(key)) { this[key] = props[key] } } } } const UserMapper = new Mapper({ recordClass: User }) UserMapper.recordClass // function User() {} const user = UserMapper#createRecord() user instanceof Record // false user instanceof User // true Extend the Record class. import {Mapper, Record} from 'js-data' // Custom class class User extends Record { constructor () { super(props) } } const UserMapper = new Mapper({ recordClass: User }) UserMapper.recordClass // function User() {} const user = UserMapper#createRecord() user instanceof Record // true user instanceof User // true schema This Mapper's Schema. Details Type Since Source See Schema 3.0.0 Mapper.js, line 335 Schema Methods &lt;static&gt; extend(props, classProps) Create a subclass of this Mapper. Method parameters: Name Type Argument Default Description props Object &lt;optional&gt; {} Properties to add to the prototype of the subclass. classProps Object &lt;optional&gt; {} Static properties to add to the subclass. Return value: Type Description Constructor Subclass of this Mapper class. Details Since Source 3.0.0 Mapper.js, line 1839 Examples Extend the class in a cross-browser manner. import {Mapper} from 'js-data' const CustomMapperClass = Mapper.extend({ foo () { return 'bar' } }) const customMapper = new CustomMapperClass({ name: 'test' }) console.log(customMapper.foo()) // &quot;bar&quot; Extend the class using ES2015 class syntax. class CustomMapperClass extends Mapper { foo () { return 'bar' } } const customMapper = new CustomMapperClass({ name: 'test' }) console.log(customMapper.foo()) // &quot;bar&quot; afterCount(query, opts, result) Mapper lifecycle hook called by Mapper#count. If this method returns a promise then Mapper#count will wait for the promise to resolve before continuing. Method parameters: Name Type Description query Object The query argument passed to Mapper#count. opts Object The opts argument passed to Mapper#count. result * The result, if any. Details Since Source 3.0.0 Mapper.js, line 404 afterCreate(props, opts, result) Mapper lifecycle hook called by Mapper#create. If this method returns a promise then Mapper#create will wait for the promise to resolve before continuing. Method parameters: Name Type Description props Object The props argument passed to Mapper#create. opts Object The opts argument passed to Mapper#create. result * The result, if any. Details Since Source 3.0.0 Mapper.js, line 417 afterCreateMany(records, opts, result) Mapper lifecycle hook called by Mapper#createMany. If this method returns a promise then Mapper#createMany will wait for the promise to resolve before continuing. Method parameters: Name Type Description records Array The records argument passed to Mapper#createMany. opts Object The opts argument passed to Mapper#createMany. result * The result, if any. Details Since Source 3.0.0 Mapper.js, line 430 afterDestroy(id, opts, result) Mapper lifecycle hook called by Mapper#destroy. If this method returns a promise then Mapper#destroy will wait for the promise to resolve before continuing. Method parameters: Name Type Description id String | Number The id argument passed to Mapper#destroy. opts Object The opts argument passed to Mapper#destroy. result * The result, if any. Details Since Source 3.0.0 Mapper.js, line 443 afterDestroyAll(data, query, opts, result) Mapper lifecycle hook called by Mapper#destroyAll. If this method returns a promise then Mapper#destroyAll will wait for the promise to resolve before continuing. Method parameters: Name Type Description data * The data returned by the adapter. query query The query argument passed to Mapper#destroyAll. opts Object The opts argument passed to Mapper#destroyAll. result * The result, if any. Details Since Source 3.0.0 Mapper.js, line 456 afterFind(id, opts, result) Mapper lifecycle hook called by Mapper#find. If this method returns a promise then Mapper#find will wait for the promise to resolve before continuing. Method parameters: Name Type Description id String | Number The id argument passed to Mapper#find. opts Object The opts argument passed to Mapper#find. result * The result, if any. Details Since Source 3.0.0 Mapper.js, line 470 afterFindAll(query, opts, result) Mapper lifecycle hook called by Mapper#findAll. If this method returns a promise then Mapper#findAll will wait for the promise to resolve before continuing. Method parameters: Name Type Description query Object The query argument passed to Mapper#findAll. opts Object The opts argument passed to Mapper#findAll. result * The result, if any. Details Since Source 3.0.0 Mapper.js, line 483 afterSum(query, opts, result) Mapper lifecycle hook called by Mapper#sum. If this method returns a promise then Mapper#sum will wait for the promise to resolve before continuing. Method parameters: Name Type Description query Object The query argument passed to Mapper#sum. opts Object The opts argument passed to Mapper#sum. result * The result, if any. Details Since Source 3.0.0 Mapper.js, line 496 afterUpdate(id, props, opts, result) Mapper lifecycle hook called by Mapper#update. If this method returns a promise then Mapper#update will wait for the promise to resolve before continuing. Method parameters: Name Type Description id String | Number The id argument passed to Mapper#update. props props The props argument passed to Mapper#update. opts Object The opts argument passed to Mapper#update. result * The result, if any. Details Since Source 3.0.0 Mapper.js, line 509 afterUpdateAll(props, query, opts, result) Mapper lifecycle hook called by Mapper#updateAll. If this method returns a promise then Mapper#updateAll will wait for the promise to resolve before continuing. Method parameters: Name Type Description props Object The props argument passed to Mapper#updateAll. query Object The query argument passed to Mapper#updateAll. opts Object The opts argument passed to Mapper#updateAll. result * The result, if any. Details Since Source 3.0.0 Mapper.js, line 523 afterUpdateMany(records, opts, result) Mapper lifecycle hook called by Mapper#updateMany. If this method returns a promise then Mapper#updateMany will wait for the promise to resolve before continuing. Method parameters: Name Type Description records Array The records argument passed to Mapper#updateMany. opts Object The opts argument passed to Mapper#updateMany. result * The result, if any. Details Since Source 3.0.0 Mapper.js, line 537 beforeCount(query, opts) Mapper lifecycle hook called by Mapper#count. If this method returns a promise then Mapper#count will wait for the promise to resolve before continuing. Method parameters: Name Type Description query Object The query argument passed to Mapper#count. opts Object The opts argument passed to Mapper#count. Details Since Source 3.0.0 Mapper.js, line 574 beforeCreate(props, opts) Mapper lifecycle hook called by Mapper#create. If this method returns a promise then Mapper#create will wait for the promise to resolve before continuing. Method parameters: Name Type Description props Object The props argument passed to Mapper#create. opts Object The opts argument passed to Mapper#create. Details Since Source 3.0.0 Mapper.js, line 550 beforeCreateMany(records, opts) Mapper lifecycle hook called by Mapper#createMany. If this method returns a promise then Mapper#createMany will wait for the promise to resolve before continuing. Method parameters: Name Type Description records Array The records argument passed to Mapper#createMany. opts Object The opts argument passed to Mapper#createMany. Details Since Source 3.0.0 Mapper.js, line 562 beforeDestroy(id, opts) Mapper lifecycle hook called by Mapper#destroy. If this method returns a promise then Mapper#destroy will wait for the promise to resolve before continuing. Method parameters: Name Type Description id String | Number The id argument passed to Mapper#destroy. opts Object The opts argument passed to Mapper#destroy. Details Since Source 3.0.0 Mapper.js, line 586 beforeDestroyAll(query, opts) Mapper lifecycle hook called by Mapper#destroyAll. If this method returns a promise then Mapper#destroyAll will wait for the promise to resolve before continuing. Method parameters: Name Type Description query query The query argument passed to Mapper#destroyAll. opts Object The opts argument passed to Mapper#destroyAll. Details Since Source 3.0.0 Mapper.js, line 598 beforeFind(id, opts) Mappers lifecycle hook called by Mapper#find. If this method returns a promise then Mapper#find will wait for the promise to resolve before continuing. Method parameters: Name Type Description id String | Number The id argument passed to Mapper#find. opts Object The opts argument passed to Mapper#find. Details Since Source 3.0.0 Mapper.js, line 610 beforeFindAll(query, opts) Mapper lifecycle hook called by Mapper#findAll. If this method returns a promise then Mapper#findAll will wait for the promise to resolve before continuing. Method parameters: Name Type Description query Object The query argument passed to Mapper#findAll. opts Object The opts argument passed to Mapper#findAll. Details Since Source 3.0.0 Mapper.js, line 622 beforeSum(field, query, opts) Mapper lifecycle hook called by Mapper#sum. If this method returns a promise then Mapper#sum will wait for the promise to resolve before continuing. Method parameters: Name Type Description field String The field argument passed to Mapper#sum. query Object The query argument passed to Mapper#sum. opts Object The opts argument passed to Mapper#sum. Details Since Source 3.0.0 Mapper.js, line 634 beforeUpdate(id, props, opts) Mapper lifecycle hook called by Mapper#update. If this method returns a promise then Mapper#update will wait for the promise to resolve before continuing. Method parameters: Name Type Description id String | Number The id argument passed to Mapper#update. props props The props argument passed to Mapper#update. opts Object The opts argument passed to Mapper#update. Details Since Source 3.0.0 Mapper.js, line 647 beforeUpdateAll(props, query, opts) Mapper lifecycle hook called by Mapper#updateAll. If this method returns a promise then Mapper#updateAll will wait for the promise to resolve before continuing. Method parameters: Name Type Description props Object The props argument passed to Mapper#updateAll. query Object The query argument passed to Mapper#updateAll. opts Object The opts argument passed to Mapper#updateAll. Details Since Source 3.0.0 Mapper.js, line 660 beforeUpdateMany(records, opts) Mapper lifecycle hook called by Mapper#updateMany. If this method returns a promise then Mapper#updateMany will wait for the promise to resolve before continuing. Method parameters: Name Type Description records Array The records argument passed to Mapper#updateMany. opts Object The opts argument passed to Mapper#updateMany. Details Since Source 3.0.0 Mapper.js, line 673 belongsTo() Define a belongsTo relationship. Only useful if you're managing your Mappers manually and not using a Container or DataStore component. Details Since Source See 3.0.0 Mapper.js, line 717 http://www.js-data.io/v3.0/docs/relations Example PostService.belongsTo(UserService, { // post.user_id points to user.id foreignKey: 'user_id' // user records will be attached to post records at &quot;post.user&quot; localField: 'user' }) CommentService.belongsTo(UserService, { // comment.user_id points to user.id foreignKey: 'user_id' // user records will be attached to comment records at &quot;comment.user&quot; localField: 'user' }) CommentService.belongsTo(PostService, { // comment.post_id points to post.id foreignKey: 'post_id' // post records will be attached to comment records at &quot;comment.post&quot; localField: 'post' }) count(query, opts) Select records according to the query argument and return the count. Mapper#beforeCount will be called before calling the adapter. Mapper#afterCount will be called after calling the adapter. Method parameters: Name Type Argument Default Description query Object &lt;optional&gt; {} Selection query. See query. Properties Name Type Argument Description where Object &lt;optional&gt; See query.where. offset Number &lt;optional&gt; See query.offset. limit Number &lt;optional&gt; See query.limit. orderBy String | Array.&lt;Array&gt; &lt;optional&gt; See query.orderBy. opts Object &lt;optional&gt; Configuration options. Refer to the count method of whatever adapter you're using for more configuration options. Properties Name Type Argument Default Description adapter Boolean &lt;optional&gt; Mapper#defaultAdapter Name of the adapter to use. notify Boolean &lt;optional&gt; Mapper#notify See Mapper#notify. raw Boolean &lt;optional&gt; Mapper#raw See Mapper#raw. Return value: Type Description Promise Resolves with the count of the selected records. Details Since Source 3.0.0 Mapper.js, line 750 Example Get the number of published blog posts PostService.count({ status: 'published' }).then((numPublished) =&gt; { console.log(numPublished) // e.g. 45 }) create(props, opts) Create and save a new the record using the provided props. Mapper#beforeCreate will be called before calling the adapter. Mapper#afterCreate will be called after calling the adapter. Method parameters: Name Type Argument Description props Object The properties for the new record. opts Object &lt;optional&gt; Configuration options. Refer to the create method of whatever adapter you're using for more configuration options. Properties Name Type Argument Default Description adapter Boolean &lt;optional&gt; Mapper#defaultAdapter Name of the adapter to use. notify Boolean &lt;optional&gt; Mapper#notify See Mapper#notify. raw Boolean &lt;optional&gt; Mapper#raw See Mapper#raw. with Array.&lt;String&gt; &lt;optional&gt; [] Relations to create in a cascading create if props contains nested relations. NOT performed in a transaction. Each nested create will result in another Mapper#create or Mapper#createMany call. pass Array.&lt;String&gt; &lt;optional&gt; [] Relations to send to the adapter as part of the payload. Normally relations are not sent. Return value: Type Description Promise Resolves with the created record. Details Since Source 3.0.0 Mapper.js, line 780 Example Create and save a new blog post PostService.create({ title: 'Modeling your data', status: 'draft' }).then((post) =&gt; { console.log(post) // { id: 1234, status: 'draft', ... } }) createInstance(props, opts) Use Mapper#createRecord instead. Method parameters: Name Type Argument Description props Object | Array See Mapper#createRecord. opts Object &lt;optional&gt; See Mapper#createRecord. Return value: Type Description Object | Array See Mapper#createRecord. Details Since Source See 3.0.0 Mapper.js, line 906 Mapper#createRecord Deprecated: Yes createMany(records, opts) Given an array of records, batch create them via an adapter. Mapper#beforeCreateMany will be called before calling the adapter. Mapper#afterCreateMany will be called after calling the adapter. Method parameters: Name Type Argument Description records Array.&lt;Record&gt; Array of records to be created in one batch. opts Object &lt;optional&gt; Configuration options. Refer to the createMany method of whatever adapter you're using for more configuration options. Properties Name Type Argument Default Description adapter Boolean &lt;optional&gt; Mapper#defaultAdapter Name of the adapter to use. notify Boolean &lt;optional&gt; Mapper#notify See Mapper#notify. raw Boolean &lt;optional&gt; Mapper#raw See Mapper#raw. with Array.&lt;String&gt; &lt;optional&gt; [] Relations to create in a cascading create if records contains nested relations. NOT performed in a transaction. Each nested create will result in another Mapper#createMany call. pass Array.&lt;String&gt; &lt;optional&gt; [] Relations to send to the adapter as part of the payload. Normally relations are not sent. Return value: Type Description Promise Resolves with the created records. Details Since Source Tutorials 3.0.0 Mapper.js, line 920 Saving data Example Create and save several new blog posts PostService.createMany([{ title: 'Modeling your data', status: 'draft' }, { title: 'Reading data', status: 'draft' }]).then((posts) =&gt; { console.log(posts[0]) // { id: 1234, status: 'draft', ... } console.log(posts[1]) // { id: 1235, status: 'draft', ... } }) createRecord(props, opts) Create an unsaved, uncached instance of this Mapper's Mapper#recordClass. Returns props if props is already an instance of Mapper#recordClass. Note: This method does not interact with any adapter, and does not save any data. It only creates new objects in memory. Method parameters: Name Type Argument Description props Object | Array.&lt;Object&gt; The properties for the Record instance or an array of property objects for the Record instances. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description noValidate Boolean &lt;optional&gt; false Whether to skip validation when the Record instances are created. Return value: Type Description Record | Array.&lt;Record&gt; The Record instance or Record instances. Details Since Source 3.0.0 Mapper.js, line 1049 Examples Create empty unsaved record instance const post = PostService.createRecord() Create an unsaved record instance with inital properties const post = PostService.createRecord({ title: 'Modeling your data', status: 'draft' }) Create a record instance that corresponds to a saved record const post = PostService.createRecord({ // JSData thinks this record has been saved if it has a primary key id: 1234, title: 'Modeling your data', status: 'draft' }) Create record instances from an array const posts = PostService.createRecord([{ title: 'Modeling your data', status: 'draft' }, { title: 'Reading data', status: 'draft' }]) Records are validated by default import {Mapper} from 'js-data' const PostService = new Mapper({ name: 'post', schema: { properties: { title: { type: 'string' } } } }) try { const post = PostService.createRecord({ title: 1234, }) } catch (err) { console.log(err.errors) // [{ expected: 'one of (string)', actual: 'number', path: 'title' }] } Skip validation import {Mapper} from 'js-data' const PostService = new Mapper({ name: 'post', schema: { properties: { title: { type: 'string' } } } }) const post = PostService.createRecord({ title: 1234, }, { noValidate: true }) console.log(post.isValid()) // false crud(method, args) Lifecycle invocation method. TODO: Improve documentation for this method. Method parameters: Name Type Argument Description method String Name of the lifecycle method to invoke. args * &lt;repeatable&gt; Arguments to pass to the lifecycle method. Return value: Type Description Promise Unspecified Details Since Source 3.0.0 Mapper.js, line 1143 dbg(args) Log the provided values at the &quot;debug&quot; level. Method parameters: Name Type Argument Description args * &lt;optional&gt; &lt;repeatable&gt; Values to log. Details Since Source 3.0.0 Component.js, line 32 Inherited From: Component#dbg destroy(id, opts) Using an adapter, destroy the record with the given primary key. Mapper#beforeDestroy will be called before destroying the record. Mapper#afterDestroy will be called after destroying the record. Method parameters: Name Type Argument Description id String | Number The primary key of the record to destroy. opts Object &lt;optional&gt; Configuration options. Refer to the destroy method of whatever adapter you're using for more configuration options. Properties Name Type Argument Default Description adapter Boolean &lt;optional&gt; Mapper#defaultAdapter Name of the adapter to use. notify Boolean &lt;optional&gt; Mapper#notify See Mapper#notify. raw Boolean &lt;optional&gt; Mapper#raw See Mapper#raw. Return value: Type Description Promise Resolves when the record has been destroyed. Resolves even if no record was found to be destroyed. Details Since Source Tutorials 3.0.0 Mapper.js, line 1203 Saving data Examples Destroy a specific blog post PostService.destroy(1234).then(() =&gt; { // Blog post #1234 has been destroyed }) Get full response PostService.destroy(1234, { raw: true }).then((result) =&gt; { console.log(result.deleted) e.g. 1 console.log(...) // etc., more metadata can be found on the result }) destroyAll(query, opts) Destroy the records selected by query via an adapter. If no query is provided then all records will be destroyed. Mapper#beforeDestroyAll will be called before destroying the records. Mapper#afterDestroyAll will be called after destroying the records. Method parameters: Name Type Argument Default Description query Object &lt;optional&gt; {} Selection query. See query. Properties Name Type Argument Description where Object &lt;optional&gt; See query.where. offset Number &lt;optional&gt; See query.offset. limit Number &lt;optional&gt; See query.limit. orderBy String | Array.&lt;Array&gt; &lt;optional&gt; See query.orderBy. opts Object &lt;optional&gt; Configuration options. Refer to the destroyAll method of whatever adapter you're using for more configuration options. Properties Name Type Argument Default Description adapter Boolean &lt;optional&gt; Mapper#defaultAdapter Name of the adapter to use. notify Boolean &lt;optional&gt; Mapper#notify See Mapper#notify. raw Boolean &lt;optional&gt; Mapper#raw See Mapper#raw. Return value: Type Description Promise Resolves when the records have been destroyed. Resolves even if no records were found to be destroyed. Details Since Source Tutorials See 3.0.0 Mapper.js, line 1237 Saving data query Examples Destroy all blog posts PostService.destroyAll().then(() =&gt; { // All blog posts have been destroyed }) Destroy all &quot;draft&quot; blog posts PostService.destroyAll({ status: 'draft' }).then(() =&gt; { // All &quot;draft&quot; blog posts have been destroyed }) Get full response const query = null const options = { raw: true } PostService.destroyAll(query, options).then((result) =&gt; { console.log(result.deleted) e.g. 14 console.log(...) // etc., more metadata can be found on the result }) emit(event, args) Trigger an event on this Component. Method parameters: Name Type Argument Description event String Name of event to emit. args * &lt;optional&gt; &lt;repeatable&gt; Arguments to pass to any listeners. Details Since Source 3.0.0 Component.js, line 98 Inherited From: Component#emit Examples collection.on('foo', (msg) =&gt; { console.log(msg) // &quot;bar&quot; }) collection.emit('foo', 'bar') store.on('foo', (msg, val1, val2) =&gt; { console.log(msg, val1, val2) // &quot;bar&quot; &quot;beep&quot; &quot;boop&quot; }) store.emit('foo', 'bar', 'beep', 'boop') find(id, opts) Retrieve via an adapter the record with the given primary key. Mapper#beforeFind will be called before calling the adapter. Mapper#afterFind will be called after calling the adapter. Method parameters: Name Type Argument Description id String | Number The primary key of the record to retrieve. opts Object &lt;optional&gt; Configuration options. Refer to the find method of whatever adapter you're using for more configuration options. Properties Name Type Argument Default Description adapter Boolean &lt;optional&gt; Mapper#defaultAdapter Name of the adapter to use. notify Boolean &lt;optional&gt; Mapper#notify See Mapper#notify. raw Boolean &lt;optional&gt; Mapper#raw See Mapper#raw. with Array.&lt;String&gt; &lt;optional&gt; [] Relations to eager load in the request. Return value: Type Description Promise Resolves with the found record. Resolves with undefined if no record was found. Details Since Source Tutorials See 3.0.0 Mapper.js, line 1284 Reading data http://www.js-data.io/v3.0/docs/reading-data Examples PostService.find(1).then((post) =&gt; { console.log(post) // { id: 1, ...} }) Get full response PostService.find(1, { raw: true }).then((result) =&gt; { console.log(result.data) // { id: 1, ...} console.log(result.found) // 1 console.log(...) // etc., more metadata can be found on the result }) findAll(query, opts) Using the query argument, select records to retrieve via an adapter. Mapper#beforeFindAll will be called before calling the adapter. Mapper#afterFindAll will be called after calling the adapter. Method parameters: Name Type Argument Default Description query Object &lt;optional&gt; {} Selection query. See query. Properties Name Type Argument Description where Object &lt;optional&gt; See query.where. offset Number &lt;optional&gt; See query.offset. limit Number &lt;optional&gt; See query.limit. orderBy String | Array.&lt;Array&gt; &lt;optional&gt; See query.orderBy. opts Object &lt;optional&gt; Configuration options. Refer to the findAll method of whatever adapter you're using for more configuration options. Properties Name Type Argument Default Description adapter Boolean &lt;optional&gt; Mapper#defaultAdapter Name of the adapter to use. notify Boolean &lt;optional&gt; Mapper#notify See Mapper#notify. raw Boolean &lt;optional&gt; Mapper#raw See Mapper#raw. with Array.&lt;String&gt; &lt;optional&gt; [] Relations to eager load in the request. Return value: Type Description Promise Resolves with the found records, if any. Details Since Source Tutorials See 3.0.0 Mapper.js, line 1321 Reading data query Examples Find all &quot;published&quot; blog posts PostService.findAll({ status: 'published' }).then((posts) =&gt; { console.log(posts) // [{ id: 1, status: 'published', ...}, ...] }) Get full response PostService.findAll({ status: 'published' }, { raw: true }).then((result) =&gt; { console.log(result.data) // [{ id: 1, status: 'published', ...}, ...] console.log(result.found) // e.g. 13 console.log(...) // etc., more metadata can be found on the result }) getAdapter(name) Return the registered adapter with the given name or the default adapter if no name is provided. Method parameters: Name Type Argument Description name String &lt;optional&gt; The name of the adapter to retrieve. Return value: Type Description Adapter The adapter. Details Since Source Tutorials 3.0.0 Mapper.js, line 1361 Connecting to a data source getAdapterName(opts) Return the name of a registered adapter based on the given name or options, or the name of the default adapter if no name provided. Method parameters: Name Type Argument Description opts Object | String &lt;optional&gt; The name of an adapter or options, if any. Return value: Type Description String The name of the adapter. Details Since Source Tutorials 3.0.0 Mapper.js, line 1380 Connecting to a data source getAdapters() Get the object of registered adapters for this Mapper. Return value: Type Description Object Mapper#_adapters Details Since Source Tutorials 3.0.0 Mapper.js, line 1398 Connecting to a data source getSchema() Returns this Mapper's Schema. Return value: Type Description Schema This Mapper's Schema. Details Since Source See 3.0.0 Mapper.js, line 1410 Mapper#schema hasMany() Defines a hasMany relationship. Only useful if you're managing your Mappers manually and not using a Container or DataStore component. Details Since Source See 3.0.0 Mapper.js, line 1422 http://www.js-data.io/v3.0/docs/relations Example UserService.hasMany(PostService, { // post.user_id points to user.id foreignKey: 'user_id' // post records will be attached to user records at &quot;user.posts&quot; localField: 'posts' }) hasOne() Defines a hasOne relationship. Only useful if you're managing your Mappers manually and not using a Container or DataStore component. Details Since Source See 3.0.0 Mapper.js, line 1442 http://www.js-data.io/v3.0/docs/relations Example UserService.hasOne(ProfileService, { // profile.user_id points to user.id foreignKey: 'user_id' // profile records will be attached to user records at &quot;user.profile&quot; localField: 'profile' }) is(record) Return whether record is an instance of this Mapper's recordClass. Method parameters: Name Type Description record Object | Record The record to check. Return value: Type Description Boolean Whether record is an instance of this Mapper's Mapper#recordClass. Details Since Source 3.0.0 Mapper.js, line 1462 Example const post = PostService.createRecord() console.log(PostService.is(post)) // true // Equivalent to what's above console.log(post instanceof PostService.recordClass) // true log(level, args) Log the provided values. By default sends values to console[level]. Method parameters: Name Type Argument Description level String Log level args * &lt;optional&gt; &lt;repeatable&gt; Values to log. Details Since Source 3.0.0 Component.js, line 39 Inherited From: Component#log off(event, listener) Remove an event listener from this Component. If no listener is provided, then all listeners for the specified event will be removed. If no event is specified then all listeners for all events will be removed. Method parameters: Name Type Argument Description event String &lt;optional&gt; Name of event to unsubsribe to. listener Function &lt;optional&gt; Listener to remove. Details Since Source 3.0.0 Component.js, line 79 Inherited From: Component#off Examples Remove a listener to a single event collection.off('add', handler) Remove all listeners to a single event record.off('change') Remove all listeners to all events store.off() on(event, listener, ctx) Register a new event listener on this Component. Method parameters: Name Type Argument Description event String Name of event to subsribe to. listener Function Listener function to handle the event. ctx * &lt;optional&gt; Optional content in which to invoke the listener. Details Since Source 3.0.0 Component.js, line 49 Inherited From: Component#on Examples Listen for all &quot;afterCreate&quot; events in a DataStore store.on('afterCreate', (mapperName, props, opts, result) =&gt; { console.log(mapperName) // &quot;post&quot; console.log(props.id) // undefined console.log(result.id) // 1234 }) store.create('post', { title: 'Modeling your data' }).then((post) =&gt; { console.log(post.id) // 1234 }) Listen for the &quot;add&quot; event on a collection collection.on('add', (records) =&gt; { console.log(records) // [...] }) Listen for &quot;change&quot; events on a record post.on('change', (record, changes) =&gt; { console.log(changes) // { changed: { title: 'Modeling your data' } } }) post.title = 'Modeling your data' registerAdapter(name, adapter, opts) Register an adapter on this Mapper under the given name. Method parameters: Name Type Argument Description name String The name of the adapter to register. adapter Adapter The adapter to register. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description default Boolean &lt;optional&gt; false Whether to make the adapter the default adapter for this Mapper. Details Since Source Tutorials 3.0.0 Mapper.js, line 1483 Connecting to a data source sum(field, query, opts) Select records according to the query argument, and aggregate the sum value of the property specified by field. Mapper#beforeSum will be called before calling the adapter. Mapper#afterSum will be called after calling the adapter. Method parameters: Name Type Argument Default Description field String The field to sum. query Object &lt;optional&gt; {} Selection query. See query. Properties Name Type Argument Description where Object &lt;optional&gt; See query.where. offset Number &lt;optional&gt; See query.offset. limit Number &lt;optional&gt; See query.limit. orderBy String | Array.&lt;Array&gt; &lt;optional&gt; See query.orderBy. opts Object &lt;optional&gt; Configuration options. Refer to the sum method of whatever adapter you're using for more configuration options. Properties Name Type Argument Default Description adapter Boolean &lt;optional&gt; Mapper#defaultAdapter Name of the adapter to use. notify Boolean &lt;optional&gt; Mapper#notify See Mapper#notify. raw Boolean &lt;optional&gt; Mapper#raw See Mapper#raw. Return value: Type Description Promise Resolves with the aggregated sum. Details Since Source 3.0.0 Mapper.js, line 1504 Example PurchaseOrderService.sum('amount', { status: 'paid' }).then((amountPaid) =&gt; { console.log(amountPaid) // e.g. 451125.34 }) toJSON(records, opts) Return a plain object representation of the given record. Relations can be optionally be included. Non-schema properties can be excluded. Method parameters: Name Type Argument Description records Record | Array.&lt;Record&gt; Record or records from which to create a POJO representation. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Description strict Boolean &lt;optional&gt; Whether to include properties that are not defined in Mapper#schema. with Array.&lt;String&gt; &lt;optional&gt; Array of relation names or relation fields to include in the POJO representation. withAll Boolean &lt;optional&gt; Whether to simply include all relations in the representation. Overrides opts.with. Return value: Type Description Object | Array.&lt;Object&gt; POJO representation of the record or records. Details Since Source 3.0.0 Mapper.js, line 1536 Example import {Mapper, Schema} from 'js-data' const PersonService = new Mapper({ name: 'person', schema: { properties: { name: { type: 'string' }, id: { type: 'string' } } } }) const person = PersonService.createRecord({ id: 1, name: 'John', foo: 'bar' }) console.log(PersonService.toJSON(person)) // {&quot;id&quot;:1,&quot;name&quot;:&quot;John&quot;,&quot;foo&quot;:&quot;bar&quot;} console.log(PersonService.toJSON(person), { strict: true }) // {&quot;id&quot;:1,&quot;name&quot;:&quot;John&quot;} update(id, props, opts) Using an adapter, update the record with the primary key specified by the id argument. Mapper#beforeUpdate will be called before updating the record. Mapper#afterUpdate will be called after updating the record. Method parameters: Name Type Argument Description id String | Number The primary key of the record to update. props Object The update to apply to the record. opts Object &lt;optional&gt; Configuration options. Refer to the update method of whatever adapter you're using for more configuration options. Properties Name Type Argument Default Description adapter Boolean &lt;optional&gt; Mapper#defaultAdapter Name of the adapter to use. notify Boolean &lt;optional&gt; Mapper#notify See Mapper#notify. raw Boolean &lt;optional&gt; Mapper#raw See Mapper#raw. transaction. Return value: Type Description Promise Resolves with the updated record. Rejects if the record could not be found. Details Since Source Tutorials 3.0.0 Mapper.js, line 1620 Saving data Example Update a specific post PostService.update(1234, { status: 'published', published_at: new Date() }).then((post) =&gt; { console.log(post) // { id: 1234, status: 'published', ... } }) updateAll(props, query, opts) Using the query argument, perform the a single updated to the selected records. Mapper#beforeUpdateAll will be called before making the update. Mapper#afterUpdateAll will be called after making the update. Method parameters: Name Type Argument Default Description props Object Update to apply to selected records. query Object &lt;optional&gt; {} Selection query. See query. Properties Name Type Argument Description where Object &lt;optional&gt; See query.where. offset Number &lt;optional&gt; See query.offset. limit Number &lt;optional&gt; See query.limit. orderBy String | Array.&lt;Array&gt; &lt;optional&gt; See query.orderBy. opts Object &lt;optional&gt; Configuration options. Refer to the updateAll method of whatever adapter you're using for more configuration options. Properties Name Type Argument Default Description adapter Boolean &lt;optional&gt; Mapper#defaultAdapter Name of the adapter to use. notify Boolean &lt;optional&gt; Mapper#notify See Mapper#notify. raw Boolean &lt;optional&gt; Mapper#raw See Mapper#raw. Return value: Type Description Promise Resolves with the update records, if any. Details Since Source Tutorials See 3.0.0 Mapper.js, line 1654 Saving data query Example Turn all of John's blog posts into drafts. const update = { status: draft: published_at: null } const query = { userId: 1234 } PostService.updateAll(update, query).then((posts) =&gt; { console.log(posts) // [...] }) updateMany(records, opts) Given an array of updates, perform each of the updates via an adapter. Each &quot;update&quot; is a hash of properties with which to update an record. Each update must contain the primary key of the record to be updated. Mapper#beforeUpdateMany will be called before making the update. Mapper#afterUpdateMany will be called after making the update. Method parameters: Name Type Argument Description records Array.&lt;Record&gt; Array up record updates. opts Object &lt;optional&gt; Configuration options. Refer to the updateMany method of whatever adapter you're using for more configuration options. Properties Name Type Argument Default Description adapter Boolean &lt;optional&gt; Mapper#defaultAdapter Name of the adapter to use. notify Boolean &lt;optional&gt; Mapper#notify See Mapper#notify. raw Boolean &lt;optional&gt; Mapper#raw See Mapper#raw. Return value: Type Description Promise Resolves with the updated records. Rejects if any of the records could be found. Details Since Source Tutorials 3.0.0 Mapper.js, line 1690 Saving data Example PostService.updateMany([ { id: 1234, status: 'draft' }, { id: 2468, status: 'published', published_at: new Date() } ]).then((posts) =&gt; { console.log(posts) // [...] }) validate(record, opts) Validate the given record or records according to this Mapper's Schema. If there are no validation errors then the return value will be undefined. Method parameters: Name Type Argument Description record Object | Array.&lt;Object&gt; The record or records to validate. opts Object &lt;optional&gt; Configuration options. Passed to Schema#validate. Return value: Type Description Array.&lt;Object&gt; Array of errors or undefined if no errors. Details Since Source 3.0.0 Mapper.js, line 1723 Example import {Mapper, Schema} from 'js-data' const PersonSchema = new Schema({ properties: { name: { type: 'string' }, id: { type: 'string' } } }) const PersonService = new Mapper({ name: 'person', schema: PersonSchema }) let errors = PersonService.validate({ name: 'John' }) console.log(errors) // undefined errors = PersonService.validate({ name: 123 }) console.log(errors) // [{ expected: 'one of (string)', actual: 'number', path: 'name' }] wrap(data, opts) Method used to wrap data returned by an adapter with this Mapper's Mapper#recordClass. This method is used by all of a Mapper's CRUD methods. The provided implementation of this method assumes that the data passed to it is a record or records that need to be wrapped with Mapper#createRecord. Override with care. Provided implementation of Mapper#wrap: function (data, opts) { return this.createRecord(data, opts) } Method parameters: Name Type Argument Description data Object | Array.&lt;Object&gt; The record or records to be wrapped. opts Object &lt;optional&gt; Configuration options. Passed to Mapper#createRecord. Return value: Type Description Record | Array.&lt;Record&gt; The wrapped record or records. Details Since Source 3.0.0 Mapper.js, line 1772 Example Override to customize behavior const PostMapper = new Mapper({ name: 'post', wrap (data, opts) { const originalWrap = this.constructor.prototype.wrap // Let's say &quot;GET /post&quot; doesn't return JSON quite like JSData expects, // but the actual post records are nested under a &quot;posts&quot; field. So, // we override Mapper#wrap to handle this special case. if (opts.op === 'findAll') { return originalWrap.call(this, data.posts, opts) } // Otherwise perform original behavior return originalWrap.call(this, data, opts) } }) × Search results Close api.js-data.io • js-data.io "},"module-js-data.html":{"id":"module-js-data.html","title":"Module: js-data","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentDataStoreLinkedCollectionMapperQueryRecordSchema Module: js-data Registered as js-data in NPM and Bower. Also available from CDN.JS and JSDelivr. Details Source index.js, line 1 Examples Install from NPM npm i --save js-data@beta Install from Bower bower i --save js-data@3.0.0-beta.1 Install from CDN.JS &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/js-data/3.0.0-beta.1/js-data.min.js&quot;&gt;&lt;/script&gt; Install from JSDelivr &lt;script src=&quot;https://cdn.jsdelivr.net/js-data/3.0.0-beta.1/js-data.min.js&quot;&gt;&lt;/script&gt; Load into your app via script tag &lt;script src=&quot;/path/to/js-data.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; console.log(JSData.version.full); // &quot;3.0.0-beta.1&quot; &lt;/script&gt; Load into your app via CommonJS var JSData = require('js-data'); Load into your app via ES2015 Modules import * as JSData from 'js-data'; Load into your app via AMD define('myApp', ['js-data'], function (JSData) { ... }) Members &lt;static&gt; Collection JSData's Collection class. Details Type Since Source Tutorials See Constructor 3.0.0 index.js, line 65 Components of JSData: Collection Collection Example import {Collection} from 'js-data' const collection = new Collection() &lt;static&gt; Component JSData's Component class. Most components in JSData extend this class. Details Type Since Source See Constructor 3.0.0 index.js, line 80 Component Example import {Component} from 'js-data' // Make a custom component. const MyComponent = Component.extend({ myMethod (someArg) { ... } }) &lt;static&gt; Container JSData's Container class. Defines and manages Mappers. Used in Node.js and in the browser, though in the browser you may want to use DataStore instead. Details Type Since Source Tutorials See Constructor 3.0.0 index.js, line 98 Components of JSData: Container Container Example import {Container} from 'js-data' const store = new Container() &lt;static&gt; DataStore JSData's DataStore class. Primarily for use in the browser. In Node.js you probably want to use Container instead. Details Type Since Source Tutorials See Constructor 3.0.0 index.js, line 115 Components of JSData: DataStore DataStore Example import {DataStore} from 'js-data' const store = new DataStore() &lt;static&gt; Index JSData's Index class, based on mindex. Details Type Since Source See Constructor 3.0.0 index.js, line 131 Index &lt;static&gt; LinkedCollection JSData's LinkedCollection class. Used by the DataStore component. If you need to create a collection manually, you should probably use the Collection class. Details Type Since Source See Constructor 3.0.0 index.js, line 141 DataStore LinkedCollection &lt;static&gt; Mapper JSData's Mapper class. The core of the ORM. Details Type Since Source Tutorials See Constructor 3.0.0 index.js, line 154 Modeling your data Components of JSData: Mapper Container Mapper Examples Recommended use import {Container} from 'js-data' const store = new Container() store.defineMapper('user') Create Mapper manually import {Mapper} from 'js-data' const UserMapper = new Mapper({ name: 'user' }) &lt;static&gt; Query JSData's Query class. Used by the Collection component. Details Type Since Source See Constructor 3.0.0 index.js, line 176 Query &lt;static&gt; Record JSData's Record class. Details Type Since Source Tutorials See Constructor 3.0.0 index.js, line 186 Components of JSData: Record Record Example import {Container} from 'js-data' const store = new Container() store.defineMapper('user') const user = store.createRecord('user') &lt;static&gt; Schema JSData's Schema class. Implements http://json-schema.org/draft-04. Details Type Since Source Tutorials See Constructor 3.0.0 index.js, line 203 Components of JSData: schema JSData's Schema Syntax Schema http://json-schema.org/ Example import {Container, Schema} from 'js-data' const userSchema = new Schema({ properties: { id: { type: 'string' }, name: { type: 'string' } } }) const store = new Container() store.defineMapper('user', { schema: userSchema }) &lt;static&gt; utils JSData's utility methods. Details Type Since Source See Object 3.0.0 index.js, line 50 utils Properties: Name Type Description Promise Function See utils.Promise. Example import {utils} from 'js-data' console.log(utils.isString('foo')) // true &lt;static&gt; version Describes the version of this JSData object. Details Type Since Source Object 2.0.0 index.js, line 29 Properties: Name Type Description full String The full semver value. major Number The major version number. minor Number The minor version number. patch Number The patch version number. alpha String | Boolean The alpha version value, otherwise false if the current version is not alpha. beta String | Boolean The beta version value, otherwise false if the current version is not beta. Example console.log(JSData.version.full) // &quot;3.0.0-beta.1&quot; Methods &lt;static&gt; belongsTo(related, opts) TODO Method parameters: Name Type Description related Mapper The relation the target belongs to. opts Object Configuration options. Properties Name Type Description foreignKey String The field that holds the primary key of the related record. localField String The field that holds a reference to the related record object. Return value: Type Description Function Invocation function, which accepts the target as the only parameter. Details Source decorators.js, line 4 &lt;static&gt; hasMany(related, opts) TODO Method parameters: Name Type Description related Mapper The relation of which the target has many. opts Object Configuration options. Properties Name Type Argument Description foreignKey String &lt;optional&gt; The field that holds the primary key of the related record. localField String The field that holds a reference to the related record object. Return value: Type Description Function Invocation function, which accepts the target as the only parameter. Details Source decorators.js, line 24 &lt;static&gt; hasOne(related, opts) TODO Method parameters: Name Type Description related Mapper The relation of which the target has one. opts Object Configuration options. Properties Name Type Argument Description foreignKey String &lt;optional&gt; The field that holds the primary key of the related record. localField String The field that holds a reference to the related record object. Return value: Type Description Function Invocation function, which accepts the target as the only parameter. Details Source decorators.js, line 44 × Search results Close api.js-data.io • js-data.io "},"Query.html":{"id":"Query.html","title":"Class: Query","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentDataStoreLinkedCollectionMapperQueryRecordSchema Class: Query Query new Query(collection) A class used by the Collection class to build queries to be executed against the collection's data. An instance of Query is returned by Collection#query. Query instances are typically short-lived, and you shouldn't have to create them yourself. Just use Collection#query. import {Query} from 'js-data' Method parameters: Name Type Description collection Collection The collection on which this query operates. Details Since Source 3.0.0 Query.js, line 25 Example const posts = store.query('post').filter({ status: 'draft' }).limit(2).run() Extends This class extends the Component class. Members &lt;static&gt; ops The filtering operators supported by Query#filter, and which are implemented by adapters (for the most part). Details Type Since Source Object 3.0.0 Query.js, line 680 Properties: Name Type Description == Function Equality operator. != Function Inequality operator. &gt; Function Greater than operator. &gt;= Function Greater than (inclusive) operator. &lt; Function Less than operator. Function Less than (inclusive) operator. isectEmpty Function Operator that asserts that the intersection between two arrays is empty. isectNotEmpty Function Operator that asserts that the intersection between two arrays is not empty. in Function Operator that asserts whether a value is in an array. notIn Function Operator that asserts whether a value is not in an array. contains Function Operator that asserts whether an array contains a value. notContains Function Operator that asserts whether an array does not contain a value. Examples Variant 1 const publishedPosts = store.filter('post', { status: 'published', limit: 2 }) Variant 2 const publishedPosts = store.filter('post', { where: { status: { '==': 'published' } }, limit: 2 }) Variant 3 const publishedPosts = store.query('post').filter({ status: 'published' }).limit(2).run() Variant 4 const publishedPosts = store.query('post').filter({ where: { status: { '==': 'published' } } }).limit(2).run() Multiple operators const myPublishedPosts = store.filter('post', { where: { status: { '==': 'published' }, user_id: { '==': currentUser.id } } }) _listeners Event listeners attached to this Component. Do not modify. Use Component#on and Component#off instead. Details Type Since Source Object 3.0.0 Component.js, line 7 Inherited From: Component#_listeners collection The Collection on which this query operates. Details Type Since Source Collection 3.0.0 Query.js, line 46 data The current data result of this query. Details Type Since Source Array 3.0.0 Query.js, line 55 Methods &lt;static&gt; extend(props, classProps) Create a subclass of this Query. Method parameters: Name Type Argument Default Description props Object &lt;optional&gt; {} Properties to add to the prototype of the subclass. classProps Object &lt;optional&gt; {} Static properties to add to the subclass. Return value: Type Description Constructor Subclass of this Query class. Details Since Source 3.0.0 Query.js, line 797 Examples Extend the class in a cross-browser manner. import {Query} from 'js-data' const CustomQueryClass = Query.extend({ foo () { return 'bar' } }) const customQuery = new CustomQueryClass({ name: 'test' }) console.log(customQuery.foo()) // &quot;bar&quot; Extend the class using ES2015 class syntax. class CustomQueryClass extends Query { foo () { return 'bar' } } const customQuery = new CustomQueryClass({ name: 'test' }) console.log(customQuery.foo()) // &quot;bar&quot; between(leftKeys, rightKeys, opts) Find all entities between two boundaries. Method parameters: Name Type Argument Description leftKeys Array Keys defining the left boundary. rightKeys Array Keys defining the right boundary. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description index String &lt;optional&gt; Name of the secondary index to use in the query. If no index is specified, the main index is used. leftInclusive Boolean &lt;optional&gt; true Whether to include entities on the left boundary. rightInclusive Boolean &lt;optional&gt; false Whether to include entities on the left boundary. limit Boolean &lt;optional&gt; Limit the result to a certain number. offset Boolean &lt;optional&gt; The number of resulting entities to skip. Return value: Type Description Query A reference to itself for chaining. Details Since Source 3.0.0 Query.js, line 149 Examples Get the users ages 18 to 30. const users = query.between(18, 30, { index: 'age' }).run() Same as above. const users = query.between([18], [30], { index: 'age' }).run() compare(orderBy, index, a, b) The comparison function used by the Query class. Method parameters: Name Type Description orderBy Array An orderBy clause used for sorting and sub-sorting. index Number The index of the current orderBy clause being used. a * The first item in the comparison. b * The second item in the comparison. Return value: Type Description Number -1 if b should preceed a. 0 if a and b are equal. 1 if a should preceed b. Details Since Source 3.0.0 Query.js, line 182 dbg(args) Log the provided values at the &quot;debug&quot; level. Method parameters: Name Type Argument Description args * &lt;optional&gt; &lt;repeatable&gt; Values to log. Details Since Source 3.0.0 Component.js, line 32 Inherited From: Component#dbg emit(event, args) Trigger an event on this Component. Method parameters: Name Type Argument Description event String Name of event to emit. args * &lt;optional&gt; &lt;repeatable&gt; Arguments to pass to any listeners. Details Since Source 3.0.0 Component.js, line 98 Inherited From: Component#emit Examples collection.on('foo', (msg) =&gt; { console.log(msg) // &quot;bar&quot; }) collection.emit('foo', 'bar') store.on('foo', (msg, val1, val2) =&gt; { console.log(msg, val1, val2) // &quot;bar&quot; &quot;beep&quot; &quot;boop&quot; }) store.emit('foo', 'bar', 'beep', 'boop') evaluate(value, op, predicate) Predicate evaluation function used by the Query class. Method parameters: Name Type Description value * The value to evaluate. op String The operator to use in this evaluation. predicate * The predicate to use in this evaluation. Return value: Type Description Boolean Whether the value passed the evaluation or not. Details Since Source 3.0.0 Query.js, line 228 filter(queryOrFn, thisArg) Find the record or records that match the provided query or are accepted by the provided filter function. Method parameters: Name Type Argument Default Description queryOrFn Object | Function &lt;optional&gt; {} Selection query or filter function. thisArg Function &lt;optional&gt; Context to which to bind queryOrFn if queryOrFn is a function. Return value: Type Description Query A reference to itself for chaining. Details Since Source 3.0.0 Query.js, line 250 Examples Get the draft posts created less than three months const posts = query.filter({ where: { status: { '==': 'draft' }, created_at_timestamp: { '&gt;=': (new Date().getTime() (1000 * 60 * 60 * 24 * 30 * 3)) // 3 months ago } } }).run() Use a custom filter function const posts = query.filter(function (post) { return post.isReady() }).run() forEach(forEachFn, thisArg) Iterate over all entities. Method parameters: Name Type Argument Description forEachFn Function Iteration function. thisArg * &lt;optional&gt; Context to which to bind forEachFn. Return value: Type Description Query A reference to itself for chaining. Details Since Source 3.0.0 Query.js, line 456 get(keyList, opts) Find the entity or entities that match the provided key. Method parameters: Name Type Argument Description keyList Array Key(s) defining the entity to retrieve. If keyList is not an array (i.e. for a single-value key), it will be wrapped in an array. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Description string String &lt;optional&gt; Name of the secondary index to use in the query. If no index is specified, the main index is used. Return value: Type Description Query A reference to itself for chaining. Details Since Source 3.0.0 Query.js, line 470 Examples Get the entity whose primary key is 25. const entities = query.get(25).run() Same as above. const entities = query.get([25]).run() Get all users who are active and have the &quot;admin&quot; role. const activeAdmins = query.get(['active', 'admin'], { index: 'activityAndRoles' }).run() Get all entities that match a certain weather condition. const niceDays = query.get(['sunny', 'humid', 'calm'], { index: 'weatherConditions' }).run() getAll(keyList, opts) Find the entity or entities that match the provided keyLists. Method parameters: Name Type Argument Description keyList Array &lt;optional&gt; &lt;repeatable&gt; Provide one or more keyLists, and all entities matching each keyList will be retrieved. If no keyLists are provided, all entities will be returned. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Description index String &lt;optional&gt; Name of the secondary index to use in the query. If no index is specified, the main index is used. Return value: Type Description Query A reference to itself for chaining. Details Since Source 3.0.0 Query.js, line 516 Examples Get the posts where &quot;status&quot; is &quot;draft&quot; or &quot;inReview&quot;. const posts = query.getAll('draft', 'inReview', { index: 'status' }).run() Same as above. const posts = query.getAll(['draft'], ['inReview'], { index: 'status' }).run() getData() Return the current data result of this query. Return value: Type Description Array The data in this query. Details Since Source 3.0.0 Query.js, line 556 like(pattern, flags) Implementation used by the like operator. Takes a pattern and flags and returns a RegExp instance that can test strings. Method parameters: Name Type Description pattern String Testing pattern. flags String Flags for the regular expression. Return value: Type Description RegExp Regular expression for testing strings. Details Since Source 3.0.0 Query.js, line 570 limit(num) Limit the result. Method parameters: Name Type Description num Number The maximum number of entities to keep in the result. Return value: Type Description Query A reference to itself for chaining. Details Since Source 3.0.0 Query.js, line 584 Example Get only the first 10 draft posts. const posts = query.get('draft', { index: 'status' }).limit(10).run() log(level, args) Log the provided values. By default sends values to console[level]. Method parameters: Name Type Argument Description level String Log level args * &lt;optional&gt; &lt;repeatable&gt; Values to log. Details Since Source 3.0.0 Component.js, line 39 Inherited From: Component#log map(mapFn, thisArg) Apply a mapping function to the result data. Method parameters: Name Type Argument Description mapFn Function Mapping function. thisArg * &lt;optional&gt; Context to which to bind mapFn. Return value: Type Description Query A reference to itself for chaining. Details Since Source 3.0.0 Query.js, line 604 Example const ages = UserCollection.query().map((user) =&gt; { return user.age }).run() mapCall(funcName) Return the result of calling the specified function on each item in this collection's main index. Method parameters: Name Type Description funcName String Name of function to call Return value: Type Description Query A reference to itself for chaining. Details Since Source 3.0.0 Query.js, line 623 Example const stringAges = UserCollection.query().mapCall('toString').run() off(event, listener) Remove an event listener from this Component. If no listener is provided, then all listeners for the specified event will be removed. If no event is specified then all listeners for all events will be removed. Method parameters: Name Type Argument Description event String &lt;optional&gt; Name of event to unsubsribe to. listener Function &lt;optional&gt; Listener to remove. Details Since Source 3.0.0 Component.js, line 79 Inherited From: Component#off Examples Remove a listener to a single event collection.off('add', handler) Remove all listeners to a single event record.off('change') Remove all listeners to all events store.off() on(event, listener, ctx) Register a new event listener on this Component. Method parameters: Name Type Argument Description event String Name of event to subsribe to. listener Function Listener function to handle the event. ctx * &lt;optional&gt; Optional content in which to invoke the listener. Details Since Source 3.0.0 Component.js, line 49 Inherited From: Component#on Examples Listen for all &quot;afterCreate&quot; events in a DataStore store.on('afterCreate', (mapperName, props, opts, result) =&gt; { console.log(mapperName) // &quot;post&quot; console.log(props.id) // undefined console.log(result.id) // 1234 }) store.create('post', { title: 'Modeling your data' }).then((post) =&gt; { console.log(post.id) // 1234 }) Listen for the &quot;add&quot; event on a collection collection.on('add', (records) =&gt; { console.log(records) // [...] }) Listen for &quot;change&quot; events on a record post.on('change', (record, changes) =&gt; { console.log(changes) // { changed: { title: 'Modeling your data' } } }) post.title = 'Modeling your data' run() Complete the execution of the query and return the resulting data. Return value: Type Description Array The result of executing this query. Details Since Source 3.0.0 Query.js, line 643 skip(num) Skip a number of results. Method parameters: Name Type Description num Number The number of entities to skip. Return value: Type Description Query A reference to itself for chaining. Details Since Source 3.0.0 Query.js, line 656 Example Get all but the first 10 draft posts. const posts = query.get('draft', { index: 'status' }).skip(10).run() × Search results Close api.js-data.io • js-data.io "},"query_.html":{"id":"query_.html","title":"Namespace: query","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentDataStoreLinkedCollectionMapperQueryRecordSchema Namespace: query query Selection query as defined by JSData's Query Syntax. Details Since Source Tutorials 3.0.0 Query.js, line 280 JSData's Query Syntax Properties: Name Type Argument Description limit Number &lt;optional&gt; See query.limit. offset Number &lt;optional&gt; See query.offset. orderBy String | Array.&lt;Array&gt; &lt;optional&gt; See query.orderBy. skip Number &lt;optional&gt; Alias for query.offset. sort String | Array.&lt;Array&gt; &lt;optional&gt; Alias for query.orderBy. where Object &lt;optional&gt; See query.where. Examples Empty &quot;findAll&quot; query store.findAll('post').then((posts) =&gt; { console.log(posts) // [...] }) Empty &quot;filter&quot; query const posts = store.filter('post') console.log(posts) // [...] Complex &quot;findAll&quot; query const PAGE_SIZE = 10 let currentPage = 3 // Retrieve a filtered page of blog posts store.findAll('post', { where: { status: { // WHERE status = 'published' '==': 'published' }, author: { // AND author IN ('bob', 'alice') 'in': ['bob', 'alice'], // OR author IN ('karen') '|in': ['karen'] } }, orderBy: [ // ORDER BY date_published DESC, ['date_published', 'DESC'], // ORDER BY title ASC ['title', 'ASC'] ], // LIMIT 10 limit: PAGE_SIZE, // SKIP 20 offset: PAGE_SIZE * (currentPage 1) }).then((posts) =&gt; { console.log(posts) // [...] }) Members &lt;static&gt; limit Maximum number of records to retrieve. Details Type Since Source See Number 3.0.0 Query.js, line 431 http://www.js-data.io/v3.0/docs/query-syntax Example Retrieve the first &quot;page&quot; of blog posts const PAGE_SIZE = 10 let currentPage = 1 PostService.findAll({ offset: PAGE_SIZE * (currentPage 1) limit: PAGE_SIZE }) &lt;static&gt; offset Number of records to skip. Details Type Since Source See Number 3.0.0 Query.js, line 409 http://www.js-data.io/v3.0/docs/query-syntax Example Retrieve the first &quot;page&quot; of blog posts const PAGE_SIZE = 10 let currentPage = 1 PostService.findAll({ offset: PAGE_SIZE * (currentPage 1) limit: PAGE_SIZE }) &lt;static&gt; orderBy Determines how records should be ordered in the result. Details Type Since Source See String | Array.&lt;Array&gt; 3.0.0 Query.js, line 388 http://www.js-data.io/v3.0/docs/query-syntax Example TODO &lt;static&gt; where Filtering criteria. Records that do not meet this criteria will be exluded from the result. Details Type Since Source See Object 3.0.0 Query.js, line 341 http://www.js-data.io/v3.0/docs/query-syntax Example TODO × Search results Close api.js-data.io • js-data.io "},"Record.html":{"id":"Record.html","title":"Class: Record","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentDataStoreLinkedCollectionMapperQueryRecordSchema Class: Record Record new Record(props, opts) js-data's Record class. import {Record} from 'js-data' Method parameters: Name Type Argument Description props Object &lt;optional&gt; The initial properties of the new Record instance. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description noValidate Boolean &lt;optional&gt; false Whether to skip validation on the initial properties. Details Since Source 3.0.0 Record.js, line 16 Extends This class extends the Component class. Members _listeners Event listeners attached to this Component. Do not modify. Use Component#on and Component#off instead. Details Type Since Source Object 3.0.0 Component.js, line 7 Inherited From: Component#_listeners Methods &lt;static&gt; extend(props, classProps) Create a subclass of this Record. Method parameters: Name Type Argument Default Description props Object &lt;optional&gt; {} Properties to add to the prototype of the subclass. classProps Object &lt;optional&gt; {} Static properties to add to the subclass. Return value: Type Description Constructor Subclass of this Record class. Details Since Source 3.0.0 Record.js, line 441 Examples Extend the class in a cross-browser manner. import {Record} from 'js-data' const CustomRecordClass = Record.extend({ foo () { return 'bar' } }) const customRecord = new CustomRecordClass() console.log(customRecord.foo()) // &quot;bar&quot; Extend the class using ES2015 class syntax. class CustomRecordClass extends Record { foo () { return 'bar' } } const customRecord = new CustomRecordClass() console.log(customRecord.foo()) // &quot;bar&quot; afterLoadRelations(relations, opts) Lifecycle hook. Method parameters: Name Type Description relations Array.&lt;String&gt; The relations argument passed to Record#loadRelations. opts Object The opts argument passed to Record#loadRelations. Details Since Source 3.0.0 Record.js, line 72 beforeLoadRelations(relations, opts) Lifecycle hook. Method parameters: Name Type Description relations Array.&lt;String&gt; The relations argument passed to Record#loadRelations. opts Object The opts argument passed to Record#loadRelations. Details Since Source 3.0.0 Record.js, line 82 changes(opts) Return changes to this record since it was instantiated or Record#commit was called. Method parameters: Name Type Argument Description opts &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description equalsFn Function &lt;optional&gt; utils.deepEqual Equality function. ignore Array &lt;optional&gt; [] Array of strings or RegExp of fields to ignore. Return value: Type Description Object Object describing the changes to this record since it was instantiated or its Record#commit method was last called. Details Since Source 3.0.0 Record.js, line 92 commit() Make the record's current in-memory state it's only state, with any previous property values being set to current values. Details Since Source 3.0.0 Record.js, line 109 dbg(args) Log the provided values at the &quot;debug&quot; level. Method parameters: Name Type Argument Description args * &lt;optional&gt; &lt;repeatable&gt; Values to log. Details Since Source 3.0.0 Component.js, line 32 Inherited From: Component#dbg destroy(opts) Call Mapper#destroy using this record's primary key. Method parameters: Name Type Argument Description opts Object &lt;optional&gt; Configuration options passed to Mapper#destroy. Return value: Type Description Promise The result of calling Mapper#destroy with the primary key of this record. Details Since Source 3.0.0 Record.js, line 121 emit(event, args) Trigger an event on this Component. Method parameters: Name Type Argument Description event String Name of event to emit. args * &lt;optional&gt; &lt;repeatable&gt; Arguments to pass to any listeners. Details Since Source 3.0.0 Component.js, line 98 Inherited From: Component#emit Examples collection.on('foo', (msg) =&gt; { console.log(msg) // &quot;bar&quot; }) collection.emit('foo', 'bar') store.on('foo', (msg, val1, val2) =&gt; { console.log(msg, val1, val2) // &quot;bar&quot; &quot;beep&quot; &quot;boop&quot; }) store.emit('foo', 'bar', 'beep', 'boop') get(key) Return the value at the given path for this instance. Method parameters: Name Type Description key String Path of value to retrieve. Return value: Type Description * Value at path. Details Since Source 3.0.0 Record.js, line 136 hasChanges(opts) Return whether this record has changed since it was instantiated or Record#commit was called. Method parameters: Name Type Argument Description opts &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description equalsFn Function &lt;optional&gt; utils.deepEqual Equality function. ignore Array &lt;optional&gt; [] Array of strings or RegExp of fields to ignore. Return value: Type Description Boolean Return whether the record has changed since it was instantiated or since its Record#commit method was called. Details Since Source 3.0.0 Record.js, line 148 isValid(opts) Return whether the record in its current state passes validation. Method parameters: Name Type Argument Description opts Object &lt;optional&gt; Configuration options. Passed to Mapper#validate. Return value: Type Description Boolean Whether the record in its current state passes validation. Details Since Source 3.0.0 Record.js, line 165 loadRelations(relations, opts) Lazy load relations of this record, to be attached to the record once their loaded. Method parameters: Name Type Argument Description relations Array.&lt;String&gt; &lt;optional&gt; List of relations to load. opts Object &lt;optional&gt; Configuration options. Return value: Type Description Promise Resolves with the record, with the loaded relations now attached. Details Since Source 3.0.0 Record.js, line 178 log(level, args) Log the provided values. By default sends values to console[level]. Method parameters: Name Type Argument Description level String Log level args * &lt;optional&gt; &lt;repeatable&gt; Values to log. Details Since Source 3.0.0 Component.js, line 39 Inherited From: Component#log off(event, listener) Remove an event listener from this Component. If no listener is provided, then all listeners for the specified event will be removed. If no event is specified then all listeners for all events will be removed. Method parameters: Name Type Argument Description event String &lt;optional&gt; Name of event to unsubsribe to. listener Function &lt;optional&gt; Listener to remove. Details Since Source 3.0.0 Component.js, line 79 Inherited From: Component#off Examples Remove a listener to a single event collection.off('add', handler) Remove all listeners to a single event record.off('change') Remove all listeners to all events store.off() on(event, listener, ctx) Register a new event listener on this Component. Method parameters: Name Type Argument Description event String Name of event to subsribe to. listener Function Listener function to handle the event. ctx * &lt;optional&gt; Optional content in which to invoke the listener. Details Since Source 3.0.0 Component.js, line 49 Inherited From: Component#on Examples Listen for all &quot;afterCreate&quot; events in a DataStore store.on('afterCreate', (mapperName, props, opts, result) =&gt; { console.log(mapperName) // &quot;post&quot; console.log(props.id) // undefined console.log(result.id) // 1234 }) store.create('post', { title: 'Modeling your data' }).then((post) =&gt; { console.log(post.id) // 1234 }) Listen for the &quot;add&quot; event on a collection collection.on('add', (records) =&gt; { console.log(records) // [...] }) Listen for &quot;change&quot; events on a record post.on('change', (record, changes) =&gt; { console.log(changes) // { changed: { title: 'Modeling your data' } } }) post.title = 'Modeling your data' previous(key) Return the properties with which this record was instantiated. Method parameters: Name Type Argument Description key String &lt;optional&gt; If specified, return just the initial value of the given key. Return value: Type Description Object The initial properties of this record. Details Since Source 3.0.0 Record.js, line 266 revert(opts) Revert changes to this record back to the properties it had when it was instantiated. Method parameters: Name Type Argument Description opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Description preserve Array.&lt;String&gt; &lt;optional&gt; Array of strings or Regular Expressions denoting properties that should not be reverted. Details Since Source 3.0.0 Record.js, line 282 save(opts) Delegates to Mapper#create or Mapper#update. Method parameters: Name Type Argument Description opts Object &lt;optional&gt; Configuration options. See Mapper#create and Mapper#update. Properties Name Type Argument Description changesOnly Boolean &lt;optional&gt; Equality function. Default uses ===. equalsFn Function &lt;optional&gt; Passed to Record#changes when opts.changesOnly is true. ignore Array &lt;optional&gt; Passed to Record#changes when opts.changesOnly is true. Return value: Type Description Promise The result of calling Mapper#create or Mapper#update. Details Since Source 3.0.0 Record.js, line 309 set(key, value, opts) Set the value for a given key, or the values for the given keys if &quot;key&quot; is an object. Method parameters: Name Type Argument Description key String | Object Key to set or hash of key-value pairs to set. value * &lt;optional&gt; Value to set for the given key. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description silent Boolean &lt;optional&gt; false Whether to trigger change events. Details Since Source 3.0.0 Record.js, line 348 toJSON(opts) Return a plain object representation of this record. If the class from which this record was created has a Mapper, then Mapper#toJSON will be called with this record instead. Method parameters: Name Type Argument Description opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Description with Array.&lt;String&gt; &lt;optional&gt; Array of relation names or relation fields to include in the representation. Only available as an option if the class from which this record was created has a Mapper and this record resides in an instance of DataStore. Return value: Type Description Object Plain object representation of this record. Details Since Source 3.0.0 Record.js, line 373 unset(key, opts) Unset the value for a given key. Method parameters: Name Type Argument Description key String Key to unset. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description silent Boolean &lt;optional&gt; false Whether to trigger change events. Details Since Source 3.0.0 Record.js, line 400 validate(opts) Validate this record based on its current properties. Method parameters: Name Type Argument Description opts Object &lt;optional&gt; Configuration options. Passed to Mapper#validate. Return value: Type Description * Array of errors or undefined if no errors. Details Since Source 3.0.0 Record.js, line 413 × Search results Close api.js-data.io • js-data.io "},"Schema.html":{"id":"Schema.html","title":"Class: Schema","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentDataStoreLinkedCollectionMapperQueryRecordSchema Class: Schema Schema new Schema(definition) js-data's Schema class. import {Schema} from 'js-data' Method parameters: Name Type Description definition Object Schema definition according to json-schema.org Details Source Schema.js, line 994 Extends This class extends the Component class. Members &lt;static&gt; typeGroupValidators A map of validation functions grouped by type. Details Type Source Object Schema.js, line 874 &lt;static&gt; types A function map for each of the seven primitive JSON types defined by the core specification. Each function will check a given value and return true or false if the value is an instance of that type. types.integer(1) // returns true types.string({}) // returns falsehttp://json-schema.org/latest/json-schema-core.html#anchor8 Details Type Source Object Schema.js, line 6 &lt;static&gt; validationKeywords A map of all object member validation functions for each keyword defined in the JSON Schema. Details Type Source Object Schema.js, line 96 _listeners Event listeners attached to this Component. Do not modify. Use Component#on and Component#off instead. Details Type Since Source Object 3.0.0 Component.js, line 7 Inherited From: Component#_listeners Methods &lt;static&gt; validate(value, schema, opts) Validates the provided value against a given Schema according to the http://json-schema.org/ v4 specification. Method parameters: Name Type Argument Description value * Value to be validated. schema Object &lt;optional&gt; Valid Schema according to the http://json-schema.org/ v4 specification. opts Object &lt;optional&gt; Configuration options. Return value: Type Description Array | undefined Array of errors or undefined if valid. Details Source Schema.js, line 672 dbg(args) Log the provided values at the &quot;debug&quot; level. Method parameters: Name Type Argument Description args * &lt;optional&gt; &lt;repeatable&gt; Values to log. Details Since Source 3.0.0 Component.js, line 32 Inherited From: Component#dbg emit(event, args) Trigger an event on this Component. Method parameters: Name Type Argument Description event String Name of event to emit. args * &lt;optional&gt; &lt;repeatable&gt; Arguments to pass to any listeners. Details Since Source 3.0.0 Component.js, line 98 Inherited From: Component#emit Examples collection.on('foo', (msg) =&gt; { console.log(msg) // &quot;bar&quot; }) collection.emit('foo', 'bar') store.on('foo', (msg, val1, val2) =&gt; { console.log(msg, val1, val2) // &quot;bar&quot; &quot;beep&quot; &quot;boop&quot; }) store.emit('foo', 'bar', 'beep', 'boop') log(level, args) Log the provided values. By default sends values to console[level]. Method parameters: Name Type Argument Description level String Log level args * &lt;optional&gt; &lt;repeatable&gt; Values to log. Details Since Source 3.0.0 Component.js, line 39 Inherited From: Component#log off(event, listener) Remove an event listener from this Component. If no listener is provided, then all listeners for the specified event will be removed. If no event is specified then all listeners for all events will be removed. Method parameters: Name Type Argument Description event String &lt;optional&gt; Name of event to unsubsribe to. listener Function &lt;optional&gt; Listener to remove. Details Since Source 3.0.0 Component.js, line 79 Inherited From: Component#off Examples Remove a listener to a single event collection.off('add', handler) Remove all listeners to a single event record.off('change') Remove all listeners to all events store.off() on(event, listener, ctx) Register a new event listener on this Component. Method parameters: Name Type Argument Description event String Name of event to subsribe to. listener Function Listener function to handle the event. ctx * &lt;optional&gt; Optional content in which to invoke the listener. Details Since Source 3.0.0 Component.js, line 49 Inherited From: Component#on Examples Listen for all &quot;afterCreate&quot; events in a DataStore store.on('afterCreate', (mapperName, props, opts, result) =&gt; { console.log(mapperName) // &quot;post&quot; console.log(props.id) // undefined console.log(result.id) // 1234 }) store.create('post', { title: 'Modeling your data' }).then((post) =&gt; { console.log(post.id) // 1234 }) Listen for the &quot;add&quot; event on a collection collection.on('add', (records) =&gt; { console.log(records) // [...] }) Listen for &quot;change&quot; events on a record post.on('change', (record, changes) =&gt; { console.log(changes) // { changed: { title: 'Modeling your data' } } }) post.title = 'Modeling your data' validate(value, opts) Validate the provided value against this schema. Method parameters: Name Type Argument Description value * Value to validate. opts Object &lt;optional&gt; Configuration options. Return value: Type Description Array | undefined Array of errors or undefined if valid. Details Source Schema.js, line 1047 validate(target) This adds ES5 getters/setters to the target based on the &quot;properties&quot; in this Schema, which makes possible change tracking and validation on property assignment. Method parameters: Name Type Description target Object The prototype to which to apply this schema. Details Source Schema.js, line 1023 × Search results Close api.js-data.io • js-data.io "},"utils.html":{"id":"utils.html","title":"Namespace: utils","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentDataStoreLinkedCollectionMapperQueryRecordSchema Namespace: utils utils Utility methods used by JSData. Details Type Source Object utils.js, line 1 Example import {utils} from 'js-data' console.log(utils.isString('foo')) // true Members &lt;static&gt; Promise Reference to the Promise constructor used by JSData. Defaults to window.Promise or global.Promise. Details Type Since Source Function 3.0.0 utils.js, line 68 Example Make JSData use a different `Promise` constructor import Promise from 'bluebird' import {utils} from 'js-data' utils.Promise = Promise Methods &lt;static&gt; addHiddenPropsToTarget(target, props) Define hidden (non-enumerable), writable properties on target from the provided props. Method parameters: Name Type Description target Object That to which props should be added. props Object Properties to be added to target. Details Since Source 3.0.0 utils.js, line 175 Example import {utils} from 'js-data' function Cat () {} utils.addHiddenPropsToTarget(Cat.prototype, { say () { console.log('meow') } }) const cat = new Cat() cat.say() // &quot;meow&quot; &lt;static&gt; areDifferent(a, b, opts) Return whether the two objects are deeply different. Method parameters: Name Type Argument Description a Object Base object. b Object Comparison object. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description equalsFn Function &lt;optional&gt; utils.deepEqual Equality function. ignore Array &lt;optional&gt; [] Array of strings or RegExp of fields to ignore. Return value: Type Description Boolean Whether the two objects are deeply different. Details Since Source See 3.0.0 utils.js, line 206 utils.diffObjects Example import {utils} from 'js-data' utils.areDifferent({}, {}) // false utils.areDifferent({ a: 1 }, { a: 1 }) // false utils.areDifferent({ foo: 'bar' }, {}) // true &lt;static&gt; classCallCheck(instance, ctor) Verified that the given constructor is being invoked via new, as opposed to just being called like a normal function. Method parameters: Name Type Description instance * Instance that is being constructed. ctor Constructor Constructor function used to construct the instance. Throws: Throws an error if the constructor is being improperly invoked. Type Error Details Since Source 3.0.0 utils.js, line 234 Example import {utils} from 'js-data' function Cat () { utils.classCallCheck(this, Cat) } const cat = new Cat() // this is ok Cat() // this throws an error &lt;static&gt; copy(from, to, stackFrom, stackTo, blacklist, plain) Deep copy a value. Method parameters: Name Type Argument Description from * Value to deep copy. to * &lt;optional&gt; Destination object for the copy operation. stackFrom * &lt;optional&gt; For internal use. stackTo * &lt;optional&gt; For internal use. blacklist Array.&lt;String&gt; | Array.&lt;RegExp&gt; &lt;optional&gt; List of strings or RegExp of properties to skip. plain Boolean &lt;optional&gt; Whether to make a plain copy (don't try to use original prototype). Return value: Type Description * Deep copy of from. Details Since Source 3.0.0 utils.js, line 281 Example import {utils} from 'js-data' const a = { foo: { bar: 'baz' } } const b = utils.copy(a) a === b // false utils.areDifferent(a, b) // false &lt;static&gt; deepEqual(a, b) Check whether the two provided objects are deeply equal. Method parameters: Name Type Description a Object First object in the comparison. b Object Second object in the comparison. Return value: Type Description Boolean Whether the two provided objects are deeply equal. Details Since Source See 3.0.0 utils.js, line 1194 utils.equal &lt;static&gt; deepFillIn(dest, source) Recursively shallow fill in own enumerable properties from source to dest. Method parameters: Name Type Description dest Object The destination object. source Object The source object. Details Since Source See 3.0.0 utils.js, line 356 utils.fillIn utils.deepMixIn Example import {utils} from 'js-data' const a = { foo: { bar: 'baz' }, beep: 'boop' } const b = { beep: 'bip' } utils.deepFillIn(b, a) console.log(b) // {&quot;foo&quot;:{&quot;bar&quot;:&quot;baz&quot;},&quot;beep&quot;:&quot;bip&quot;} &lt;static&gt; deepMixIn(dest, source) Recursively shallow copy own enumerable properties from source to dest. Method parameters: Name Type Description dest Object The destination object. source Object The source object. Details Since Source See 3.0.0 utils.js, line 388 utils.fillIn utils.deepFillIn Example import {utils} from 'js-data' const a = { foo: { bar: 'baz' }, beep: 'boop' } const b = { beep: 'bip' } utils.deepFillIn(b, a) console.log(b) // {&quot;foo&quot;:{&quot;bar&quot;:&quot;baz&quot;},&quot;beep&quot;:&quot;boop&quot;} &lt;static&gt; diffObjects(newObject, oldObject, opts) Return a diff of the base object to the comparison object. Method parameters: Name Type Argument Description newObject Object Comparison object. oldObject Object Base object. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description equalsFn Function &lt;optional&gt; utils.deepEqual Equality function. ignore Array &lt;optional&gt; [] Array of strings or RegExp of fields to ignore. Return value: Type Description Object The diff from the base object to the comparison object. Details Since Source See 3.0.0 utils.js, line 419 utils.areDifferent Example import {utils} from 'js-data' const oldObject = { foo: 'bar', a: 1234 } const newObject = { beep: 'boop', a: 5678 } const diff = utils.diffObjects(oldObject, newObject) console.log(diff.added) // {&quot;beep&quot;:&quot;boop&quot;} console.log(diff.changed) // {&quot;a&quot;:5678} console.log(diff.removed) // {&quot;foo&quot;:undefined} &lt;static&gt; equal(a, b) Return whether the two values are equal according to the == operator. Method parameters: Name Type Description a * First value in the comparison. b * Second value in the comparison. Return value: Type Description Boolean Whether the two values are equal according to ==. Details Since Source 3.0.0 utils.js, line 487 &lt;static&gt; err(domain, target) Produce a factory function for making Error objects with the provided metadata. Used throughout the various js-data components. Method parameters: Name Type Description domain String Namespace. target String Target. Return value: Type Description Function Factory function. Details Since Source 3.0.0 utils.js, line 500 &lt;static&gt; eventify(target, getter, setter) Add eventing capabilities into the target object. Method parameters: Name Type Argument Description target Object Target object. getter Function &lt;optional&gt; Custom getter for retrieving the object's event listeners. setter Function &lt;optional&gt; Custom setter for setting the object's event listeners. Details Since Source 3.0.0 utils.js, line 519 &lt;static&gt; extend(props, props) Used for sublcassing. Invoke this method in the context of a superclass to to produce a subclass based on props and classProps. Method parameters: Name Type Description props Object Instance properties for the subclass. Properties Name Type Argument Description constructor Object &lt;optional&gt; Provide a custom constructor function to use as the subclass. props Object Static properties for the subclass. Return value: Type Description Constructor A new subclass. Details Since Source 3.0.0 utils.js, line 588 Example import {utils} from 'js-data' function Animal () {} Animal.extend = utils.extend const Cat = Animal.extend({ say () { console.log('meow') } }) const cat = new Cat() cat instanceof Animal // true cat instanceof Cat // true cat.say() // &quot;meow&quot; &lt;static&gt; fillIn(dest, source) Shallow copy own enumerable properties from src to dest that are on src but are missing from `dest. Method parameters: Name Type Description dest Object The destination object. source Object The source object. Details Since Source See 3.0.0 utils.js, line 665 utils.deepFillIn utils.deepMixIn Example import {utils} from 'js-data' const a = { foo: 'bar', beep: 'boop' } const b = { beep: 'bip' } utils.fillIn(b, a) console.log(b) // {&quot;foo&quot;:&quot;bar&quot;,&quot;beep&quot;:&quot;bip&quot;} &lt;static&gt; findIndex(array, fn) Find the last index of something according to the given checker function. Method parameters: Name Type Description array Array The array to search. fn Function Checker function. Return value: Type Description Number Index if found or -1 if not found. Details Since Source 3.0.0 utils.js, line 691 &lt;static&gt; forEachRelation(mapper, opts, fn, thisArg) Recursively iterate over a Mapper's relations according to opts.with. Method parameters: Name Type Description mapper Mapper Mapper. opts Object Configuration options. fn Function Callback function. thisArg * Execution context for the callback function. Details Since Source 3.0.0 utils.js, line 714 &lt;static&gt; forOwn(object, fn, thisArg) Iterate over an object's own enumerable properties. Method parameters: Name Type Argument Description object Object The object whose properties are to be enumerated. fn Function Iteration function. thisArg Object &lt;optional&gt; Content to which to bind fn. Details Since Source 3.0.0 utils.js, line 735 Example import {utils} from 'js-data' const a = { b: 1, c: 4 } let sum = 0 utils.forOwn(a, function (value, key) { sum += value }) console.log(sum) // 5 &lt;static&gt; fromJson(json) Proxy for JSON.parse. Method parameters: Name Type Description json String JSON to parse. Return value: Type Description Object Parsed object. Details Since Source See 3.0.0 utils.js, line 762 utils.toJson &lt;static&gt; get(object, prop) Retrieve the specified property from the given object. Supports retrieving nested properties. Method parameters: Name Type Description object Object Object from which to retrieve a property's value. prop String Property to retrieve. Return value: Type Description * Value of the specified property. Details Since Source See 3.0.0 utils.js, line 775 utils.set Example import {utils} from 'js-data' const a = { foo: { bar: 'baz' }, beep: 'boop' } console.log(utils.get(a, 'beep')) // &quot;boop&quot; console.log(utils.get(a, 'foo.bar')) // &quot;bar&quot; &lt;static&gt; getSuper(instance, isCtor) Return the superclass for the given instance or subclass. If an instance is provided, then finds the parent class of the instance's constructor. Method parameters: Name Type Argument Default Description instance Object | Function Instance or constructor. isCtor Boolean &lt;optional&gt; false Whether instance is a constructor. Return value: Type Description Constructor The superclass (grandparent constructor). Details Since Source 3.0.0 utils.js, line 809 &lt;static&gt; intersection(array1, array2) Return the intersection of two arrays. Method parameters: Name Type Description array1 Array First array. array2 Array Second array. Return value: Type Description Array Array of elements common to both arrays. Details Since Source 3.0.0 utils.js, line 827 &lt;static&gt; isArray(value) Proxy for Array.isArray. Method parameters: Name Type Description value * The value to test. Return value: Type Description Boolean Whether the provided value is an array. Details Since Source 3.0.0 utils.js, line 856 &lt;static&gt; isBlacklisted(prop, blacklist) Return whether prop is matched by any string or regular expression in blacklist. Method parameters: Name Type Description prop String The name of a property to check. blacklist Array Array of strings and regular expressions. Return value: Type Description Boolean Whether prop was matched. Details Since Source 3.0.0 utils.js, line 866 &lt;static&gt; isBoolean(value) Return whether the provided value is a boolean. Method parameters: Name Type Description value * The value to test. Return value: Type Description Boolean Whether the provided value is a boolean. Details Since Source 3.0.0 utils.js, line 890 &lt;static&gt; isDate(value) Return whether the provided value is a date. Method parameters: Name Type Description value * The value to test. Return value: Type Description Date Whether the provided value is a date. Details Since Source 3.0.0 utils.js, line 902 &lt;static&gt; isFunction(value) Return whether the provided value is a function. Method parameters: Name Type Description value * The value to test. Return value: Type Description Boolean Whether the provided value is a function. Details Since Source 3.0.0 utils.js, line 914 &lt;static&gt; isInteger(value) Return whether the provided value is an integer. Method parameters: Name Type Description value * The value to test. Return value: Type Description Boolean Whether the provided value is an integer. Details Since Source 3.0.0 utils.js, line 926 &lt;static&gt; isNull(value) Return whether the provided value is null. Method parameters: Name Type Description value * The value to test. Return value: Type Description Boolean Whether the provided value is null. Details Since Source 3.0.0 utils.js, line 938 &lt;static&gt; isNumber(value) Return whether the provided value is a number. Method parameters: Name Type Description value * The value to test. Return value: Type Description Boolean Whether the provided value is a number. Details Since Source 3.0.0 utils.js, line 950 &lt;static&gt; isObject(value) Return whether the provided value is an object. Method parameters: Name Type Description value * The value to test. Return value: Type Description Boolean Whether the provided value is an object. Details Since Source 3.0.0 utils.js, line 963 &lt;static&gt; isRegExp(value) Return whether the provided value is a regular expression. Method parameters: Name Type Description value * The value to test. Return value: Type Description Boolean Whether the provided value is a regular expression. Details Since Source 3.0.0 utils.js, line 975 &lt;static&gt; isSorN(value) Return whether the provided value is a string or a number. Method parameters: Name Type Description value * The value to test. Return value: Type Description Boolean Whether the provided value is a string or a number. Details Since Source 3.0.0 utils.js, line 987 &lt;static&gt; isString(value) Return whether the provided value is a string. Method parameters: Name Type Description value * The value to test. Return value: Type Description Boolean Whether the provided value is a string. Details Since Source 3.0.0 utils.js, line 999 &lt;static&gt; isUndefined(value) Return whether the provided value is a undefined. Method parameters: Name Type Description value * The value to test. Return value: Type Description Boolean Whether the provided value is a undefined. Details Since Source 3.0.0 utils.js, line 1011 &lt;static&gt; logify(target) Mix in logging capabilities to the target. Method parameters: Name Type Description target * The target. Details Since Source 3.0.0 utils.js, line 1023 &lt;static&gt; noDupeAdd(array, record, fn) Adds the given record to the provided array only if it's not already in the array. Method parameters: Name Type Description array Array The array. record * The value to add. fn Function Callback function passed to utils.findIndex. Details Since Source 3.0.0 utils.js, line 1053 &lt;static&gt; omit(props, keys) Return a shallow copy of the provided object, minus the properties specified in keys. Method parameters: Name Type Description props Object The object to copy. keys Array.&lt;String&gt; Array of strings, representing properties to skip. Return value: Type Description Object Shallow copy of props, minus keys. Details Since Source 3.0.0 utils.js, line 1073 &lt;static&gt; pick(props, keys) Return a shallow copy of the provided object, but only include the properties specified in keys. Method parameters: Name Type Description props Object The object to copy. keys Array.&lt;String&gt; Array of strings, representing properties to keep. Return value: Type Description Object Shallow copy of props, but only including keys. Details Since Source 3.0.0 utils.js, line 1093 &lt;static&gt; plainCopy(value) Return a plain copy of the given value. Method parameters: Name Type Description value * The value to copy. Return value: Type Description * Plain copy of value. Details Since Source See 3.0.0 utils.js, line 1113 utils.copy &lt;static&gt; reject(value) Shortcut for utils.Promise.reject(value). Method parameters: Name Type Argument Description value * &lt;optional&gt; Value with which to reject the Promise. Return value: Type Description Promise Promise reject with value. Details Since Source See 3.0.0 utils.js, line 1126 utils.Promise &lt;static&gt; remove(array, fn) Remove the last item found in array according to the given checker function. Method parameters: Name Type Description array Array The array to search. fn Function Checker function. Details Source utils.js, line 1139 &lt;static&gt; set(object, path, value) Set the value at the provided key or path. Method parameters: Name Type Argument Description object Object The object on which to set a property. path String | Object The key or path to the property. Can also pass in an object of path/value pairs, which will all be set on the target object. value * &lt;optional&gt; The value to set. Details Source utils.js, line 1169 &lt;static&gt; toJson(value) Proxy for JSON.stringify. Method parameters: Name Type Description value * Value to serialize to JSON. Return value: Type Description String JSON string. Details Since Source See 3.0.0 utils.js, line 1232 utils.fromJson &lt;static&gt; unset(object, path) Unset the value at the provided key or path. Method parameters: Name Type Description object Object The object from which to delete the property. path String The key or path to the property. Details Since Source See 3.0.0 utils.js, line 1243 utils.set × Search results Close api.js-data.io • js-data.io "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
